<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/matrix.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/matrix.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="matrix_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_MATRIX_HPP_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_MATRIX_HPP_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2013, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment">               </span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL.">viennacl/forwards.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html" title="Implementation of the ViennaCL scalar class.">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="vector_8hpp.html" title="The vector type with operator-overloads and proxy classes is defined here. Linear algebra operations ...">viennacl/vector.hpp</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="matrix__operations_8hpp.html" title="Implementations of dense matrix related operations including matrix-vector products.">viennacl/linalg/matrix_operations.hpp</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="matrix__size__deducer_8hpp.html" title="Helper implementations that deduce the dimensions of the supplied matrix-valued expressions.">viennacl/tools/matrix_size_deducer.hpp</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="meta_2result__of_8hpp.html" title="A collection of compile time type deductions.">viennacl/meta/result_of.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="enable__if_8hpp.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl/meta/enable_if.hpp</a>&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>viennacl
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036   <span class="comment">//</span>
<a name="l00037"></a>00037   <span class="comment">// Initializer types</span>
<a name="l00038"></a>00038   <span class="comment">//</span>
<a name="l00040"></a>00040 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00041"></a><a class="code" href="classviennacl_1_1identity__matrix.html">00041</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1identity__matrix.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">identity_matrix</a>
<a name="l00042"></a>00042   {
<a name="l00043"></a>00043     <span class="keyword">public</span>:
<a name="l00044"></a><a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">00044</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>         <a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00045"></a><a class="code" href="classviennacl_1_1identity__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">00045</a>       <span class="keyword">typedef</span> SCALARTYPE <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1identity__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a>;
<a name="l00046"></a>00046       
<a name="l00047"></a><a class="code" href="classviennacl_1_1identity__matrix.html#abdfc9d60b625aeb5d289e655b00ba9e7">00047</a>       <a class="code" href="classviennacl_1_1identity__matrix.html#abdfc9d60b625aeb5d289e655b00ba9e7">identity_matrix</a>(<a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s) : size_(s), diag_(1), off_diag_(0) {}
<a name="l00048"></a>00048       
<a name="l00049"></a><a class="code" href="classviennacl_1_1identity__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">00049</a>       <a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1identity__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00050"></a><a class="code" href="classviennacl_1_1identity__matrix.html#a608bdfa643e5a437579aac288fb98f96">00050</a>       <a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1identity__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00051"></a><a class="code" href="classviennacl_1_1identity__matrix.html#a8ef6164c4b022400277da3d392a8258a">00051</a>       <a class="code" href="classviennacl_1_1identity__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> <a class="code" href="classviennacl_1_1identity__matrix.html#a8ef6164c4b022400277da3d392a8258a">operator()</a>(<a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> i, <a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> j)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (i == j) ? diag_ : off_diag_; }
<a name="l00052"></a>00052       
<a name="l00053"></a>00053     <span class="keyword">private</span>:
<a name="l00054"></a>00054       <a class="code" href="classviennacl_1_1identity__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size_;
<a name="l00055"></a>00055       SCALARTYPE diag_;
<a name="l00056"></a>00056       SCALARTYPE off_diag_;
<a name="l00057"></a>00057   };
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   
<a name="l00061"></a>00061   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00062"></a><a class="code" href="classviennacl_1_1zero__matrix.html">00062</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1zero__matrix.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_matrix</a>
<a name="l00063"></a>00063   {
<a name="l00064"></a>00064     <span class="keyword">public</span>:
<a name="l00065"></a><a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">00065</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>         <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00066"></a><a class="code" href="classviennacl_1_1zero__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">00066</a>       <span class="keyword">typedef</span> SCALARTYPE <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1zero__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a>;
<a name="l00067"></a>00067       
<a name="l00068"></a><a class="code" href="classviennacl_1_1zero__matrix.html#a79f075e375881ad5c0c46ae7f883dfd1">00068</a>       <a class="code" href="classviennacl_1_1zero__matrix.html#a79f075e375881ad5c0c46ae7f883dfd1">zero_matrix</a>(<a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s1, <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s2) : size1_(s1), size2_(s2), val_(0) {}
<a name="l00069"></a>00069       
<a name="l00070"></a><a class="code" href="classviennacl_1_1zero__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">00070</a>       <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1zero__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size1_; }
<a name="l00071"></a><a class="code" href="classviennacl_1_1zero__matrix.html#a608bdfa643e5a437579aac288fb98f96">00071</a>       <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1zero__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size2_; }
<a name="l00072"></a><a class="code" href="classviennacl_1_1zero__matrix.html#ab27e17d7a9f7766258b84b34d08be07f">00072</a>       <a class="code" href="classviennacl_1_1zero__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> <a class="code" href="classviennacl_1_1zero__matrix.html#ab27e17d7a9f7766258b84b34d08be07f">operator()</a>(<a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>, <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*j*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> val_; }
<a name="l00073"></a>00073       
<a name="l00074"></a>00074     <span class="keyword">private</span>:
<a name="l00075"></a>00075       <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size1_;
<a name="l00076"></a>00076       <a class="code" href="classviennacl_1_1zero__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size2_;
<a name="l00077"></a>00077       SCALARTYPE val_;
<a name="l00078"></a>00078   };
<a name="l00079"></a>00079   
<a name="l00080"></a>00080   
<a name="l00082"></a>00082   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00083"></a><a class="code" href="classviennacl_1_1scalar__matrix.html">00083</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1scalar__matrix.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_matrix</a>
<a name="l00084"></a>00084   {
<a name="l00085"></a>00085     <span class="keyword">public</span>:
<a name="l00086"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">00086</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>         <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00087"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">00087</a>       <span class="keyword">typedef</span> SCALARTYPE <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1scalar__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a>;
<a name="l00088"></a>00088       
<a name="l00089"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#ac7973e2dffe773e474df0be545f00e6c">00089</a>       <a class="code" href="classviennacl_1_1scalar__matrix.html#ac7973e2dffe773e474df0be545f00e6c">scalar_matrix</a>(<a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s1, <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s2, <a class="code" href="classviennacl_1_1scalar__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> val) : size1_(s1), size2_(s2), value_(val) {}
<a name="l00090"></a>00090       
<a name="l00091"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">00091</a>       <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1scalar__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size1_; }
<a name="l00092"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#a608bdfa643e5a437579aac288fb98f96">00092</a>       <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1scalar__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size2_; }
<a name="l00093"></a><a class="code" href="classviennacl_1_1scalar__matrix.html#ab27e17d7a9f7766258b84b34d08be07f">00093</a>       <a class="code" href="classviennacl_1_1scalar__matrix.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> <a class="code" href="classviennacl_1_1scalar__matrix.html#ab27e17d7a9f7766258b84b34d08be07f">operator()</a>(<a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>, <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*j*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value_; }
<a name="l00094"></a>00094       
<a name="l00095"></a>00095     <span class="keyword">private</span>:
<a name="l00096"></a>00096       <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size1_;
<a name="l00097"></a>00097       <a class="code" href="classviennacl_1_1scalar__matrix.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size2_;
<a name="l00098"></a>00098       SCALARTYPE value_;
<a name="l00099"></a>00099   };
<a name="l00100"></a>00100   
<a name="l00101"></a>00101   
<a name="l00102"></a>00102   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00103"></a><a class="code" href="classviennacl_1_1matrix__expression.html">00103</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>
<a name="l00104"></a>00104   {
<a name="l00105"></a>00105     <span class="keyword">public</span>:
<a name="l00106"></a><a class="code" href="classviennacl_1_1matrix__expression.html#ab107e292e9522c5274cc173ffbc98b47">00106</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> LHS::size_type       <a class="code" href="classviennacl_1_1matrix__expression.html#ab107e292e9522c5274cc173ffbc98b47">size_type</a>;
<a name="l00107"></a>00107       
<a name="l00109"></a>00109       <span class="comment">//*/</span>
<a name="l00110"></a><a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936">00110</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___e_x_t_r_a_c_t_o_r.html#a83bfb3b5edd361e46e5c2c287c8a949f">viennacl::tools::MATRIX_EXTRACTOR&lt;LHS, RHS&gt;::ResultType</a>    <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_type</a>;
<a name="l00111"></a>00111     
<a name="l00112"></a><a class="code" href="classviennacl_1_1matrix__expression.html#a466edf19960e38ab2eecab2109956c53">00112</a>       <a class="code" href="classviennacl_1_1matrix__expression.html#a466edf19960e38ab2eecab2109956c53">matrix_expression</a>(LHS &amp; <a class="code" href="classviennacl_1_1matrix__expression.html#abb680866089de4e937ddc6ce6f1f1830" title="Get left hand side operand.">lhs</a>, RHS &amp; <a class="code" href="classviennacl_1_1matrix__expression.html#a563f5aecaa0755006225235e44a11a82" title="Get right hand side operand.">rhs</a>) : lhs_(lhs), rhs_(rhs) {}
<a name="l00113"></a>00113       
<a name="l00116"></a><a class="code" href="classviennacl_1_1matrix__expression.html#abb680866089de4e937ddc6ce6f1f1830">00116</a>       LHS &amp; <a class="code" href="classviennacl_1_1matrix__expression.html#abb680866089de4e937ddc6ce6f1f1830" title="Get left hand side operand.">lhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> lhs_; }
<a name="l00119"></a><a class="code" href="classviennacl_1_1matrix__expression.html#a563f5aecaa0755006225235e44a11a82">00119</a>       RHS &amp; <a class="code" href="classviennacl_1_1matrix__expression.html#a563f5aecaa0755006225235e44a11a82" title="Get right hand side operand.">rhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rhs_; }
<a name="l00120"></a>00120       
<a name="l00122"></a><a class="code" href="classviennacl_1_1matrix__expression.html#a86ca1671903a30f6c861897f6b516c12">00122</a>       std::size_t <a class="code" href="classviennacl_1_1matrix__expression.html#a86ca1671903a30f6c861897f6b516c12" title="Returns the size of the result vector.">size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a86ca1671903a30f6c861897f6b516c12" title="Returns the size of the result vector.">viennacl::tools::MATRIX_SIZE_DEDUCER&lt;LHS, RHS, OP&gt;::size1</a>(lhs_, rhs_); }
<a name="l00123"></a><a class="code" href="classviennacl_1_1matrix__expression.html#acfb022af062a8199d74d46018edb21ed">00123</a>       std::size_t <a class="code" href="classviennacl_1_1matrix__expression.html#acfb022af062a8199d74d46018edb21ed">size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html#acfb022af062a8199d74d46018edb21ed">viennacl::tools::MATRIX_SIZE_DEDUCER&lt;LHS, RHS, OP&gt;::size2</a>(lhs_, rhs_); }
<a name="l00124"></a>00124       
<a name="l00125"></a>00125     <span class="keyword">private</span>:
<a name="l00127"></a>00127       <span class="keyword">typename</span> result_of::matrix_expression_internal_storage&lt;LHS&gt;::type lhs_;
<a name="l00129"></a>00129       <span class="keyword">typename</span> result_of::matrix_expression_internal_storage&lt;RHS&gt;::type rhs_;
<a name="l00130"></a>00130   };
<a name="l00131"></a>00131   
<a name="l00132"></a>00132   
<a name="l00134"></a><a class="code" href="structviennacl_1_1row__iteration.html">00134</a>   <span class="keyword">struct </span><a class="code" href="structviennacl_1_1row__iteration.html" title="A tag indicating iteration along increasing row index of a matrix.">row_iteration</a> {};
<a name="l00135"></a>00135   
<a name="l00137"></a><a class="code" href="structviennacl_1_1col__iteration.html">00137</a>   <span class="keyword">struct </span><a class="code" href="structviennacl_1_1col__iteration.html" title="A tag indicating iteration along increasing columns index of a matrix.">col_iteration</a> {};
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="comment">//STL-like iterator. TODO: STL-compliance...</span>
<a name="l00140"></a>00140   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ROWCOL, <span class="keyword">typename</span> MATRIXTYPE&gt;
<a name="l00141"></a><a class="code" href="classviennacl_1_1matrix__iterator.html">00141</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a>
<a name="l00142"></a>00142   {
<a name="l00143"></a>00143       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__iterator.html">matrix_iterator&lt;ROWCOL, MATRIXTYPE&gt;</a>    <a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a>;
<a name="l00144"></a>00144     <span class="keyword">public</span>:
<a name="l00145"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a4d1008b55c3e6de3a019d5514c4393d8">00145</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> MATRIXTYPE::value_type       <a class="code" href="classviennacl_1_1matrix__iterator.html#a4d1008b55c3e6de3a019d5514c4393d8">value_type</a>;
<a name="l00146"></a>00146       
<a name="l00147"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a84946926e76015bccd2130d0f18cceca">00147</a>       <a class="code" href="classviennacl_1_1matrix__iterator.html#a84946926e76015bccd2130d0f18cceca">matrix_iterator</a>(MATRIXTYPE &amp; mat, 
<a name="l00148"></a>00148                       std::size_t start_row,
<a name="l00149"></a>00149                       std::size_t start_col) : mat_(mat), row_(start_row), col_(start_col) {};
<a name="l00150"></a>00150       
<a name="l00151"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a94001b4941ee37e508c3442528389b16">00151</a>       <a class="code" href="classviennacl_1_1matrix__iterator.html#a4d1008b55c3e6de3a019d5514c4393d8">value_type</a> <a class="code" href="classviennacl_1_1matrix__iterator.html#a94001b4941ee37e508c3442528389b16">operator*</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> mat_(row_, col_); }
<a name="l00152"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#aa5055e4100b53acad1be8697088ff1dc">00152</a>       <a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__iterator.html#aa5055e4100b53acad1be8697088ff1dc">operator++</a>(<span class="keywordtype">void</span>) { <a class="code" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html">viennacl::tools::MATRIX_ITERATOR_INCREMENTER&lt;ROWCOL, MATRIXTYPE&gt;::apply</a>(mat_, row_, col_); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00153"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a4419c6af964a7de542db8474f8ef1091">00153</a>       <a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__iterator.html#a4419c6af964a7de542db8474f8ef1091">operator++</a>(<span class="keywordtype">int</span>) { <a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a> tmp = *<span class="keyword">this</span>; ++(*this); <span class="keywordflow">return</span> tmp; }
<a name="l00154"></a>00154       
<a name="l00155"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#ad25b9ad360f06fda1535074b749cf023">00155</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1matrix__iterator.html#ad25b9ad360f06fda1535074b749cf023">operator==</a>(<a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a> <span class="keyword">const</span> &amp; other) { <span class="keywordflow">return</span> (row_ == other.row_) &amp;&amp; (col_ == other.col_); }
<a name="l00156"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a111e186f57ea74111730a997ba77ea17">00156</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1matrix__iterator.html#a111e186f57ea74111730a997ba77ea17">operator!=</a>(<a class="code" href="classviennacl_1_1matrix__iterator.html">self_type</a> <span class="keyword">const</span> &amp; other) { <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other); }
<a name="l00157"></a>00157       
<a name="l00158"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#ae658148a9e0a4018710cedddf71369c3">00158</a>       <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> <a class="code" href="classviennacl_1_1matrix__iterator.html#ae658148a9e0a4018710cedddf71369c3">index1</a>() { <span class="keywordflow">return</span> row_; }
<a name="l00159"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#ad1d9cfb91491b08bbf42e0d8ec19a98b">00159</a>       <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> <a class="code" href="classviennacl_1_1matrix__iterator.html#ad1d9cfb91491b08bbf42e0d8ec19a98b">index2</a>() { <span class="keywordflow">return</span> col_; }
<a name="l00160"></a>00160       
<a name="l00161"></a><a class="code" href="classviennacl_1_1matrix__iterator.html#a472f3f82844b2d229acbd12e34d6764b">00161</a>       MATRIXTYPE &amp; <a class="code" href="classviennacl_1_1matrix__iterator.html#a472f3f82844b2d229acbd12e34d6764b">operator()</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mat_; }
<a name="l00162"></a>00162     
<a name="l00163"></a>00163     <span class="keyword">private</span>:
<a name="l00164"></a>00164       MATRIXTYPE &amp; mat_;
<a name="l00165"></a>00165       <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> row_;
<a name="l00166"></a>00166       <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> col_;
<a name="l00167"></a>00167   };
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 
<a name="l00176"></a>00176   <span class="keyword">template</span> &lt;<span class="keyword">class </span>SCALARTYPE, <span class="keyword">typename</span> F, <span class="keyword">typename</span> SizeType <span class="comment">/* see forwards.h for default type */</span>, <span class="keyword">typename</span> DistanceType <span class="comment">/* see forwards.h for default type */</span>&gt;
<a name="l00177"></a><a class="code" href="classviennacl_1_1matrix__base.html">00177</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base</a>
<a name="l00178"></a>00178   {
<a name="l00179"></a>00179       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;SCALARTYPE, F, SizeType, DistanceType&gt;</a>          <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a>;
<a name="l00180"></a>00180     <span class="keyword">public</span>:
<a name="l00181"></a>00181       
<a name="l00182"></a><a class="code" href="classviennacl_1_1matrix__base.html#a7c957b95ad10d3115a7137f2e962a76f">00182</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__iterator.html">matrix_iterator&lt;row_iteration, self_type &gt;</a>   <a class="code" href="classviennacl_1_1matrix__base.html#a7c957b95ad10d3115a7137f2e962a76f">iterator1</a>;
<a name="l00183"></a><a class="code" href="classviennacl_1_1matrix__base.html#a35947ea4855c8d7b1cd5453c8ea9d81f">00183</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__iterator.html">matrix_iterator&lt;col_iteration, self_type &gt;</a>   <a class="code" href="classviennacl_1_1matrix__base.html#a35947ea4855c8d7b1cd5453c8ea9d81f">iterator2</a>;
<a name="l00184"></a><a class="code" href="classviennacl_1_1matrix__base.html#aed985c700866b1bae61cb8bcd5d322fe">00184</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;typename viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT&lt;SCALARTYPE&gt;::ResultType</a>&gt;   <a class="code" href="classviennacl_1_1matrix__base.html#aed985c700866b1bae61cb8bcd5d322fe">value_type</a>;
<a name="l00185"></a><a class="code" href="classviennacl_1_1matrix__base.html#afe14f79ef563aa2fc6b051029e0eb93b">00185</a>       <span class="keyword">typedef</span> SCALARTYPE                                                          <a class="code" href="classviennacl_1_1matrix__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a>;
<a name="l00186"></a><a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">00186</a>       <span class="keyword">typedef</span> SizeType                                                            <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>;
<a name="l00187"></a><a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">00187</a>       <span class="keyword">typedef</span> DistanceType                                                        <a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a>;
<a name="l00188"></a><a class="code" href="classviennacl_1_1matrix__base.html#a54da31d88e477d0e9f61b0715fdc8162">00188</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">backend::mem_handle</a>                                                 <a class="code" href="classviennacl_1_1matrix__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a>;
<a name="l00189"></a><a class="code" href="classviennacl_1_1matrix__base.html#a2e790b9737b40b4602341f07f87a8e9e">00189</a>       <span class="keyword">typedef</span> F                                                                   <a class="code" href="classviennacl_1_1matrix__base.html#a2e790b9737b40b4602341f07f87a8e9e">orientation_functor</a>;
<a name="l00190"></a><a class="code" href="classviennacl_1_1matrix__base.html#aae659434f4f7cdb21ae9ea0b79c50e38">00190</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> F::orientation_category                                    <a class="code" href="classviennacl_1_1matrix__base.html#aae659434f4f7cdb21ae9ea0b79c50e38">orientation_category</a>;
<a name="l00191"></a>00191       
<a name="l00193"></a><a class="code" href="classviennacl_1_1matrix__base.html#af4cfd0b12d0e044b73b5d5d825ace273">00193</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix__base.html#af4cfd0b12d0e044b73b5d5d825ace273" title="The default constructor. Does not allocate any memory.">matrix_base</a>() : size1_(0), size2_(0), start1_(0), start2_(0), stride1_(1), stride2_(1), internal_size1_(0), internal_size2_(0) {};
<a name="l00194"></a>00194       
<a name="l00200"></a><a class="code" href="classviennacl_1_1matrix__base.html#ad7cde304aaf10d0a5e27f05fac53c72b">00200</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix__base.html#af4cfd0b12d0e044b73b5d5d825ace273" title="The default constructor. Does not allocate any memory.">matrix_base</a>(<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> columns)
<a name="l00201"></a>00201           : size1_(rows), size2_(columns), start1_(0), start2_(0), stride1_(1), stride2_(1), internal_size1_(rows), internal_size2_(columns)
<a name="l00202"></a>00202       {
<a name="l00203"></a>00203         <span class="keywordflow">if</span> (rows &gt; 0 &amp;&amp; columns &gt; 0)
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205           std::vector&lt;SCALARTYPE&gt; temp(<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00206"></a>00206           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(temp[0]));
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208       }
<a name="l00209"></a>00209   
<a name="l00210"></a><a class="code" href="classviennacl_1_1matrix__base.html#aa314fc2cc63b1d99db05afae53939c31">00210</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix__base.html#af4cfd0b12d0e044b73b5d5d825ace273" title="The default constructor. Does not allocate any memory.">matrix_base</a>(<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> columns, <a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> mem_type)
<a name="l00211"></a>00211           : size1_(rows), size2_(columns), start1_(0), start2_(0), stride1_(1), stride2_(1), internal_size1_(rows), internal_size2_(columns)
<a name="l00212"></a>00212       {
<a name="l00213"></a>00213         elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a016f1218a02268c06c3009803cc3073d" title="Switches the currently active handle. If no support for that backend is provided, an exception is thr...">switch_active_handle_id</a>(mem_type);
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (rows &gt; 0 &amp;&amp; columns &gt; 0)
<a name="l00215"></a>00215         {
<a name="l00216"></a>00216           std::vector&lt;SCALARTYPE&gt; temp(<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00217"></a>00217           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(temp[0]));
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219       }
<a name="l00220"></a>00220         
<a name="l00221"></a><a class="code" href="classviennacl_1_1matrix__base.html#aae58a107fc7b546cffa3b52f3e0e54bd">00221</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix__base.html#af4cfd0b12d0e044b73b5d5d825ace273" title="The default constructor. Does not allocate any memory.">matrix_base</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> &amp; h,
<a name="l00222"></a>00222                            <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_size1, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_start1, <a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> mat_stride1, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_internal_size1,
<a name="l00223"></a>00223                            <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_size2, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_start2, <a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> mat_stride2, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> mat_internal_size2) 
<a name="l00224"></a>00224         : size1_(mat_size1), size2_(mat_size2),
<a name="l00225"></a>00225           start1_(mat_start1), start2_(mat_start2),
<a name="l00226"></a>00226           stride1_(mat_stride1), stride2_(mat_stride2),
<a name="l00227"></a>00227           internal_size1_(mat_internal_size1), internal_size2_(mat_internal_size2),
<a name="l00228"></a>00228           elements_(h) {}
<a name="l00229"></a>00229   
<a name="l00230"></a><a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">00230</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; other)  <span class="comment">//enables implicit conversions</span>
<a name="l00231"></a>00231       {
<a name="l00232"></a>00232         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0)
<a name="l00233"></a>00233           <a class="code" href="classviennacl_1_1matrix__base.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can be preserved, but.">resize</a>(other.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), other.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(), <span class="keyword">false</span>);
<a name="l00234"></a>00234         
<a name="l00235"></a>00235         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(*<span class="keyword">this</span>,
<a name="l00236"></a>00236                              other, <a class="code" href="classviennacl_1_1matrix__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a>(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00237"></a>00237         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00238"></a>00238       }
<a name="l00239"></a>00239       
<a name="l00240"></a>00240   
<a name="l00245"></a>00245       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP&gt;
<a name="l00246"></a>00246       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l00247"></a>00247                                     self_type &amp; &gt;::type
<a name="l00248"></a><a class="code" href="classviennacl_1_1matrix__base.html#ad2e47e21d79579d5b597e37f89ecbd31">00248</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>, <span class="keyword">const</span> S1, OP&gt; &amp; proxy)
<a name="l00249"></a>00249       {
<a name="l00250"></a>00250         assert(  (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0)
<a name="l00251"></a>00251               &amp;&amp; (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00252"></a>00252               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l00253"></a>00253         
<a name="l00254"></a>00254         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0 &amp;&amp; proxy.lhs().internal_size() &gt; 0)
<a name="l00255"></a>00255         {
<a name="l00256"></a>00256           size1_ = proxy.lhs().size1();
<a name="l00257"></a>00257           size2_ = proxy.lhs().size2();
<a name="l00258"></a>00258           internal_size1_ = size1_;
<a name="l00259"></a>00259           internal_size2_ = size2_;
<a name="l00260"></a>00260           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00261"></a>00261         } 
<a name="l00262"></a>00262   
<a name="l00263"></a>00263         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00264"></a>00264           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(*<span class="keyword">this</span>,
<a name="l00265"></a>00265                                 proxy.lhs(), proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), <span class="keyword">false</span>);
<a name="l00266"></a>00266         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00267"></a>00267       }
<a name="l00268"></a>00268   
<a name="l00269"></a>00269       <span class="comment">//m1 = m2 +- m3; </span>
<a name="l00274"></a>00274 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> OP&gt;
<a name="l00275"></a>00275       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>,
<a name="l00276"></a>00276                                     self_type &amp;&gt;::type
<a name="l00277"></a><a class="code" href="classviennacl_1_1matrix__base.html#aa5efe2b611f0a370f2d4d897432f13b0">00277</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00278"></a>00278                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00279"></a>00279                                            OP&gt; &amp; proxy)
<a name="l00280"></a>00280       {
<a name="l00281"></a>00281         assert(  (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0)
<a name="l00282"></a>00282               &amp;&amp; (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00283"></a>00283               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l00284"></a>00284         
<a name="l00285"></a>00285         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0 &amp;&amp; proxy.lhs().internal_size() &gt; 0)
<a name="l00286"></a>00286         {
<a name="l00287"></a>00287           size1_ = proxy.lhs().size1();
<a name="l00288"></a>00288           size2_ = proxy.lhs().size2();
<a name="l00289"></a>00289           internal_size1_ = size1_;
<a name="l00290"></a>00290           internal_size2_ = size2_;
<a name="l00291"></a>00291           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00292"></a>00292         } 
<a name="l00293"></a>00293   
<a name="l00294"></a>00294         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00295"></a>00295           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>, 
<a name="l00296"></a>00296                                   proxy.lhs(), SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00297"></a>00297                                   proxy.rhs(), SCALARTYPE(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l00298"></a>00298         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00299"></a>00299       }
<a name="l00300"></a>00300       
<a name="l00305"></a>00305       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l00306"></a>00306                 <span class="keyword">typename</span> OP&gt;
<a name="l00307"></a>00307       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l00308"></a>00308                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00309"></a>00309                                     self_type &amp;&gt;::type
<a name="l00310"></a><a class="code" href="classviennacl_1_1matrix__base.html#a813b30bac25ad9554da7af7243bc9e8c">00310</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00311"></a>00311                                             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l00312"></a>00312                                             OP&gt; &amp; proxy)
<a name="l00313"></a>00313       {
<a name="l00314"></a>00314         assert(  (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0)
<a name="l00315"></a>00315               &amp;&amp; (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00316"></a>00316               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l00317"></a>00317         
<a name="l00318"></a>00318         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0 &amp;&amp; proxy.lhs().internal_size() &gt; 0)
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320           size1_ = proxy.lhs().size1();
<a name="l00321"></a>00321           size2_ = proxy.lhs().size2();
<a name="l00322"></a>00322           internal_size1_ = size1_;
<a name="l00323"></a>00323           internal_size2_ = size2_;
<a name="l00324"></a>00324           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00325"></a>00325         } 
<a name="l00326"></a>00326   
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00328"></a>00328         {
<a name="l00329"></a>00329           <span class="keywordtype">bool</span> flip_sign_2 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00330"></a>00330           <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a>)
<a name="l00331"></a>00331             flip_sign_2 = !flip_sign_2;
<a name="l00332"></a>00332           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>, 
<a name="l00333"></a>00333                                   proxy.lhs(),         SCALARTYPE(1.0), 1, false                                             , <span class="keyword">false</span>,
<a name="l00334"></a>00334                                   proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_2);
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00337"></a>00337       }
<a name="l00338"></a>00338   
<a name="l00343"></a>00343       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l00344"></a>00344                 <span class="keyword">typename</span> OP&gt;
<a name="l00345"></a>00345       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP1&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a>)
<a name="l00346"></a>00346                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00347"></a>00347                                     self_type &amp;&gt;::type
<a name="l00348"></a><a class="code" href="classviennacl_1_1matrix__base.html#a29963ba1560f2d19adadeb139ca24180">00348</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l00349"></a>00349                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00350"></a>00350                                            OP&gt; &amp; proxy)
<a name="l00351"></a>00351       {
<a name="l00352"></a>00352         assert(  (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0)
<a name="l00353"></a>00353               &amp;&amp; (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00354"></a>00354               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l00355"></a>00355         
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0 &amp;&amp; proxy.rhs().internal_size() &gt; 0)
<a name="l00357"></a>00357         {
<a name="l00358"></a>00358           size1_ = proxy.lhs().size1();
<a name="l00359"></a>00359           size2_ = proxy.lhs().size2();
<a name="l00360"></a>00360           internal_size1_ = size1_;
<a name="l00361"></a>00361           internal_size2_ = size2_;
<a name="l00362"></a>00362           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00363"></a>00363         } 
<a name="l00364"></a>00364   
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00366"></a>00366           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>, 
<a name="l00367"></a>00367                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l00368"></a>00368                                 proxy.rhs(),         SCALARTYPE(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l00369"></a>00369         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00370"></a>00370       }
<a name="l00371"></a>00371       
<a name="l00376"></a>00376       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l00377"></a>00377                 <span class="keyword">typename</span> F1, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l00378"></a>00378                 <span class="keyword">typename</span> F2, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l00379"></a>00379                 <span class="keyword">typename</span> OP&gt;
<a name="l00380"></a>00380       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP1&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a>)
<a name="l00381"></a>00381                                     &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l00382"></a>00382                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00383"></a>00383                                     self_type &amp;&gt;::type
<a name="l00384"></a><a class="code" href="classviennacl_1_1matrix__base.html#aec877d01945e65950718de15b87952bf">00384</a>       <span class="keyword">operator</span> = (<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l00385"></a>00385                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l00386"></a>00386                                            OP&gt; &amp; proxy)
<a name="l00387"></a>00387       {
<a name="l00388"></a>00388         assert(  (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0)
<a name="l00389"></a>00389               &amp;&amp; (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() || <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00390"></a>00390               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l00391"></a>00391         
<a name="l00392"></a>00392         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0 &amp;&amp; proxy.lhs().lhs().internal_size() &gt; 0)
<a name="l00393"></a>00393         {
<a name="l00394"></a>00394           size1_ = proxy.lhs().size1();
<a name="l00395"></a>00395           size2_ = proxy.lhs().size2();
<a name="l00396"></a>00396           internal_size1_ = size1_;
<a name="l00397"></a>00397           internal_size2_ = size2_;
<a name="l00398"></a>00398           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00399"></a>00399         } 
<a name="l00400"></a>00400   
<a name="l00401"></a>00401         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00402"></a>00402         {
<a name="l00403"></a>00403           <span class="keywordtype">bool</span> flip_sign_2 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00404"></a>00404           <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a>)
<a name="l00405"></a>00405             flip_sign_2 = !flip_sign_2;
<a name="l00406"></a>00406           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>, 
<a name="l00407"></a>00407                                   proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l00408"></a>00408                                   proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_2);
<a name="l00409"></a>00409         }
<a name="l00410"></a>00410         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00411"></a>00411       }
<a name="l00412"></a>00412       
<a name="l00413"></a>00413       
<a name="l00415"></a><a class="code" href="classviennacl_1_1matrix__base.html#a709f8975d7a71074ac37b51f20fc4ced">00415</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<a class="code" href="classviennacl_1_1identity__matrix.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">identity_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m)
<a name="l00416"></a>00416       {
<a name="l00417"></a>00417         assert( (m.<a class="code" href="classviennacl_1_1identity__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>() == size1_ || size1_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00418"></a>00418         assert( (m.<a class="code" href="classviennacl_1_1identity__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>() == size2_ || size2_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00419"></a>00419   
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0)
<a name="l00421"></a>00421         {
<a name="l00422"></a>00422           size1_ = m.<a class="code" href="classviennacl_1_1identity__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>();
<a name="l00423"></a>00423           size2_ = m.<a class="code" href="classviennacl_1_1identity__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>();
<a name="l00424"></a>00424           internal_size1_ = size1_;
<a name="l00425"></a>00425           internal_size2_ = size2_;
<a name="l00426"></a>00426           <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00427"></a>00427             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());  
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429         
<a name="l00430"></a>00430         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00431"></a>00431         {
<a name="l00432"></a>00432           <a class="code" href="classviennacl_1_1matrix__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero.">clear</a>();
<a name="l00433"></a>00433           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a00dffd5366f688a32fc26bdb265c49eb">viennacl::linalg::matrix_diagonal_assign</a>(*<span class="keyword">this</span>, m(0,0));
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435         
<a name="l00436"></a>00436         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00437"></a>00437       }
<a name="l00438"></a>00438       
<a name="l00440"></a><a class="code" href="classviennacl_1_1matrix__base.html#ac7edb7074fed882530274a73312b8762">00440</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<a class="code" href="classviennacl_1_1zero__matrix.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m)
<a name="l00441"></a>00441       {
<a name="l00442"></a>00442         assert( (m.<a class="code" href="classviennacl_1_1zero__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>() == size1_ || size1_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00443"></a>00443         assert( (m.<a class="code" href="classviennacl_1_1zero__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>() == size2_ || size2_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00444"></a>00444   
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0)
<a name="l00446"></a>00446         {
<a name="l00447"></a>00447           size1_ = m.<a class="code" href="classviennacl_1_1zero__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>();
<a name="l00448"></a>00448           size2_ = m.<a class="code" href="classviennacl_1_1zero__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>();
<a name="l00449"></a>00449           internal_size1_ = size1_;
<a name="l00450"></a>00450           internal_size2_ = size2_;
<a name="l00451"></a>00451           <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00452"></a>00452             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());  
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454         
<a name="l00455"></a>00455         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00456"></a>00456           <a class="code" href="classviennacl_1_1matrix__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero.">clear</a>();
<a name="l00457"></a>00457         
<a name="l00458"></a>00458         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00459"></a>00459       }
<a name="l00460"></a>00460   
<a name="l00462"></a><a class="code" href="classviennacl_1_1matrix__base.html#ab6e9d8d1d18e7518ae74272bf17fc780">00462</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<a class="code" href="classviennacl_1_1scalar__matrix.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m)
<a name="l00463"></a>00463       {
<a name="l00464"></a>00464         assert( (m.<a class="code" href="classviennacl_1_1scalar__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>() == size1_ || size1_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00465"></a>00465         assert( (m.<a class="code" href="classviennacl_1_1scalar__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>() == size2_ || size2_ == 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch!&quot;</span>) );
<a name="l00466"></a>00466   
<a name="l00467"></a>00467         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() == 0)
<a name="l00468"></a>00468         {
<a name="l00469"></a>00469           size1_ = m.<a class="code" href="classviennacl_1_1scalar__matrix.html#a7dd094a9c9324a396059b30e5bc6c997">size1</a>();
<a name="l00470"></a>00470           size2_ = m.<a class="code" href="classviennacl_1_1scalar__matrix.html#a608bdfa643e5a437579aac288fb98f96">size2</a>();
<a name="l00471"></a>00471           internal_size1_ = size1_;
<a name="l00472"></a>00472           internal_size2_ = size2_;
<a name="l00473"></a>00473           <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00474"></a>00474             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());  
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476         
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00478"></a>00478         {
<a name="l00479"></a>00479           <a class="code" href="classviennacl_1_1matrix__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero.">clear</a>();
<a name="l00480"></a>00480           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a67d52597ebfd395495a2c8c967226d13">viennacl::linalg::matrix_assign</a>(*<span class="keyword">this</span>, m(0,0));
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482         
<a name="l00483"></a>00483         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00484"></a>00484       }
<a name="l00485"></a>00485       
<a name="l00486"></a>00486       
<a name="l00487"></a>00487       <span class="comment">//read-write access to an element of the matrix/matrix_range/matrix_slice</span>
<a name="l00490"></a><a class="code" href="classviennacl_1_1matrix__base.html#af6d344286b7a33707dbd8b1bddd5cfbf">00490</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1matrix__base.html#af6d344286b7a33707dbd8b1bddd5cfbf" title="Read-write access to a single element of the matrix/matrix_range/matrix_slice.">operator()</a>(<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> row_index, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> col_index)
<a name="l00491"></a>00491       {
<a name="l00492"></a>00492         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(F::mem_index(start1_ + stride1_ * row_index, start2_ + stride2_ * col_index, <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()), elements_);
<a name="l00493"></a>00493       }
<a name="l00494"></a>00494       
<a name="l00497"></a><a class="code" href="classviennacl_1_1matrix__base.html#a1fdcd6cca1560ccd5d1d861910685820">00497</a>       <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1matrix__base.html#af6d344286b7a33707dbd8b1bddd5cfbf" title="Read-write access to a single element of the matrix/matrix_range/matrix_slice.">operator()</a>(<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> row_index, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> col_index)<span class="keyword"> const</span>
<a name="l00498"></a>00498 <span class="keyword">      </span>{
<a name="l00499"></a>00499         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a>(F::mem_index(start1_ + stride1_ * row_index, start2_ + stride2_ * col_index, <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()), elements_);
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       
<a name="l00502"></a>00502       <span class="comment">//</span>
<a name="l00503"></a>00503       <span class="comment">// Operator overloads for enabling implicit conversions:</span>
<a name="l00504"></a>00504       <span class="comment">//</span>
<a name="l00505"></a><a class="code" href="classviennacl_1_1matrix__base.html#a64495311aee2ab446c0bfc15f9a174de">00505</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a64495311aee2ab446c0bfc15f9a174de">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; other) 
<a name="l00506"></a>00506       {
<a name="l00507"></a>00507         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>,
<a name="l00508"></a>00508                                 *<span class="keyword">this</span>, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00509"></a>00509                                 other, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00510"></a>00510         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00511"></a>00511       }
<a name="l00512"></a>00512   
<a name="l00513"></a><a class="code" href="classviennacl_1_1matrix__base.html#a3a333bbb28cd659370d81dcd5e940b5b">00513</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a3a333bbb28cd659370d81dcd5e940b5b">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; other) 
<a name="l00514"></a>00514       {
<a name="l00515"></a>00515         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(*<span class="keyword">this</span>,
<a name="l00516"></a>00516                                 *<span class="keyword">this</span>, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00517"></a>00517                                 other, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l00518"></a>00518         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00519"></a>00519       }
<a name="l00520"></a>00520       
<a name="l00523"></a><a class="code" href="classviennacl_1_1matrix__base.html#a131b09f05f2e3a9aceb0b376fb23b638">00523</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a131b09f05f2e3a9aceb0b376fb23b638" title="Scales a matrix by a CPU scalar value.">operator *= </a>(SCALARTYPE val)
<a name="l00524"></a>00524       {
<a name="l00525"></a>00525         <span class="comment">//viennacl::linalg::inplace_mult(*this, val);</span>
<a name="l00526"></a>00526         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(*<span class="keyword">this</span>,
<a name="l00527"></a>00527                               *<span class="keyword">this</span>, val, 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00528"></a>00528         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00529"></a>00529       }
<a name="l00530"></a>00530       
<a name="l00533"></a><a class="code" href="classviennacl_1_1matrix__base.html#ac0fce9b73d5213e8604dc604e71a608e">00533</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#ac0fce9b73d5213e8604dc604e71a608e" title="Scales this matrix by a CPU scalar value.">operator /= </a>(SCALARTYPE val)
<a name="l00534"></a>00534       {
<a name="l00535"></a>00535         <span class="comment">//viennacl::linalg::inplace_mult(*this, static_cast&lt;SCALARTYPE&gt;(1) / val);</span>
<a name="l00536"></a>00536         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(*<span class="keyword">this</span>,
<a name="l00537"></a>00537                               *<span class="keyword">this</span>, val, 1, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l00538"></a>00538         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00539"></a>00539       }
<a name="l00540"></a>00540       
<a name="l00541"></a>00541       
<a name="l00543"></a><a class="code" href="classviennacl_1_1matrix__base.html#a25574e90b0307cf4eca29bdf78d995b2">00543</a>       <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const self_type, const SCALARTYPE, op_prod&gt;</a> <a class="code" href="classviennacl_1_1matrix__base.html#a25574e90b0307cf4eca29bdf78d995b2" title="Sign flip for the matrix. Emulated to be equivalent to -1.0 * matrix.">operator-</a>()<span class="keyword"> const</span>
<a name="l00544"></a>00544 <span class="keyword">      </span>{
<a name="l00545"></a>00545         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const self_type, const SCALARTYPE, op_prod&gt;</a>(*<span class="keyword">this</span>, SCALARTYPE(-1.0));
<a name="l00546"></a>00546       }
<a name="l00547"></a>00547       
<a name="l00548"></a>00548       
<a name="l00549"></a>00549       <span class="comment">//</span>
<a name="l00550"></a>00550       <span class="comment">// Matrix-Matrix products:</span>
<a name="l00551"></a>00551       <span class="comment">//</span>
<a name="l00552"></a>00552       
<a name="l00553"></a>00553       <span class="comment">//this = A * B and related (with trans())</span>
<a name="l00554"></a>00554       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00555"></a><a class="code" href="classviennacl_1_1matrix__base.html#acfe4567d7ce931de63636b64deab1ea1">00555</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00556"></a>00556                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00557"></a>00557                                                        op_prod &gt; &amp; proxy) 
<a name="l00558"></a>00558       {
<a name="l00559"></a>00559         <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, 1.0, 0.0);
<a name="l00560"></a>00560         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00561"></a>00561       }
<a name="l00562"></a>00562       
<a name="l00563"></a>00563       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00564"></a><a class="code" href="classviennacl_1_1matrix__base.html#aceb12f1af15e017d7bffb64aec9e60a4">00564</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00565"></a>00565                                                                                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00566"></a>00566                                                                                op_trans&gt;,
<a name="l00567"></a>00567                                                       <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00568"></a>00568                                                       op_prod &gt; &amp; proxy) 
<a name="l00569"></a>00569       {
<a name="l00570"></a>00570         <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, 1.0, 0.0);
<a name="l00571"></a>00571         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00572"></a>00572       }
<a name="l00573"></a>00573       
<a name="l00574"></a>00574       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00575"></a><a class="code" href="classviennacl_1_1matrix__base.html#af1c66fae392f0f153eba78ce9e5d9886">00575</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00576"></a>00576                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00577"></a>00577                                                                                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00578"></a>00578                                                                                op_trans&gt;,
<a name="l00579"></a>00579                                                       op_prod &gt; &amp; proxy) 
<a name="l00580"></a>00580       {
<a name="l00581"></a>00581         <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, 1.0, 0.0);
<a name="l00582"></a>00582         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00583"></a>00583       }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00586"></a><a class="code" href="classviennacl_1_1matrix__base.html#a0b8e87bab7a04f93fe40800ef0da6d74">00586</a>       <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00587"></a>00587                                                                                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F1&gt;</a>,
<a name="l00588"></a>00588                                                                                op_trans&gt;,
<a name="l00589"></a>00589                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00590"></a>00590                                                                                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F2&gt;</a>,
<a name="l00591"></a>00591                                                                                op_trans&gt;,
<a name="l00592"></a>00592                                                       op_prod &gt; &amp; proxy) 
<a name="l00593"></a>00593       {
<a name="l00594"></a>00594         <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, 1.0, 0.0);
<a name="l00595"></a>00595         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00596"></a>00596       }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   
<a name="l00600"></a><a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997">00600</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size1_;}
<a name="l00602"></a><a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96">00602</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size2_; }
<a name="l00603"></a>00603   
<a name="l00605"></a><a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de">00605</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> start1_;}
<a name="l00607"></a><a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602">00607</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> start2_; }
<a name="l00608"></a>00608   
<a name="l00610"></a><a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787">00610</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stride1_;}
<a name="l00612"></a><a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc">00612</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stride2_; }
<a name="l00613"></a>00613       
<a name="l00615"></a><a class="code" href="classviennacl_1_1matrix__base.html#ac8bb3912a3ce86b15842e79d0b421204">00615</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1matrix__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero.">clear</a>()
<a name="l00616"></a>00616       {
<a name="l00617"></a>00617         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a67d52597ebfd395495a2c8c967226d13">viennacl::linalg::matrix_assign</a>(*<span class="keyword">this</span>, SCALARTYPE(0));
<a name="l00618"></a>00618       }
<a name="l00619"></a>00619       
<a name="l00620"></a>00620       
<a name="l00621"></a>00621       <span class="comment">//const unsigned int row_stride() const { return roundUpToNextMultiple&lt;unsigned int&gt;(columns(), ALIGNMENT); }</span>
<a name="l00623"></a><a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be">00623</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_size1_; }
<a name="l00625"></a><a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba">00625</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_size2_; }
<a name="l00627"></a><a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c">00627</a>       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>() * <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>(); }
<a name="l00628"></a>00628       
<a name="l00630"></a><a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9">00630</a>             <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>()       { <span class="keywordflow">return</span> elements_; }
<a name="l00632"></a><a class="code" href="classviennacl_1_1matrix__base.html#a0830e530145e6372224c89153128e938">00632</a>       <span class="keyword">const</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> &amp; <a class="code" href="classviennacl_1_1matrix__base.html#a0830e530145e6372224c89153128e938" title="Returns the OpenCL handle, const-version.">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> elements_; }
<a name="l00633"></a>00633       
<a name="l00634"></a>00634       
<a name="l00635"></a><a class="code" href="classviennacl_1_1matrix__base.html#a4d7af104d914cb4ffd07463d5e19d721">00635</a>       <a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> <a class="code" href="classviennacl_1_1matrix__base.html#a4d7af104d914cb4ffd07463d5e19d721">memory_domain</a>()<span class="keyword"> const</span>
<a name="l00636"></a>00636 <span class="keyword">      </span>{
<a name="l00637"></a>00637         <span class="keywordflow">return</span> elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#acd29573cd156d000f75668bba858cca3" title="Returns an ID for the currently active memory buffer. Other memory buffers might contain old or no da...">get_active_handle_id</a>();
<a name="l00638"></a>00638       }
<a name="l00639"></a>00639       
<a name="l00640"></a>00640     <span class="keyword">protected</span>:
<a name="l00641"></a>00641       
<a name="l00642"></a><a class="code" href="classviennacl_1_1matrix__base.html#a06bd1620b92852143daab47c58918b30">00642</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1matrix__base.html#a06bd1620b92852143daab47c58918b30">set_handle</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> <span class="keyword">const</span> &amp; h)
<a name="l00643"></a>00643       {
<a name="l00644"></a>00644         elements_ = h;
<a name="l00645"></a>00645       }
<a name="l00646"></a>00646       
<a name="l00647"></a><a class="code" href="classviennacl_1_1matrix__base.html#ad2283ab2934e9bfcd2335d00cb56519a">00647</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1matrix__base.html#ad2283ab2934e9bfcd2335d00cb56519a">switch_memory_domain</a>(<a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> new_domain)
<a name="l00648"></a>00648       {
<a name="l00649"></a>00649         viennacl::backend::switch_memory_domain&lt;SCALARTYPE&gt;(elements_, new_domain);
<a name="l00650"></a>00650       }
<a name="l00651"></a>00651       
<a name="l00652"></a>00652       
<a name="l00660"></a><a class="code" href="classviennacl_1_1matrix__base.html#a85a1b89e54443b8f4e910a245276b670">00660</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1matrix__base.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can be preserved, but.">resize</a>(<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> columns, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
<a name="l00661"></a>00661       {
<a name="l00662"></a>00662         assert( (rows &gt; 0 &amp;&amp; columns &gt; 0) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Check failed in matrix::resize(): Number of rows and columns must be positive!&quot;</span>));
<a name="l00663"></a>00663   
<a name="l00664"></a>00664         <span class="keywordflow">if</span> (preserve &amp;&amp; <a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>() &gt; 0)
<a name="l00665"></a>00665         {
<a name="l00666"></a>00666           <span class="comment">//get old entries:</span>
<a name="l00667"></a>00667           std::vector&lt; SCALARTYPE &gt; old_entries(<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00668"></a>00668           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(elements_, 0, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(old_entries[0]));
<a name="l00669"></a>00669           
<a name="l00670"></a>00670           <span class="comment">//set up entries of new matrix:</span>
<a name="l00671"></a>00671           std::vector&lt; SCALARTYPE &gt; new_entries(  viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(rows,    1)
<a name="l00672"></a>00672                                                 * viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(columns, 1));
<a name="l00673"></a>00673           <span class="keywordflow">for</span> (<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> i=0; i&lt;rows; ++i)
<a name="l00674"></a>00674           {
<a name="l00675"></a>00675             <span class="keywordflow">if</span> (i &gt;= size1_)
<a name="l00676"></a>00676               <span class="keywordflow">continue</span>;
<a name="l00677"></a>00677               
<a name="l00678"></a>00678             <span class="keywordflow">for</span> (<a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> j=0; j&lt;columns; ++j)
<a name="l00679"></a>00679             {
<a name="l00680"></a>00680               <span class="keywordflow">if</span> (j &gt;= size2_)
<a name="l00681"></a>00681                 <span class="keywordflow">continue</span>;
<a name="l00682"></a>00682               new_entries[F::mem_index(i, j, viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(rows, 1), viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(columns, 1))] 
<a name="l00683"></a>00683                   = old_entries[F::mem_index(i, j, <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>())];
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685           }
<a name="l00686"></a>00686           
<a name="l00687"></a>00687           <span class="comment">//copy new entries to GPU:</span>
<a name="l00688"></a>00688           size1_ = rows;
<a name="l00689"></a>00689           size2_ = columns;
<a name="l00690"></a>00690           internal_size1_ = size1_;
<a name="l00691"></a>00691           internal_size2_ = size2_;
<a name="l00692"></a>00692           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*new_entries.size(), &amp;(new_entries[0]));
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694         <span class="keywordflow">else</span> <span class="comment">//discard old entries:</span>
<a name="l00695"></a>00695         {
<a name="l00696"></a>00696           size1_ = rows;
<a name="l00697"></a>00697           size2_ = columns;
<a name="l00698"></a>00698           internal_size1_ = size1_;
<a name="l00699"></a>00699           internal_size2_ = size2_;
<a name="l00700"></a>00700           
<a name="l00701"></a>00701           std::vector&lt; SCALARTYPE &gt; new_entries(  viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(rows,    1) 
<a name="l00702"></a>00702                                                 * viennacl::tools::roundUpToNextMultiple&lt;vcl_size_t&gt;(columns, 1));
<a name="l00703"></a>00703           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(new_entries[0]));
<a name="l00704"></a>00704         }
<a name="l00705"></a>00705       }
<a name="l00706"></a>00706       
<a name="l00707"></a>00707     <span class="keyword">private</span>:
<a name="l00708"></a>00708       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> size1_;
<a name="l00709"></a>00709       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> size2_;
<a name="l00710"></a>00710       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> start1_;
<a name="l00711"></a>00711       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> start2_;
<a name="l00712"></a>00712       <a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> stride1_;
<a name="l00713"></a>00713       <a class="code" href="classviennacl_1_1matrix__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> stride2_;
<a name="l00714"></a>00714       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> internal_size1_;
<a name="l00715"></a>00715       <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> internal_size2_;
<a name="l00716"></a>00716       <a class="code" href="classviennacl_1_1matrix__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> elements_;
<a name="l00717"></a>00717   }; <span class="comment">//matrix</span>
<a name="l00718"></a>00718   
<a name="l00719"></a>00719   
<a name="l00720"></a>00720   
<a name="l00727"></a>00727   <span class="keyword">template</span> &lt;<span class="keyword">class</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00728"></a><a class="code" href="classviennacl_1_1matrix.html">00728</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix</a> : <span class="keyword">public</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base</a>&lt;SCALARTYPE, F&gt;
<a name="l00729"></a>00729   {
<a name="l00730"></a>00730       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a>          <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">self_type</a>;
<a name="l00731"></a>00731       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__base.html">matrix_base&lt;SCALARTYPE, F&gt;</a>                <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>;
<a name="l00732"></a>00732     <span class="keyword">public</span>:
<a name="l00733"></a><a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">00733</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__base.html#a233dcbba0ec084278552de99c8b0a231">base_type::size_type</a>             <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a>;
<a name="l00734"></a>00734       
<a name="l00736"></a><a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3">00736</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>() : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>() {};
<a name="l00737"></a>00737       
<a name="l00743"></a><a class="code" href="classviennacl_1_1matrix.html#a5fa61229b402af98be181acc83cd2510">00743</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix.html#a5fa61229b402af98be181acc83cd2510" title="Creates the matrix with the given dimensions.">matrix</a>(<a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> columns) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(rows, columns) {}
<a name="l00744"></a>00744   
<a name="l00745"></a>00745 <span class="preprocessor">  #ifdef VIENNACL_WITH_OPENCL</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>      <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(cl_mem mem, <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> columns) : base_type (rows, columns)
<a name="l00747"></a>00747       {
<a name="l00748"></a>00748         <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> h;
<a name="l00749"></a>00749         h.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a016f1218a02268c06c3009803cc3073d" title="Switches the currently active handle. If no support for that backend is provided, an exception is thr...">switch_active_handle_id</a>(<a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">viennacl::OPENCL_MEMORY</a>);
<a name="l00750"></a>00750         h.opencl_handle() = mem;
<a name="l00751"></a>00751         h.opencl_handle().inc();  <span class="comment">//prevents that the user-provided memory is deleted once the vector object is destroyed.</span>
<a name="l00752"></a>00752         h.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a88c5d6be919f60a44e114b3269d730fd" title="Returns the number of bytes of the currently active buffer.">raw_size</a>(<span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>());
<a name="l00753"></a>00753         
<a name="l00754"></a>00754         <a class="code" href="classviennacl_1_1matrix__base.html#a06bd1620b92852143daab47c58918b30">base_type::set_handle</a>(h);
<a name="l00755"></a>00755       }
<a name="l00756"></a>00756 <span class="preprocessor">  #endif</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span>  
<a name="l00758"></a>00758       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00759"></a><a class="code" href="classviennacl_1_1matrix.html#aff34e4e2feb55adce771666e27942a0d">00759</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(proxy.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), proxy.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(), viennacl::traits::<a class="code" href="namespaceviennacl_1_1traits.html#aad443a796634a9648e19b4156fcd880d" title="Returns an ID for the currently active memory domain of an object.">active_handle_id</a>(proxy))
<a name="l00760"></a>00760       {
<a name="l00761"></a>00761         <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(proxy);
<a name="l00762"></a>00762       }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType&gt;
<a name="l00765"></a><a class="code" href="classviennacl_1_1matrix.html#aab6249aefb0b59abcb207432362c62cf">00765</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;MatrixType, MatrixType, op_trans&gt;</a> <span class="keyword">const</span> &amp; proxy) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(proxy.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), proxy.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(), viennacl::traits::<a class="code" href="namespaceviennacl_1_1traits.html#aad443a796634a9648e19b4156fcd880d" title="Returns an ID for the currently active memory domain of an object.">active_handle_id</a>(proxy))
<a name="l00766"></a>00766       {
<a name="l00767"></a>00767         <a class="code" href="classviennacl_1_1matrix.html#af8ea8d839cfa3caf47255eb7eb60b506">self_type::operator=</a>(proxy);
<a name="l00768"></a>00768       }
<a name="l00769"></a>00769       
<a name="l00771"></a><a class="code" href="classviennacl_1_1matrix.html#a588e4490dbe3bc6e13786dda5faeaa83">00771</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<a class="code" href="classviennacl_1_1identity__matrix.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">identity_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(m.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), m.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l00772"></a>00772       {
<a name="l00773"></a>00773         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>() &gt; 0)
<a name="l00774"></a>00774           <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(m);
<a name="l00775"></a>00775       }
<a name="l00776"></a>00776       
<a name="l00778"></a><a class="code" href="classviennacl_1_1matrix.html#a8b5c8a7d4ddab85acf7a259abbf3b44e">00778</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<a class="code" href="classviennacl_1_1zero__matrix.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(m.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), m.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l00779"></a>00779       {
<a name="l00780"></a>00780         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>() &gt; 0)
<a name="l00781"></a>00781           <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(m);
<a name="l00782"></a>00782       }
<a name="l00783"></a>00783   
<a name="l00785"></a><a class="code" href="classviennacl_1_1matrix.html#add5cffa07fe7c19d40a9ed0919302f59">00785</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<a class="code" href="classviennacl_1_1scalar__matrix.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_matrix&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; m) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(m.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), m.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l00786"></a>00786       {
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>() &gt; 0)
<a name="l00788"></a>00788           <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(m);
<a name="l00789"></a>00789       }
<a name="l00790"></a>00790       
<a name="l00791"></a><a class="code" href="classviennacl_1_1matrix.html#aaad980939cf7c710dc17573abf423f04">00791</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a> &amp; other) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(other.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), other.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(), viennacl::traits::<a class="code" href="namespaceviennacl_1_1traits.html#aad443a796634a9648e19b4156fcd880d" title="Returns an ID for the currently active memory domain of an object.">active_handle_id</a>(other))
<a name="l00792"></a>00792       {
<a name="l00793"></a>00793         <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(other);
<a name="l00794"></a>00794       }
<a name="l00795"></a>00795   
<a name="l00796"></a>00796   
<a name="l00797"></a>00797       <span class="comment">//copy constructor:</span>
<a name="l00798"></a><a class="code" href="classviennacl_1_1matrix.html#a23e1cb3dac8f34062a07b4ebf1331156">00798</a>       <a class="code" href="classviennacl_1_1matrix.html#a2b7f607d95bd2aeb66a382ff2df384c3" title="The default constructor. Does not allocate any memory.">matrix</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">self_type</a> &amp; other) : <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>(other.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(), other.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(), viennacl::traits::<a class="code" href="namespaceviennacl_1_1traits.html#aad443a796634a9648e19b4156fcd880d" title="Returns an ID for the currently active memory domain of an object.">active_handle_id</a>(other))
<a name="l00799"></a>00799       {
<a name="l00800"></a>00800         <a class="code" href="classviennacl_1_1matrix__base.html#a0e73ad150c52a83a51f0408a9e5bbc2d">base_type::operator=</a>(other);
<a name="l00801"></a>00801       }
<a name="l00802"></a>00802   
<a name="l00803"></a>00803       
<a name="l00804"></a>00804       <span class="comment">// A = trans(B). Currently achieved in CPU memory</span>
<a name="l00805"></a><a class="code" href="classviennacl_1_1matrix.html#af8ea8d839cfa3caf47255eb7eb60b506">00805</a>       <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">self_type</a> &amp; <a class="code" href="classviennacl_1_1matrix.html#af8ea8d839cfa3caf47255eb7eb60b506">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>,
<a name="l00806"></a>00806                                                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">base_type</a>,
<a name="l00807"></a>00807                                                      op_trans&gt; &amp; proxy)
<a name="l00808"></a>00808       {
<a name="l00809"></a>00809         assert( (<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">base_type::handle</a>() != proxy.lhs().handle()) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Self-assignment of matrix transpose not implemented&quot;</span>));
<a name="l00810"></a>00810         assert( ( (proxy.lhs().size1() == <a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">base_type::size2</a>()) || (<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">base_type::size2</a>() == 0) ) &amp;&amp; bool(<span class="stringliteral">&quot;Matrix dimensions do not match!&quot;</span>));
<a name="l00811"></a>00811         assert( ( (proxy.lhs().size2() == <a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">base_type::size1</a>()) || (<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">base_type::size1</a>() == 0) ) &amp;&amp; bool(<span class="stringliteral">&quot;Matrix dimensions do not match!&quot;</span>));
<a name="l00812"></a>00812   
<a name="l00813"></a>00813         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>() == 0)
<a name="l00814"></a>00814           <a class="code" href="classviennacl_1_1matrix.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can optionally be preserved.">resize</a>(proxy.lhs().size2(), proxy.lhs().size1(), <span class="keyword">false</span>);
<a name="l00815"></a>00815         
<a name="l00816"></a>00816         std::vector&lt;SCALARTYPE&gt; temp(proxy.lhs().internal_size());
<a name="l00817"></a>00817   
<a name="l00818"></a>00818         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(proxy.lhs().handle(), 0, <span class="keyword">sizeof</span>(SCALARTYPE)*proxy.lhs().internal_size(), &amp;(temp[0]));
<a name="l00819"></a>00819   
<a name="l00820"></a>00820         <span class="comment">// now transpose it</span>
<a name="l00821"></a>00821         std::vector&lt;SCALARTYPE&gt; temp_trans(<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>());
<a name="l00822"></a>00822   
<a name="l00823"></a>00823         <span class="keywordflow">for</span> (<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> i=0; i&lt;proxy.lhs().size1(); ++i)
<a name="l00824"></a>00824           <span class="keywordflow">for</span> (<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> j=0; j&lt;proxy.lhs().size2(); ++j)
<a name="l00825"></a>00825             temp_trans[F::mem_index(<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">base_type::start2</a>() + <a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">base_type::stride2</a>() * j,
<a name="l00826"></a>00826                                     <a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">base_type::start1</a>() + <a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">base_type::stride1</a>() * i,
<a name="l00827"></a>00827                                     <a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">base_type::internal_size1</a>(), <a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">base_type::internal_size2</a>())] 
<a name="l00828"></a>00828               = temp[F::mem_index(proxy.lhs().start1() + proxy.lhs().stride1() * i,
<a name="l00829"></a>00829                                   proxy.lhs().start2() + proxy.lhs().stride2() * j,
<a name="l00830"></a>00830                                   proxy.lhs().internal_size1(), proxy.lhs().internal_size2())];
<a name="l00831"></a>00831   
<a name="l00832"></a>00832         <span class="comment">// write back</span>
<a name="l00833"></a>00833         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a783445c0255733c8e6073cd8fe3c2a83" title="Writes data from main RAM identified by &#39;ptr&#39; to the buffer identified by &#39;dst_buffer&#39;.">viennacl::backend::memory_write</a>(<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">base_type::handle</a>(), 0, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">base_type::internal_size</a>(), &amp;(temp_trans[0]));
<a name="l00834"></a>00834           
<a name="l00835"></a>00835         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00836"></a>00836       }
<a name="l00837"></a>00837       
<a name="l00838"></a>00838       <span class="comment">/*template &lt;typename M1&gt;</span>
<a name="l00839"></a>00839 <span class="comment">      self_type &amp; operator=(const matrix_expression&lt; const M1, const M1, op_trans&gt; &amp; proxy)</span>
<a name="l00840"></a>00840 <span class="comment">      {</span>
<a name="l00841"></a>00841 <span class="comment">        self_type temp(proxy.lhs());</span>
<a name="l00842"></a>00842 <span class="comment">        *this = trans(temp);</span>
<a name="l00843"></a>00843 <span class="comment">        return *this;</span>
<a name="l00844"></a>00844 <span class="comment">      }*/</span>
<a name="l00845"></a>00845 
<a name="l00846"></a>00846       <span class="keyword">using</span> base_type::operator=;
<a name="l00847"></a>00847       
<a name="l00855"></a><a class="code" href="classviennacl_1_1matrix.html#a85a1b89e54443b8f4e910a245276b670">00855</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1matrix.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can optionally be preserved.">resize</a>(<a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> rows, <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> columns, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
<a name="l00856"></a>00856       {
<a name="l00857"></a>00857         <a class="code" href="classviennacl_1_1matrix__base.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can be preserved, but.">base_type::resize</a>(rows, columns, preserve);
<a name="l00858"></a>00858       }
<a name="l00859"></a>00859   
<a name="l00860"></a>00860   }; <span class="comment">//matrix</span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862     
<a name="l00863"></a>00863     
<a name="l00869"></a>00869   <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00870"></a><a class="code" href="namespaceviennacl.html#af2b7b1aeba8d75ee073974e57d1bf385">00870</a>   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, const matrix&lt;SCALARTYPE, F, ALIGNMENT&gt; &amp; gpu_matrix)
<a name="l00871"></a>00871   {
<a name="l00872"></a>00872     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;::size_type</a>      size_type;
<a name="l00873"></a>00873     
<a name="l00874"></a>00874     std::vector&lt;SCALARTYPE&gt; tmp(gpu_matrix.internal_size());
<a name="l00875"></a>00875     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_matrix.handle(), 0, <span class="keyword">sizeof</span>(SCALARTYPE) * gpu_matrix.internal_size(), &amp;(tmp[0]));
<a name="l00876"></a>00876     
<a name="l00877"></a>00877     s &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; gpu_matrix.size1() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; gpu_matrix.size2() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l00878"></a>00878     
<a name="l00879"></a>00879     s &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;
<a name="l00880"></a>00880     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.size1(); ++i)
<a name="l00881"></a>00881     {
<a name="l00882"></a>00882       s &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;
<a name="l00883"></a>00883       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.size2(); ++j)
<a name="l00884"></a>00884       {
<a name="l00885"></a>00885         s &lt;&lt; tmp[F::mem_index(i, j, gpu_matrix.internal_size1(), gpu_matrix.internal_size2())];
<a name="l00886"></a>00886         <span class="keywordflow">if</span> (j &lt; gpu_matrix.size2() - 1)
<a name="l00887"></a>00887           s &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00888"></a>00888       }
<a name="l00889"></a>00889       s &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l00890"></a>00890       <span class="keywordflow">if</span> (i &lt; gpu_matrix.size1() - 1)
<a name="l00891"></a>00891         s &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00892"></a>00892     }
<a name="l00893"></a>00893     s &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l00894"></a>00894     <span class="keywordflow">return</span> s;
<a name="l00895"></a>00895   }
<a name="l00896"></a>00896 
<a name="l00902"></a>00902   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00903"></a><a class="code" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">00903</a>   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, const matrix_expression&lt;LHS, RHS, OP&gt; &amp; expr)
<a name="l00904"></a>00904   {
<a name="l00905"></a>00905     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1tools_1_1_c_p_u___s_c_a_l_a_r___t_y_p_e___d_e_d_u_c_e_r.html" title="Obtain the cpu scalar type from a type, including a GPU type like viennacl::scalar&lt;T&gt;">viennacl::tools::CPU_SCALAR_TYPE_DEDUCER&lt; typename tools::CONST_REMOVER&lt;LHS&gt;::ResultType</a> &gt;::ResultType     ScalarType;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;ScalarType&gt;</a> temp = expr;
<a name="l00908"></a>00908     s &lt;&lt; temp;
<a name="l00909"></a>00909     <span class="keywordflow">return</span> s;
<a name="l00910"></a>00910   }
<a name="l00911"></a>00911   
<a name="l00913"></a>00913   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00914"></a>00914   matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> matrix_base&lt;NumericT, F&gt;, op_trans&gt;
<a name="l00915"></a><a class="code" href="namespaceviennacl.html#a0250af0917fd1088eb339e3550964954">00915</a>   <a class="code" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84" title="Returns an expression template class representing a transposed matrix.">trans</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat)
<a name="l00916"></a>00916   {
<a name="l00917"></a>00917     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, op_trans&gt;(mat, mat);
<a name="l00918"></a>00918   }
<a name="l00919"></a>00919   
<a name="l00920"></a>00920   
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="comment">//</span>
<a name="l00924"></a>00924   <span class="comment">//cpu to gpu, generic type:</span>
<a name="l00925"></a>00925   <span class="comment">//</span>
<a name="l00931"></a>00931 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CPU_MATRIX, <span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00932"></a><a class="code" href="namespaceviennacl.html#a3728d51018413682b2c807cb26fe0ce6">00932</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> CPU_MATRIX &amp; cpu_matrix,
<a name="l00933"></a>00933             <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix )
<a name="l00934"></a>00934   {
<a name="l00935"></a>00935     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;::size_type</a>      size_type;
<a name="l00936"></a>00936     
<a name="l00937"></a>00937     <span class="comment">//std::cout &lt;&lt; &quot;Copying CPU_MATRIX!&quot; &lt;&lt; std::endl;</span>
<a name="l00938"></a>00938     <span class="comment">//std::cout &lt;&lt; &quot;Size at begin: &quot; &lt;&lt; gpu_matrix.size1() &lt;&lt; &quot;, &quot; &lt;&lt; gpu_matrix.size2() &lt;&lt; std::endl;</span>
<a name="l00939"></a>00939     <span class="keywordflow">if</span> (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0 || gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00940"></a>00940     {
<a name="l00941"></a>00941       gpu_matrix.<a class="code" href="classviennacl_1_1matrix.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can optionally be preserved.">resize</a>(cpu_matrix.size1(),
<a name="l00942"></a>00942                         cpu_matrix.size2(), <span class="keyword">false</span>);
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944     <span class="keywordflow">else</span>
<a name="l00945"></a>00945     {
<a name="l00946"></a>00946       assert( (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == cpu_matrix.size1()) 
<a name="l00947"></a>00947               &amp;&amp; (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == cpu_matrix.size2())
<a name="l00948"></a>00948               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;matrix size mismatch&quot;</span>)
<a name="l00949"></a>00949             );
<a name="l00950"></a>00950     }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     std::vector&lt;SCALARTYPE&gt; data(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00953"></a>00953     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(); ++i)
<a name="l00954"></a>00954     {
<a name="l00955"></a>00955       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(); ++j) 
<a name="l00956"></a>00956         data[F::mem_index(i, j, gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>())] = cpu_matrix(i,j);
<a name="l00957"></a>00957     }
<a name="l00958"></a>00958     
<a name="l00959"></a>00959     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE) * data.size(), &amp;(data[0]));
<a name="l00960"></a>00960     <span class="comment">//gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE, data);</span>
<a name="l00961"></a>00961     <span class="comment">//std::cout &lt;&lt; &quot;Size at end: &quot; &lt;&lt; gpu_matrix.size1() &lt;&lt; &quot;, &quot; &lt;&lt; gpu_matrix.size2() &lt;&lt; std::endl;</span>
<a name="l00962"></a>00962   }
<a name="l00963"></a>00963   
<a name="l00964"></a>00964   <span class="comment">//</span>
<a name="l00965"></a>00965   <span class="comment">//cpu to gpu, STL type:</span>
<a name="l00966"></a>00966   <span class="comment">//</span>
<a name="l00972"></a>00972 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00973"></a><a class="code" href="namespaceviennacl.html#aba57054849e1adf3cd627b22d8512b75">00973</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> std::vector&lt; std::vector&lt;SCALARTYPE, A1&gt;, A2&gt; &amp; cpu_matrix,
<a name="l00974"></a>00974             <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix )
<a name="l00975"></a>00975   {
<a name="l00976"></a>00976     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;::size_type</a>      size_type;
<a name="l00977"></a>00977     
<a name="l00978"></a>00978     <span class="keywordflow">if</span> (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == 0 || gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == 0)
<a name="l00979"></a>00979     {
<a name="l00980"></a>00980       gpu_matrix.<a class="code" href="classviennacl_1_1matrix.html#a85a1b89e54443b8f4e910a245276b670" title="Resizes the matrix. Existing entries can optionally be preserved.">resize</a>(cpu_matrix.size(),
<a name="l00981"></a>00981                         cpu_matrix[0].size(),
<a name="l00982"></a>00982                         <span class="keyword">false</span>);
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984     <span class="keywordflow">else</span>
<a name="l00985"></a>00985     {
<a name="l00986"></a>00986       assert( (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() == cpu_matrix.size()) 
<a name="l00987"></a>00987               &amp;&amp; (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == cpu_matrix[0].size())
<a name="l00988"></a>00988               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;matrix size mismatch&quot;</span>)
<a name="l00989"></a>00989             );
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992     std::vector&lt;SCALARTYPE&gt; data(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l00993"></a>00993     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(); ++i)
<a name="l00994"></a>00994     {
<a name="l00995"></a>00995       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(); ++j) 
<a name="l00996"></a>00996         data[F::mem_index(i, j, gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>())] = cpu_matrix[i][j];
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998     
<a name="l00999"></a>00999     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE) * data.size(), &amp;(data[0]));
<a name="l01000"></a>01000     <span class="comment">//gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE, data);</span>
<a name="l01001"></a>01001   }
<a name="l01002"></a>01002   
<a name="l01003"></a>01003   
<a name="l01004"></a>01004   <span class="comment">//</span>
<a name="l01005"></a>01005   <span class="comment">//cpu to gpu, another STL type:</span>
<a name="l01006"></a>01006   <span class="comment">//</span>
<a name="l01013"></a>01013 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01014"></a><a class="code" href="namespaceviennacl.html#a6fe9c1c3ea45c54d92082b1805790e80">01014</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(SCALARTYPE * cpu_matrix_begin,
<a name="l01015"></a>01015                   SCALARTYPE * cpu_matrix_end,
<a name="l01016"></a>01016                   <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix)
<a name="l01017"></a>01017   {
<a name="l01018"></a>01018     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE) * (cpu_matrix_end - cpu_matrix_begin), cpu_matrix_begin);
<a name="l01019"></a>01019     <span class="comment">/*gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE,</span>
<a name="l01020"></a>01020 <span class="comment">                                                                          sizeof(SCALARTYPE) * (cpu_matrix_end - cpu_matrix_begin),</span>
<a name="l01021"></a>01021 <span class="comment">                                                                          cpu_matrix_begin);*/</span>
<a name="l01022"></a>01022   }
<a name="l01023"></a>01023   
<a name="l01024"></a>01024   
<a name="l01025"></a>01025 <span class="preprocessor">  #ifdef VIENNACL_WITH_EIGEN</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span>
<a name="l01031"></a>01031   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01032"></a>01032   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> Eigen::MatrixXf &amp; cpu_matrix,
<a name="l01033"></a>01033             matrix&lt;float, F, ALIGNMENT&gt; &amp; gpu_matrix)
<a name="l01034"></a>01034   {
<a name="l01035"></a>01035     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix&lt;float, F, ALIGNMENT&gt;::size_type      size_type;
<a name="l01036"></a>01036     
<a name="l01037"></a>01037     <span class="keywordflow">if</span> (gpu_matrix.size1() == 0 || gpu_matrix.size2() == 0)
<a name="l01038"></a>01038     {
<a name="l01039"></a>01039       gpu_matrix.resize(cpu_matrix.rows(),
<a name="l01040"></a>01040                         cpu_matrix.cols(),
<a name="l01041"></a>01041                         <span class="keyword">false</span>);
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043     <span class="keywordflow">else</span>
<a name="l01044"></a>01044     {
<a name="l01045"></a>01045       assert( (gpu_matrix.size1() == <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(cpu_matrix.rows())) 
<a name="l01046"></a>01046               &amp;&amp; (gpu_matrix.size2() == <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(cpu_matrix.cols()))
<a name="l01047"></a>01047               &amp;&amp; bool(<span class="stringliteral">&quot;matrix size mismatch&quot;</span>)
<a name="l01048"></a>01048             );
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     std::vector&lt;float&gt; data(gpu_matrix.internal_size());
<a name="l01052"></a>01052     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.size1(); ++i)
<a name="l01053"></a>01053     {
<a name="l01054"></a>01054       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.size2(); ++j) 
<a name="l01055"></a>01055         data[F::mem_index(i, j, gpu_matrix.internal_size1(), gpu_matrix.internal_size2())] = cpu_matrix(i,j);
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057     
<a name="l01058"></a>01058     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.handle(), <span class="keyword">sizeof</span>(float) * data.size(), &amp;(data[0]));
<a name="l01059"></a>01059     <span class="comment">//gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE, data);</span>
<a name="l01060"></a>01060   }
<a name="l01061"></a>01061   
<a name="l01067"></a>01067   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01068"></a>01068   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> Eigen::MatrixXd &amp; cpu_matrix,
<a name="l01069"></a>01069             matrix&lt;double, F, ALIGNMENT&gt; &amp; gpu_matrix)
<a name="l01070"></a>01070   {
<a name="l01071"></a>01071     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix&lt;double, F, ALIGNMENT&gt;::size_type      size_type;
<a name="l01072"></a>01072     
<a name="l01073"></a>01073     <span class="keywordflow">if</span> (gpu_matrix.size1() == 0 || gpu_matrix.size2() == 0)
<a name="l01074"></a>01074     {
<a name="l01075"></a>01075       gpu_matrix.resize(cpu_matrix.rows(),
<a name="l01076"></a>01076                         cpu_matrix.cols(),
<a name="l01077"></a>01077                         <span class="keyword">false</span>);
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079     <span class="keywordflow">else</span>
<a name="l01080"></a>01080     {
<a name="l01081"></a>01081       assert( (gpu_matrix.size1() == <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(cpu_matrix.rows())) 
<a name="l01082"></a>01082               &amp;&amp; (gpu_matrix.size2() == <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(cpu_matrix.cols()))
<a name="l01083"></a>01083               &amp;&amp; bool(<span class="stringliteral">&quot;matrix size mismatch&quot;</span>)
<a name="l01084"></a>01084             );
<a name="l01085"></a>01085     }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087     std::vector&lt;double&gt; data(gpu_matrix.internal_size());
<a name="l01088"></a>01088     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.size1(); ++i)
<a name="l01089"></a>01089     {
<a name="l01090"></a>01090       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.size2(); ++j) 
<a name="l01091"></a>01091         data[F::mem_index(i, j, gpu_matrix.internal_size1(), gpu_matrix.internal_size2())] = cpu_matrix(i,j);
<a name="l01092"></a>01092     }
<a name="l01093"></a>01093     
<a name="l01094"></a>01094     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.handle(), <span class="keyword">sizeof</span>(double) * data.size(), &amp;(data[0]));
<a name="l01095"></a>01095     <span class="comment">//gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE, data);</span>
<a name="l01096"></a>01096   }
<a name="l01097"></a>01097 <span class="preprocessor">  #endif</span>
<a name="l01098"></a>01098 <span class="preprocessor"></span>  
<a name="l01099"></a>01099 <span class="preprocessor">  #ifdef VIENNACL_WITH_MTL4</span>
<a name="l01100"></a>01100 <span class="preprocessor"></span>
<a name="l01105"></a>01105   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> T, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01106"></a>01106   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> mtl::dense2D&lt;SCALARTYPE, T&gt;&amp; cpu_matrix,
<a name="l01107"></a>01107             matrix&lt;SCALARTYPE, F, ALIGNMENT&gt; &amp; gpu_matrix)
<a name="l01108"></a>01108   {
<a name="l01109"></a>01109     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;::size_type      size_type;
<a name="l01110"></a>01110     
<a name="l01111"></a>01111     <span class="keywordflow">if</span> (gpu_matrix.size1() == 0 || gpu_matrix.size2() == 0)
<a name="l01112"></a>01112     {
<a name="l01113"></a>01113       gpu_matrix.resize(cpu_matrix.num_rows(),
<a name="l01114"></a>01114                         cpu_matrix.num_cols(),
<a name="l01115"></a>01115                         <span class="keyword">false</span>);
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117     <span class="keywordflow">else</span>
<a name="l01118"></a>01118     {
<a name="l01119"></a>01119       assert( (gpu_matrix.size1() == cpu_matrix.num_rows()) 
<a name="l01120"></a>01120               &amp;&amp; (gpu_matrix.size2() == cpu_matrix.num_cols())
<a name="l01121"></a>01121               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;matrix size mismatch&quot;</span>)
<a name="l01122"></a>01122             );
<a name="l01123"></a>01123     }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     std::vector&lt;SCALARTYPE&gt; data(gpu_matrix.internal_size());
<a name="l01126"></a>01126     <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.size1(); ++i)
<a name="l01127"></a>01127     {
<a name="l01128"></a>01128       <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.size2(); ++j) 
<a name="l01129"></a>01129         data[F::mem_index(i, j, gpu_matrix.internal_size1(), gpu_matrix.internal_size2())] = cpu_matrix[i][j];
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131     
<a name="l01132"></a>01132     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(gpu_matrix.handle(), <span class="keyword">sizeof</span>(SCALARTYPE) * data.size(), &amp;(data[0]));
<a name="l01133"></a>01133     <span class="comment">//gpu_matrix.elements_ = viennacl::ocl::current_context().create_memory(CL_MEM_READ_WRITE, data);</span>
<a name="l01134"></a>01134   }
<a name="l01135"></a>01135 <span class="preprocessor">  #endif</span>
<a name="l01136"></a>01136 <span class="preprocessor"></span>  
<a name="l01137"></a>01137   
<a name="l01138"></a>01138   
<a name="l01139"></a>01139   
<a name="l01140"></a>01140   <span class="comment">//</span>
<a name="l01141"></a>01141   <span class="comment">//gpu to cpu, generic type</span>
<a name="l01142"></a>01142   <span class="comment">//</span>
<a name="l01148"></a>01148 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CPU_MATRIX, <span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01149"></a><a class="code" href="namespaceviennacl.html#ad655c8cbb96bf07d2348309a2656799e">01149</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix,
<a name="l01150"></a>01150             CPU_MATRIX &amp; cpu_matrix )
<a name="l01151"></a>01151   {
<a name="l01152"></a>01152     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">matrix&lt;float, F, ALIGNMENT&gt;::size_type</a>      size_type;
<a name="l01153"></a>01153     
<a name="l01154"></a>01154     <span class="keywordflow">if</span> ( (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0) &amp;&amp; (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0) )
<a name="l01155"></a>01155     {
<a name="l01156"></a>01156       std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l01157"></a>01157       <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), 0, <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(temp_buffer[0]));
<a name="l01158"></a>01158       
<a name="l01159"></a>01159       <span class="comment">//now copy entries to cpu_matrix:</span>
<a name="l01160"></a>01160       <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(); ++i)
<a name="l01161"></a>01161         <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(); ++j) 
<a name="l01162"></a>01162           cpu_matrix(i,j) = temp_buffer[F::mem_index(i, j, gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>())];
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164   }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <span class="comment">//gpu to cpu, STL type</span>
<a name="l01172"></a>01172 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01173"></a><a class="code" href="namespaceviennacl.html#aab87e45b79097799bbaabeed1e240ace">01173</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix,
<a name="l01174"></a>01174             std::vector&lt; std::vector&lt;SCALARTYPE, A1&gt;, A2&gt; &amp; cpu_matrix)
<a name="l01175"></a>01175   {
<a name="l01176"></a>01176     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix.html#a6d6dadd7b4260bf281cc6277f382acac">matrix&lt;float, F, ALIGNMENT&gt;::size_type</a>      size_type;
<a name="l01177"></a>01177     
<a name="l01178"></a>01178     <span class="keywordflow">if</span> ( (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0) &amp;&amp; (gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0) 
<a name="l01179"></a>01179         &amp;&amp; (cpu_matrix.size() &gt;= gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>()) &amp;&amp; (cpu_matrix[0].<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size</a>() &gt;= gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>()))
<a name="l01180"></a>01180     {
<a name="l01181"></a>01181       std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>());
<a name="l01182"></a>01182       <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), 0, <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), &amp;(temp_buffer[0]));
<a name="l01183"></a>01183       
<a name="l01184"></a>01184       <span class="comment">//now copy entries to cpu_matrix:</span>
<a name="l01185"></a>01185       <span class="keywordflow">for</span> (size_type i = 0; i &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>(); ++i)
<a name="l01186"></a>01186         <span class="keywordflow">for</span> (size_type j = 0; j &lt; gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>(); ++j) 
<a name="l01187"></a>01187           cpu_matrix[i][j] = temp_buffer[F::mem_index(i, j, gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>(), gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>())];
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189   }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191   <span class="comment">//gpu to cpu, STL type</span>
<a name="l01197"></a>01197 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01198"></a><a class="code" href="namespaceviennacl.html#a67d05f6ec18b2d7c2051eb4f6b47b5a7">01198</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, ALIGNMENT&gt;</a> &amp; gpu_matrix,
<a name="l01199"></a>01199                   SCALARTYPE * cpu_matrix_begin)
<a name="l01200"></a>01200   {
<a name="l01201"></a>01201     <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the OpenCL handle, non-const-version.">handle</a>(), 0, <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_matrix.<a class="code" href="classviennacl_1_1matrix__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the total amount of allocated memory in multiples of sizeof(SCALARTYPE)">internal_size</a>(), cpu_matrix_begin);
<a name="l01202"></a>01202   }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 
<a name="l01207"></a>01207 
<a name="l01208"></a>01208 
<a name="l01209"></a>01209   <span class="comment">// operator +</span>
<a name="l01211"></a>01211 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01212"></a>01212             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01213"></a>01213   <span class="keyword">typename</span> matrix_expression&lt; LHS1, RHS1, OP1&gt;::matrix_type
<a name="l01214"></a><a class="code" href="namespaceviennacl.html#ab0b04b8d27cc0b0b61dfb5597e584702">01214</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01215"></a>01215               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01216"></a>01216   {
<a name="l01217"></a>01217     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01218"></a>01218             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01219"></a>01219             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01220"></a>01220     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_expression&lt; LHS1, RHS1, OP1&gt;::matrix_type</a> result = proxy1;
<a name="l01221"></a>01221     result += proxy2;
<a name="l01222"></a>01222     <span class="keywordflow">return</span> result;
<a name="l01223"></a>01223   }
<a name="l01224"></a>01224   
<a name="l01225"></a>01225   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01226"></a>01226             <span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01227"></a>01227   matrix&lt;NumericT, F&gt;
<a name="l01228"></a><a class="code" href="namespaceviennacl.html#a8992f6234065e16e9276dfff541602b6">01228</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01229"></a>01229               <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01230"></a>01230   {
<a name="l01231"></a>01231     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01232"></a>01232             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01233"></a>01233             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01234"></a>01234     <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;NumericT, F&gt;</a> result = proxy1;
<a name="l01235"></a>01235     result += proxy2;
<a name="l01236"></a>01236     <span class="keywordflow">return</span> result;
<a name="l01237"></a>01237   }
<a name="l01238"></a>01238   
<a name="l01239"></a>01239   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01240"></a>01240             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01241"></a>01241   matrix&lt;NumericT, F&gt;
<a name="l01242"></a><a class="code" href="namespaceviennacl.html#a9fa036b3f0f44238017a31ad88c80d86">01242</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01243"></a>01243               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01244"></a>01244   {
<a name="l01245"></a>01245     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01246"></a>01246             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01247"></a>01247             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01248"></a>01248     <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;NumericT, F&gt;</a> result = proxy1;
<a name="l01249"></a>01249     result += proxy2;
<a name="l01250"></a>01250     <span class="keywordflow">return</span> result;
<a name="l01251"></a>01251   }
<a name="l01252"></a>01252   
<a name="l01253"></a>01253   
<a name="l01254"></a>01254   
<a name="l01256"></a>01256   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01257"></a>01257   matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> matrix_base&lt;NumericT, F&gt;, op_add &gt; 
<a name="l01258"></a><a class="code" href="namespaceviennacl.html#a5372fd531482dd77aac96fba60b4538f">01258</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m2) 
<a name="l01259"></a>01259   {
<a name="l01260"></a>01260     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01261"></a>01261                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01262"></a>01262                               op_add &gt; (m1, m2);
<a name="l01263"></a>01263   }
<a name="l01264"></a>01264 
<a name="l01266"></a>01266   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP&gt;
<a name="l01267"></a>01267   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a>,
<a name="l01268"></a>01268                                 matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;,
<a name="l01269"></a>01269                                                    <span class="keyword">const</span> matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S3, OP&gt;,
<a name="l01270"></a>01270                                                    op_add &gt;
<a name="l01271"></a>01271                               &gt;::type
<a name="l01272"></a><a class="code" href="namespaceviennacl.html#a443dcf4c6c1a880daee9c7386f4b6fdb">01272</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01273"></a>01273               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP&gt; &amp; proxy) 
<a name="l01274"></a>01274   {
<a name="l01275"></a>01275     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01276"></a>01276                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP&gt;,
<a name="l01277"></a>01277                               op_add &gt; (m1, proxy);
<a name="l01278"></a>01278   }
<a name="l01279"></a>01279   
<a name="l01281"></a>01281   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01282"></a>01282   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01283"></a>01283                                 matrix_expression&lt; const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S2, OP&gt;,
<a name="l01284"></a>01284                                                    <span class="keyword">const</span> matrix_base&lt;NumericT, F&gt;,
<a name="l01285"></a>01285                                                    op_add &gt;
<a name="l01286"></a>01286                               &gt;::type
<a name="l01287"></a><a class="code" href="namespaceviennacl.html#a5d1fff024f156a58a991d59fd465a507">01287</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy,
<a name="l01288"></a>01288               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m3) 
<a name="l01289"></a>01289   {
<a name="l01290"></a>01290     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt;,
<a name="l01291"></a>01291                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01292"></a>01292                               op_add &gt; (proxy, m3);
<a name="l01293"></a>01293   }
<a name="l01294"></a>01294   
<a name="l01295"></a>01295   
<a name="l01301"></a>01301   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01302"></a>01302             <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l01303"></a>01303             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l01304"></a>01304   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01305"></a>01305                                 matrix_expression&lt;const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l01306"></a>01306                                                   <span class="keyword">const</span> matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01307"></a>01307                                                   op_add&gt;
<a name="l01308"></a>01308                               &gt;::type
<a name="l01309"></a><a class="code" href="namespaceviennacl.html#a857040281dd174c8ac87528f047d5c0a">01309</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; lhs,
<a name="l01310"></a>01310               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt; <span class="keyword">const</span> &amp; rhs)
<a name="l01311"></a>01311   {
<a name="l01312"></a>01312     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l01313"></a>01313                              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01314"></a>01314                              op_add&gt;(lhs, rhs);
<a name="l01315"></a>01315   }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317   
<a name="l01318"></a>01318   
<a name="l01319"></a>01319   
<a name="l01320"></a>01320   <span class="comment">// operator +=</span>
<a name="l01321"></a>01321   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01322"></a>01322   matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01323"></a><a class="code" href="namespaceviennacl.html#a589ea656a161143b696e4e10283461f3">01323</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; other) 
<a name="l01324"></a>01324   {
<a name="l01325"></a>01325     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(m1,
<a name="l01326"></a>01326                            m1,    NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01327"></a>01327                            other, NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01328"></a>01328     <span class="keywordflow">return</span> m1;
<a name="l01329"></a>01329   }
<a name="l01330"></a>01330 
<a name="l01333"></a>01333   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01334"></a>01334   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01335"></a>01335                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01336"></a><a class="code" href="namespaceviennacl.html#a34d0383bb21e7539bd4abe967918dc0c">01336</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, 
<a name="l01337"></a>01337                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy)
<a name="l01338"></a>01338   {
<a name="l01339"></a>01339     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01340"></a>01340             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01341"></a>01341             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01342"></a>01342 
<a name="l01343"></a>01343     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01344"></a>01344       <a class="code" href="namespaceviennacl_1_1linalg.html#abe7161810c732e58a047eac3ec15134a">viennacl::linalg::ambm</a>(m1, 
<a name="l01345"></a>01345                              m1,        NumericT(1.0), 1, <span class="keyword">false</span>,                                             <span class="keyword">false</span>,
<a name="l01346"></a>01346                              proxy.lhs(), proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01347"></a>01347     <span class="keywordflow">return</span> m1;
<a name="l01348"></a>01348   }
<a name="l01349"></a>01349 
<a name="l01355"></a>01355   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> OP&gt;
<a name="l01356"></a>01356   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>,
<a name="l01357"></a>01357                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01358"></a><a class="code" href="namespaceviennacl.html#aa33e6eb5ca54fc6763be5c488564eebe">01358</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, 
<a name="l01359"></a>01359                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, OP&gt; &amp; proxy)
<a name="l01360"></a>01360   {
<a name="l01361"></a>01361     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01362"></a>01362             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01363"></a>01363             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01364"></a>01364 
<a name="l01365"></a>01365     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01366"></a>01366       <a class="code" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01367"></a>01367                                 proxy.lhs(), NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01368"></a>01368                                 proxy.rhs(), NumericT(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01369"></a>01369     <span class="keywordflow">return</span> m1;
<a name="l01370"></a>01370   }
<a name="l01371"></a>01371   
<a name="l01377"></a>01377   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01378"></a>01378             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01379"></a>01379             <span class="keyword">typename</span> OP&gt;
<a name="l01380"></a>01380   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01381"></a>01381                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01382"></a>01382                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01383"></a><a class="code" href="namespaceviennacl.html#a9148ebbd8fc6c6ba770c9e57ca8c302c">01383</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01384"></a>01384                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01385"></a>01385                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01386"></a>01386                                         OP&gt; &amp; proxy)
<a name="l01387"></a>01387   {
<a name="l01388"></a>01388     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01389"></a>01389             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01390"></a>01390             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01391"></a>01391 
<a name="l01392"></a>01392     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l01395"></a>01395       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01396"></a>01396         flip_sign_3 = !flip_sign_3;
<a name="l01397"></a>01397       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#aae3804f0747aa8346818a989062980c3">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01398"></a>01398                                 proxy.lhs(),           NumericT(1.0), 1, false                                             , <span class="keyword">false</span>,
<a name="l01399"></a>01399                                 proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401     <span class="keywordflow">return</span> m1;
<a name="l01402"></a>01402   }
<a name="l01403"></a>01403 
<a name="l01409"></a>01409   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01410"></a>01410             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01411"></a>01411             <span class="keyword">typename</span> OP&gt;
<a name="l01412"></a>01412   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01413"></a>01413                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01414"></a>01414                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01415"></a><a class="code" href="namespaceviennacl.html#a4da9f947cf67d8eb0ea0244c38d34059">01415</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01416"></a>01416                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01417"></a>01417                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01418"></a>01418                                         OP&gt; &amp; proxy)
<a name="l01419"></a>01419   {
<a name="l01420"></a>01420     assert(   (proxy.size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01421"></a>01421             &amp;&amp; (proxy.size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01422"></a>01422             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01425"></a>01425       <a class="code" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01426"></a>01426                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l01427"></a>01427                                 proxy.rhs(),           NumericT(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01428"></a>01428     <span class="keywordflow">return</span> m1;
<a name="l01429"></a>01429   }
<a name="l01430"></a>01430   
<a name="l01436"></a>01436   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01437"></a>01437             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01438"></a>01438             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01439"></a>01439             <span class="keyword">typename</span> OP&gt;
<a name="l01440"></a>01440   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01441"></a>01441                                 &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01442"></a>01442                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01443"></a>01443                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01444"></a><a class="code" href="namespaceviennacl.html#aea14a59372ddd475eb821c6a589d4268">01444</a>   <span class="keyword">operator</span> += (<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01445"></a>01445                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01446"></a>01446                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01447"></a>01447                                         OP&gt; &amp; proxy)
<a name="l01448"></a>01448   {
<a name="l01449"></a>01449     assert(   (proxy.size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01450"></a>01450             &amp;&amp; (proxy.size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01451"></a>01451             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01452"></a>01452 
<a name="l01453"></a>01453     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01454"></a>01454     {
<a name="l01455"></a>01455       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l01456"></a>01456       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01457"></a>01457         flip_sign_3 = !flip_sign_3;
<a name="l01458"></a>01458       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#aae3804f0747aa8346818a989062980c3">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01459"></a>01459                                proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l01460"></a>01460                                proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462     <span class="keywordflow">return</span> m1;
<a name="l01463"></a>01463   }
<a name="l01464"></a>01464   
<a name="l01465"></a>01465   
<a name="l01466"></a>01466   
<a name="l01467"></a>01467   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01468"></a>01468   matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01469"></a><a class="code" href="namespaceviennacl.html#a65aa6fc53cb1fffb53cf9874db013eb0">01469</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01470"></a>01470                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod &gt; &amp; proxy) 
<a name="l01471"></a>01471   {
<a name="l01472"></a>01472     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac5c0508032a1cc386f096bd8e8160e80" title="The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update...">viennacl::linalg::scaled_rank_1_update</a>(m1,
<a name="l01473"></a>01473                                             NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01474"></a>01474                                             proxy.lhs(),
<a name="l01475"></a>01475                                             proxy.rhs());
<a name="l01476"></a>01476     <span class="keywordflow">return</span> m1;
<a name="l01477"></a>01477   }
<a name="l01478"></a>01478 
<a name="l01479"></a>01479   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l01480"></a>01480   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01481"></a>01481                                 matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01482"></a>01482                               &gt;::type
<a name="l01483"></a><a class="code" href="namespaceviennacl.html#ade18df55cbc05cd34eef188baf75d0f4">01483</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01484"></a>01484                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod &gt;,
<a name="l01485"></a>01485                                         <span class="keyword">const</span> S1,
<a name="l01486"></a>01486                                         op_prod &gt; &amp; proxy) 
<a name="l01487"></a>01487   {
<a name="l01488"></a>01488     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac5c0508032a1cc386f096bd8e8160e80" title="The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update...">viennacl::linalg::scaled_rank_1_update</a>(m1,
<a name="l01489"></a>01489                                            proxy.rhs(), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l01490"></a>01490                                            proxy.lhs().lhs(),
<a name="l01491"></a>01491                                            proxy.lhs().rhs());
<a name="l01492"></a>01492     <span class="keywordflow">return</span> m1;
<a name="l01493"></a>01493   }
<a name="l01494"></a>01494   
<a name="l01495"></a>01495   <span class="comment">//C += A * B </span>
<a name="l01496"></a>01496   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01497"></a>01497   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01498"></a><a class="code" href="namespaceviennacl.html#a0c4b121a63ee355f6cf18b56949b51a4">01498</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01499"></a>01499                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01500"></a>01500                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01501"></a>01501                                         op_prod &gt; &amp; proxy) 
<a name="l01502"></a>01502   {
<a name="l01503"></a>01503     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, 1.0, 1.0);
<a name="l01504"></a>01504     <span class="keywordflow">return</span> m1;
<a name="l01505"></a>01505   }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01508"></a>01508   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01509"></a><a class="code" href="namespaceviennacl.html#a2c5a85799c2db6530c2f9eeabbb1ef53">01509</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01510"></a>01510                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01511"></a>01511                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01512"></a>01512                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01513"></a>01513                                                                  op_trans&gt;,
<a name="l01514"></a>01514                                         op_prod &gt; &amp; proxy) 
<a name="l01515"></a>01515   {
<a name="l01516"></a>01516     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, 1.0, 1.0);
<a name="l01517"></a>01517     <span class="keywordflow">return</span> m1;
<a name="l01518"></a>01518   }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01521"></a>01521   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01522"></a><a class="code" href="namespaceviennacl.html#a6b7ef92927cd5b04a6d7f5c4150f0512">01522</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01523"></a>01523                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01524"></a>01524                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01525"></a>01525                                                                  op_trans&gt;,
<a name="l01526"></a>01526                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01527"></a>01527                                         op_prod &gt; &amp; proxy) 
<a name="l01528"></a>01528   {
<a name="l01529"></a>01529     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, 1.0, 1.0);
<a name="l01530"></a>01530     <span class="keywordflow">return</span> m1;
<a name="l01531"></a>01531   }
<a name="l01532"></a>01532 
<a name="l01533"></a>01533   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01534"></a>01534   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01535"></a><a class="code" href="namespaceviennacl.html#a4f6de4f40e96f9a18fd52875e8fe8fa0">01535</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01536"></a>01536                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01537"></a>01537                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01538"></a>01538                                                                  op_trans&gt;,
<a name="l01539"></a>01539                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01540"></a>01540                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01541"></a>01541                                                                  op_trans&gt;,
<a name="l01542"></a>01542                                         op_prod &gt; &amp; proxy) 
<a name="l01543"></a>01543   {
<a name="l01544"></a>01544     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, 1.0, 1.0);
<a name="l01545"></a>01545     <span class="keywordflow">return</span> m1;
<a name="l01546"></a>01546   }
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   
<a name="l01549"></a>01549     
<a name="l01550"></a>01550   
<a name="l01551"></a>01551   
<a name="l01552"></a>01552   <span class="comment">// operator -</span>
<a name="l01554"></a>01554 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01555"></a>01555             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01556"></a>01556   <span class="keyword">typename</span> matrix_expression&lt; LHS1, RHS1, OP1&gt;::matrix_type
<a name="l01557"></a><a class="code" href="namespaceviennacl.html#ade34780cdab333f3ec7fa9891575cbb3">01557</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01558"></a>01558               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01559"></a>01559   {
<a name="l01560"></a>01560     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01561"></a>01561             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01562"></a>01562             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01563"></a>01563     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_expression&lt; LHS1, RHS1, OP1&gt;::matrix_type</a> result = proxy1;
<a name="l01564"></a>01564     result -= proxy2;
<a name="l01565"></a>01565     <span class="keywordflow">return</span> result;
<a name="l01566"></a>01566   }
<a name="l01567"></a>01567   
<a name="l01568"></a>01568   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01569"></a>01569             <span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01570"></a>01570   matrix&lt;NumericT, F&gt;
<a name="l01571"></a><a class="code" href="namespaceviennacl.html#a3ee94920320eca8859c6c701a144eec1">01571</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01572"></a>01572               <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01573"></a>01573   {
<a name="l01574"></a>01574     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01575"></a>01575             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01576"></a>01576             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01577"></a>01577     <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;NumericT, F&gt;</a> result = proxy1;
<a name="l01578"></a>01578     result -= proxy2;
<a name="l01579"></a>01579     <span class="keywordflow">return</span> result;
<a name="l01580"></a>01580   }
<a name="l01581"></a>01581   
<a name="l01582"></a>01582   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01583"></a>01583             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01584"></a>01584   matrix&lt;NumericT, F&gt;
<a name="l01585"></a><a class="code" href="namespaceviennacl.html#ab5d56f1aa9c09f89634e90bdd081dbd5">01585</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01586"></a>01586               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01587"></a>01587   {
<a name="l01588"></a>01588     assert(    (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy2))
<a name="l01589"></a>01589             &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy1) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy2))
<a name="l01590"></a>01590             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01591"></a>01591     <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;NumericT, F&gt;</a> result = proxy1;
<a name="l01592"></a>01592     result -= proxy2;
<a name="l01593"></a>01593     <span class="keywordflow">return</span> result;
<a name="l01594"></a>01594   }
<a name="l01595"></a>01595   
<a name="l01596"></a>01596   
<a name="l01597"></a>01597   
<a name="l01599"></a>01599   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01600"></a>01600   matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> matrix_base&lt;NumericT, F&gt;, op_sub &gt; 
<a name="l01601"></a><a class="code" href="namespaceviennacl.html#a5bf54d540a468ff7b897e5b4d9b8b330">01601</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m2) 
<a name="l01602"></a>01602   {
<a name="l01603"></a>01603     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01604"></a>01604                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01605"></a>01605                               op_sub &gt; (m1, m2);
<a name="l01606"></a>01606   }
<a name="l01607"></a>01607 
<a name="l01609"></a>01609   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP&gt;
<a name="l01610"></a>01610   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a>,
<a name="l01611"></a>01611                                 matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;,
<a name="l01612"></a>01612                                                    <span class="keyword">const</span> matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S3, OP&gt;,
<a name="l01613"></a>01613                                                    op_sub &gt;
<a name="l01614"></a>01614                               &gt;::type
<a name="l01615"></a><a class="code" href="namespaceviennacl.html#ab3937a50a0a176a37c84929bf1cbd1ae">01615</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01616"></a>01616               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP&gt; &amp; proxy) 
<a name="l01617"></a>01617   {
<a name="l01618"></a>01618     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01619"></a>01619                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP&gt;,
<a name="l01620"></a>01620                               op_sub &gt; (m1, proxy);
<a name="l01621"></a>01621   }
<a name="l01622"></a>01622   
<a name="l01624"></a>01624   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01625"></a>01625   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01626"></a>01626                                 matrix_expression&lt; const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S2, OP&gt;,
<a name="l01627"></a>01627                                                    <span class="keyword">const</span> matrix_base&lt;NumericT, F&gt;,
<a name="l01628"></a>01628                                                    op_sub &gt;
<a name="l01629"></a>01629                               &gt;::type
<a name="l01630"></a><a class="code" href="namespaceviennacl.html#ac723ebaf79518ca727079ff5684de9ff">01630</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy,
<a name="l01631"></a>01631               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m3) 
<a name="l01632"></a>01632   {
<a name="l01633"></a>01633     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt;,
<a name="l01634"></a>01634                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01635"></a>01635                               op_sub &gt; (proxy, m3);
<a name="l01636"></a>01636   }
<a name="l01637"></a>01637   
<a name="l01638"></a>01638   
<a name="l01644"></a>01644   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01645"></a>01645             <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l01646"></a>01646             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l01647"></a>01647   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01648"></a>01648                                 matrix_expression&lt;const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l01649"></a>01649                                                   <span class="keyword">const</span> matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01650"></a>01650                                                   op_sub&gt;
<a name="l01651"></a>01651                               &gt;::type
<a name="l01652"></a><a class="code" href="namespaceviennacl.html#a047d1ad8f03c586d67cdfd52dfc9998a">01652</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; lhs,
<a name="l01653"></a>01653               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt; <span class="keyword">const</span> &amp; rhs)
<a name="l01654"></a>01654   {
<a name="l01655"></a>01655     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l01656"></a>01656                              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt;const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01657"></a>01657                              op_sub&gt;(lhs, rhs);
<a name="l01658"></a>01658   }
<a name="l01659"></a>01659 
<a name="l01660"></a>01660   
<a name="l01661"></a>01661   
<a name="l01662"></a>01662   
<a name="l01663"></a>01663   <span class="comment">// operator -=</span>
<a name="l01664"></a>01664   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01665"></a>01665   matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01666"></a><a class="code" href="namespaceviennacl.html#a4c1114da061dab23aeb89e2a3801ca2d">01666</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; other) 
<a name="l01667"></a>01667   {
<a name="l01668"></a>01668     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac228edc777e628e3c027774859115279">viennacl::linalg::ambm</a>(m1,
<a name="l01669"></a>01669                            m1,    NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01670"></a>01670                            other, NumericT(-1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01671"></a>01671     <span class="keywordflow">return</span> m1;
<a name="l01672"></a>01672   }
<a name="l01673"></a>01673 
<a name="l01676"></a>01676   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01677"></a>01677   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01678"></a>01678                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01679"></a><a class="code" href="namespaceviennacl.html#a0347efecac1e4749853a6067c247bfc0">01679</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, 
<a name="l01680"></a>01680                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy)
<a name="l01681"></a>01681   {
<a name="l01682"></a>01682     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01683"></a>01683             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01684"></a>01684             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01685"></a>01685 
<a name="l01686"></a>01686     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01687"></a>01687       <a class="code" href="namespaceviennacl_1_1linalg.html#abe7161810c732e58a047eac3ec15134a">viennacl::linalg::ambm</a>(m1, 
<a name="l01688"></a>01688                              m1,          NumericT(1.0), 1, <span class="keyword">false</span>,                                             <span class="keyword">false</span>,
<a name="l01689"></a>01689                              proxy.lhs(),   proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>) );
<a name="l01690"></a>01690     <span class="keywordflow">return</span> m1;
<a name="l01691"></a>01691   }
<a name="l01692"></a>01692 
<a name="l01698"></a>01698   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> OP&gt;
<a name="l01699"></a>01699   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>,
<a name="l01700"></a>01700                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01701"></a><a class="code" href="namespaceviennacl.html#a9ef187e5bc4a09bff5a3fbf1ebb9ac09">01701</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, 
<a name="l01702"></a>01702                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, OP&gt; &amp; proxy)
<a name="l01703"></a>01703   {
<a name="l01704"></a>01704     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01705"></a>01705             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01706"></a>01706             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01707"></a>01707 
<a name="l01708"></a>01708     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01709"></a>01709       <a class="code" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01710"></a>01710                                proxy.lhs(), NumericT(1.0), 1, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l01711"></a>01711                                proxy.rhs(), NumericT(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>) );
<a name="l01712"></a>01712     <span class="keywordflow">return</span> m1;
<a name="l01713"></a>01713   }
<a name="l01714"></a>01714   
<a name="l01720"></a>01720   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01721"></a>01721             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01722"></a>01722             <span class="keyword">typename</span> OP&gt;
<a name="l01723"></a>01723   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01724"></a>01724                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01725"></a>01725                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01726"></a><a class="code" href="namespaceviennacl.html#a05d885974dab948d3ccebd63eca79d60">01726</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01727"></a>01727                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01728"></a>01728                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01729"></a>01729                                         OP&gt; &amp; proxy)
<a name="l01730"></a>01730   {
<a name="l01731"></a>01731     assert(   (proxy.lhs().size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01732"></a>01732             &amp;&amp; (proxy.lhs().size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01733"></a>01733             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01734"></a>01734 
<a name="l01735"></a>01735     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01736"></a>01736     {
<a name="l01737"></a>01737       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>);
<a name="l01738"></a>01738       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01739"></a>01739         flip_sign_3 = !flip_sign_3;
<a name="l01740"></a>01740       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#aae3804f0747aa8346818a989062980c3">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01741"></a>01741                                proxy.lhs(),           NumericT(1.0), 1, false                                             , <span class="keyword">true</span>,
<a name="l01742"></a>01742                                proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01743"></a>01743     }
<a name="l01744"></a>01744     <span class="keywordflow">return</span> m1;
<a name="l01745"></a>01745   }
<a name="l01746"></a>01746 
<a name="l01752"></a>01752   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01753"></a>01753             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01754"></a>01754             <span class="keyword">typename</span> OP&gt;
<a name="l01755"></a>01755   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01756"></a>01756                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01757"></a>01757                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01758"></a><a class="code" href="namespaceviennacl.html#a55b1051cab786c1642e3be9bf5d8e47a">01758</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01759"></a>01759                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01760"></a>01760                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>,
<a name="l01761"></a>01761                                         OP&gt; &amp; proxy)
<a name="l01762"></a>01762   {
<a name="l01763"></a>01763     assert(   (proxy.size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01764"></a>01764             &amp;&amp; (proxy.size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01765"></a>01765             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01766"></a>01766 
<a name="l01767"></a>01767     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01768"></a>01768       <a class="code" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01769"></a>01769                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>),
<a name="l01770"></a>01770                                 proxy.rhs(),           NumericT(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>) );
<a name="l01771"></a>01771     <span class="keywordflow">return</span> m1;
<a name="l01772"></a>01772   }
<a name="l01773"></a>01773   
<a name="l01779"></a>01779   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l01780"></a>01780             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01781"></a>01781             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01782"></a>01782             <span class="keyword">typename</span> OP&gt;
<a name="l01783"></a>01783   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01784"></a>01784                                 &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01785"></a>01785                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01786"></a>01786                                 matrix_base&lt;NumericT, F&gt; &amp;&gt;::type
<a name="l01787"></a><a class="code" href="namespaceviennacl.html#a79aa95be516cd60f5f8c150ca3ac5890">01787</a>   <span class="keyword">operator</span> -= (<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01788"></a>01788                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01789"></a>01789                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01790"></a>01790                                         OP&gt; &amp; proxy)
<a name="l01791"></a>01791   {
<a name="l01792"></a>01792     assert(   (proxy.size1() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>())
<a name="l01793"></a>01793             &amp;&amp; (proxy.size2() == m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>())
<a name="l01794"></a>01794             &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible matrix sizes!&quot;</span>));
<a name="l01795"></a>01795 
<a name="l01796"></a>01796     <span class="keywordflow">if</span> (m1.<a class="code" href="classviennacl_1_1matrix__base.html#a7dd094a9c9324a396059b30e5bc6c997" title="Returns the number of rows.">size1</a>() &gt; 0 &amp;&amp; m1.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() &gt; 0)
<a name="l01797"></a>01797     {
<a name="l01798"></a>01798       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>);
<a name="l01799"></a>01799       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01800"></a>01800         flip_sign_3 = !flip_sign_3;
<a name="l01801"></a>01801       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#aae3804f0747aa8346818a989062980c3">viennacl::linalg::ambm_m</a>(m1, 
<a name="l01802"></a>01802                                proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>),
<a name="l01803"></a>01803                                proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01804"></a>01804     }
<a name="l01805"></a>01805     <span class="keywordflow">return</span> m1;
<a name="l01806"></a>01806   }
<a name="l01807"></a>01807   
<a name="l01808"></a>01808   
<a name="l01809"></a>01809   
<a name="l01810"></a>01810   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01811"></a>01811   matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01812"></a><a class="code" href="namespaceviennacl.html#a92ebc8a66ef351841c7b7f98e07dbbd7">01812</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01813"></a>01813                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod &gt; &amp; proxy) 
<a name="l01814"></a>01814   {
<a name="l01815"></a>01815     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac5c0508032a1cc386f096bd8e8160e80" title="The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update...">viennacl::linalg::scaled_rank_1_update</a>(m1,
<a name="l01816"></a>01816                                            NumericT(-1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01817"></a>01817                                            proxy.lhs(),
<a name="l01818"></a>01818                                            proxy.rhs());
<a name="l01819"></a>01819     <span class="keywordflow">return</span> m1;
<a name="l01820"></a>01820   }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l01823"></a>01823   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01824"></a>01824                                 matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01825"></a>01825                               &gt;::type
<a name="l01826"></a><a class="code" href="namespaceviennacl.html#a98c6ed5cc7e0ccf8e1c81c535764456c">01826</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1,
<a name="l01827"></a>01827                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod &gt;,
<a name="l01828"></a>01828                                         <span class="keyword">const</span> S1,
<a name="l01829"></a>01829                                         op_prod &gt; &amp; proxy) 
<a name="l01830"></a>01830   {
<a name="l01831"></a>01831     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ac5c0508032a1cc386f096bd8e8160e80" title="The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update...">viennacl::linalg::scaled_rank_1_update</a>(m1,
<a name="l01832"></a>01832                                            proxy.rhs(), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>),
<a name="l01833"></a>01833                                            proxy.lhs().lhs(),
<a name="l01834"></a>01834                                            proxy.lhs().rhs());
<a name="l01835"></a>01835     <span class="keywordflow">return</span> m1;
<a name="l01836"></a>01836   }
<a name="l01837"></a>01837   
<a name="l01838"></a>01838   <span class="comment">//C -= A * B </span>
<a name="l01839"></a>01839   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01840"></a>01840   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01841"></a><a class="code" href="namespaceviennacl.html#a4e8e57c6d7a5347efa0e6856969b4fcc">01841</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01842"></a>01842                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>, op_prod &gt; &amp; proxy) 
<a name="l01843"></a>01843   {
<a name="l01844"></a>01844     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, -1.0, 1.0);
<a name="l01845"></a>01845     <span class="keywordflow">return</span> m1;
<a name="l01846"></a>01846   }
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01849"></a>01849   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01850"></a><a class="code" href="namespaceviennacl.html#ac9664f3c9e1b076a7d3dff4bce7e4648">01850</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01851"></a>01851                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01852"></a>01852                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01853"></a>01853                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01854"></a>01854                                                                  op_trans&gt;,
<a name="l01855"></a>01855                                         op_prod &gt; &amp; proxy) 
<a name="l01856"></a>01856   {
<a name="l01857"></a>01857     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, -1.0, 1.0);
<a name="l01858"></a>01858     <span class="keywordflow">return</span> m1;
<a name="l01859"></a>01859   }
<a name="l01860"></a>01860 
<a name="l01861"></a>01861   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01862"></a>01862   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01863"></a><a class="code" href="namespaceviennacl.html#ac3146800de331cf9d37bc17b595f0c4a">01863</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01864"></a>01864                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01865"></a>01865                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01866"></a>01866                                                                  op_trans&gt;,
<a name="l01867"></a>01867                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01868"></a>01868                                         op_prod &gt; &amp; proxy) 
<a name="l01869"></a>01869   {
<a name="l01870"></a>01870     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, -1.0, 1.0);
<a name="l01871"></a>01871     <span class="keywordflow">return</span> m1;
<a name="l01872"></a>01872   }
<a name="l01873"></a>01873 
<a name="l01874"></a>01874   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3&gt;
<a name="l01875"></a>01875   matrix_base&lt;NumericT, F1&gt; &amp;
<a name="l01876"></a><a class="code" href="namespaceviennacl.html#af69e2a594dbe57b26b362423c99ae15b">01876</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; m1,
<a name="l01877"></a>01877                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01878"></a>01878                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>,
<a name="l01879"></a>01879                                                                  op_trans&gt;,
<a name="l01880"></a>01880                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01881"></a>01881                                                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a>,
<a name="l01882"></a>01882                                                                  op_trans&gt;,
<a name="l01883"></a>01883                                         op_prod &gt; &amp; proxy) 
<a name="l01884"></a>01884   {
<a name="l01885"></a>01885     <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), m1, -1.0, 1.0);
<a name="l01886"></a>01886     <span class="keywordflow">return</span> m1;
<a name="l01887"></a>01887   }
<a name="l01888"></a>01888   
<a name="l01889"></a>01889   
<a name="l01890"></a>01890 
<a name="l01891"></a>01891   
<a name="l01892"></a>01892   <span class="comment">// operator *</span>
<a name="l01898"></a>01898 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l01899"></a>01899   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01900"></a>01900                                 matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S1, op_prod&gt;
<a name="l01901"></a>01901                               &gt;::type 
<a name="l01902"></a><a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56">01902</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(S1 <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1value.html">value</a>, <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; m1)
<a name="l01903"></a>01903   {
<a name="l01904"></a>01904     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, op_prod&gt;(m1, value);
<a name="l01905"></a>01905   }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 
<a name="l01913"></a>01913   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> S1&gt;
<a name="l01914"></a>01914   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01915"></a>01915                                 <span class="keyword">typename</span> matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type
<a name="l01916"></a><a class="code" href="namespaceviennacl.html#a46e86d4d82f9a538bd7c36753f93578b">01916</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01917"></a>01917               S1 <span class="keyword">const</span> &amp; val)
<a name="l01918"></a>01918   {
<a name="l01919"></a>01919     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type</a> result(proxy.<a class="code" href="classviennacl_1_1matrix__expression.html#a86ca1671903a30f6c861897f6b516c12" title="Returns the size of the result vector.">size1</a>(), proxy.<a class="code" href="classviennacl_1_1matrix__expression.html#acfb022af062a8199d74d46018edb21ed">size2</a>());
<a name="l01920"></a>01920     result = proxy;
<a name="l01921"></a>01921     result *= val;
<a name="l01922"></a>01922     <span class="keywordflow">return</span> result;
<a name="l01923"></a>01923   }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925 
<a name="l01931"></a>01931   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01932"></a>01932   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01933"></a>01933                                 <span class="keyword">typename</span> matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type
<a name="l01934"></a><a class="code" href="namespaceviennacl.html#a1345a355bd88a925ece2c3906f44e7b9">01934</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(S1 <span class="keyword">const</span> &amp; val,
<a name="l01935"></a>01935               <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l01936"></a>01936   {
<a name="l01937"></a>01937     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type</a> result(proxy.size());
<a name="l01938"></a>01938     result = proxy;
<a name="l01939"></a>01939     result *= val;
<a name="l01940"></a>01940     <span class="keywordflow">return</span> result;
<a name="l01941"></a>01941   }
<a name="l01942"></a>01942   
<a name="l01945"></a>01945   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l01946"></a>01946   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01947"></a>01947                                 matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S1, op_prod&gt; &gt;::type
<a name="l01948"></a><a class="code" href="namespaceviennacl.html#a622a198be6623dc648710da7ff66826f">01948</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; m1, S1 <span class="keyword">const</span> &amp; s1)
<a name="l01949"></a>01949   {
<a name="l01950"></a>01950     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, op_prod&gt;(m1, s1);
<a name="l01951"></a>01951   }
<a name="l01952"></a>01952   
<a name="l01953"></a>01953   
<a name="l01954"></a>01954   <span class="comment">// operator *=</span>
<a name="l01955"></a>01955 
<a name="l01958"></a>01958   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l01959"></a>01959   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_scalar&lt;S1&gt;::value</a>,
<a name="l01960"></a>01960                                 matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l01961"></a>01961                               &gt;::type
<a name="l01962"></a><a class="code" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4">01962</a>   <a class="code" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4" title="Scales a matrix by a GPU scalar value.">operator *= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, S1 <span class="keyword">const</span> &amp; gpu_val)
<a name="l01963"></a>01963   {
<a name="l01964"></a>01964     <span class="comment">//viennacl::linalg::inplace_mult(*this, gpu_val);</span>
<a name="l01965"></a>01965     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(m1,
<a name="l01966"></a>01966                          m1, gpu_val, 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l01967"></a>01967     <span class="keywordflow">return</span> m1;
<a name="l01968"></a>01968   }
<a name="l01969"></a>01969 
<a name="l01970"></a>01970   
<a name="l01971"></a>01971   <span class="comment">// operator /</span>
<a name="l01972"></a>01972   
<a name="l01973"></a>01973   
<a name="l01979"></a>01979   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01980"></a>01980   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01981"></a>01981                                 <span class="keyword">typename</span> matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type
<a name="l01982"></a><a class="code" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f">01982</a>   <a class="code" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f" title="Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a matrix_expression and then divided by alpha.">operator / </a>(<a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01983"></a>01983               S1 <span class="keyword">const</span> &amp; val)
<a name="l01984"></a>01984   {
<a name="l01985"></a>01985     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1matrix__expression.html#a23b7b11067236927faea30d7acdd7936" title="Extracts the vector type from the two operands.">matrix_expression&lt; LHS, RHS, OP&gt;::matrix_type</a> result(proxy.<a class="code" href="classviennacl_1_1matrix__expression.html#a86ca1671903a30f6c861897f6b516c12" title="Returns the size of the result vector.">size1</a>(), proxy.<a class="code" href="classviennacl_1_1matrix__expression.html#acfb022af062a8199d74d46018edb21ed">size2</a>());
<a name="l01986"></a>01986     result = proxy;
<a name="l01987"></a>01987     result /= val;
<a name="l01988"></a>01988     <span class="keywordflow">return</span> result;
<a name="l01989"></a>01989   }
<a name="l01990"></a>01990 
<a name="l01991"></a>01991 
<a name="l01994"></a>01994   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l01995"></a>01995   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01996"></a>01996                                 matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;, <span class="keyword">const</span> S1, op_div&gt; &gt;::type
<a name="l01997"></a><a class="code" href="namespaceviennacl.html#acc8e629b037b3ae3dd4dccf7fd277250">01997</a>   <a class="code" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f" title="Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a matrix_expression and then divided by alpha.">operator / </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; m1, S1 <span class="keyword">const</span> &amp; s1)
<a name="l01998"></a>01998   {
<a name="l01999"></a>01999     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; const matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> S1, op_div&gt;(m1, s1);
<a name="l02000"></a>02000   }
<a name="l02001"></a>02001   
<a name="l02002"></a>02002   
<a name="l02003"></a>02003   <span class="comment">// operator /=</span>
<a name="l02004"></a>02004   
<a name="l02007"></a>02007   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l02008"></a>02008   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_scalar&lt;S1&gt;::value</a>,
<a name="l02009"></a>02009                                 matrix_base&lt;NumericT, F&gt; &amp; 
<a name="l02010"></a>02010                               &gt;::type
<a name="l02011"></a><a class="code" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453">02011</a>   <a class="code" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453" title="Scales a matrix by a GPU scalar value.">operator /= </a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; m1, S1 <span class="keyword">const</span> &amp; gpu_val)
<a name="l02012"></a>02012   {
<a name="l02013"></a>02013     <span class="comment">//viennacl::linalg::inplace_divide(*this, gpu_val);</span>
<a name="l02014"></a>02014     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad45dad732d46688229fcd82f79b17893">viennacl::linalg::am</a>(m1,
<a name="l02015"></a>02015                          m1, gpu_val, 1, <span class="keyword">true</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l02016"></a>02016     <span class="keywordflow">return</span> m1;
<a name="l02017"></a>02017   }
<a name="l02018"></a>02018 
<a name="l02019"></a>02019 
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 
<a name="l02022"></a>02022 
<a name="l02023"></a>02023   <span class="comment">// outer_prod(v1, v2) * val;</span>
<a name="l02024"></a>02024   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> S1&gt;
<a name="l02025"></a>02025   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_scalar&lt;S1&gt;::value</a>,
<a name="l02026"></a>02026                                 <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02027"></a>02027                                                              <span class="keyword">const</span> S1,
<a name="l02028"></a>02028                                                              op_prod&gt;                                  
<a name="l02029"></a>02029                               &gt;::type
<a name="l02030"></a><a class="code" href="namespaceviennacl.html#a9016294abe2bb92b7c6a36110e73bb3e">02030</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator*</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod&gt; &amp; proxy,
<a name="l02031"></a>02031             <span class="keyword">const</span> S1 &amp; val)
<a name="l02032"></a>02032   {
<a name="l02033"></a>02033     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod&gt;,
<a name="l02034"></a>02034                                         <span class="keyword">const</span> S1,
<a name="l02035"></a>02035                                         op_prod&gt;(proxy, val);
<a name="l02036"></a>02036   }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> S1&gt;
<a name="l02039"></a>02039   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_cpu_scalar&lt;S1&gt;::value</a>,
<a name="l02040"></a>02040                                 <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02041"></a>02041                                                               <span class="keyword">const</span> NumericT,
<a name="l02042"></a>02042                                                               op_prod&gt;                                  
<a name="l02043"></a>02043                               &gt;::type
<a name="l02044"></a>02044   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator*</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> vector_base&lt;NumericT&gt;, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt; &amp; proxy,
<a name="l02045"></a>02045             <span class="keyword">const</span> S1 &amp; val)
<a name="l02046"></a>02046   {
<a name="l02047"></a>02047     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02048"></a>02048                                         <span class="keyword">const</span> NumericT,
<a name="l02049"></a>02049                                         op_prod&gt;(proxy, NumericT(val));
<a name="l02050"></a>02050   }
<a name="l02051"></a>02051   
<a name="l02052"></a>02052   <span class="comment">// val * outer_prod(v1, v2);</span>
<a name="l02053"></a>02053   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> S1&gt;
<a name="l02054"></a>02054   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_scalar&lt;S1&gt;::value</a>,
<a name="l02055"></a>02055                                 <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02056"></a>02056                                                              <span class="keyword">const</span> S1,
<a name="l02057"></a>02057                                                              op_prod&gt;                                  
<a name="l02058"></a>02058                               &gt;::type
<a name="l02059"></a><a class="code" href="namespaceviennacl.html#a741bc7a80ecd551f3af836b9e760c866">02059</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator*</a>(<span class="keyword">const</span> S1 &amp; val,
<a name="l02060"></a>02060             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod&gt; &amp; proxy)
<a name="l02061"></a>02061   {
<a name="l02062"></a>02062     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a>, op_prod&gt;,
<a name="l02063"></a>02063                                         <span class="keyword">const</span> S1,
<a name="l02064"></a>02064                                         op_prod&gt;(proxy, val);
<a name="l02065"></a>02065   }
<a name="l02066"></a>02066   
<a name="l02067"></a>02067   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> S1&gt;
<a name="l02068"></a>02068   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_cpu_scalar&lt;S1&gt;::value</a>,
<a name="l02069"></a>02069                                 <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02070"></a>02070                                                              <span class="keyword">const</span> NumericT,
<a name="l02071"></a>02071                                                              op_prod&gt;                                  
<a name="l02072"></a>02072                               &gt;::type
<a name="l02073"></a>02073   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator*</a>(<span class="keyword">const</span> S1 &amp; val,
<a name="l02074"></a>02074             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> vector_base&lt;NumericT&gt;, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt; &amp; proxy)
<a name="l02075"></a>02075   {
<a name="l02076"></a>02076     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; const viennacl::matrix_expression&lt; const vector_base&lt;NumericT&gt;</a>, <span class="keyword">const</span> vector_base&lt;NumericT&gt;, op_prod&gt;,
<a name="l02077"></a>02077                                         <span class="keyword">const</span> NumericT,
<a name="l02078"></a>02078                                         op_prod&gt;(proxy, NumericT(val));
<a name="l02079"></a>02079   }
<a name="l02080"></a>02080   
<a name="l02081"></a>02081   
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 } <span class="comment">//namespace viennacl</span>
<a name="l02084"></a>02084 
<a name="l02085"></a>02085 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:54 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
