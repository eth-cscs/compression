<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="viennacl::const_vector_iterator" -->
<p>A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  
 <a href="classviennacl_1_1const__vector__iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classviennacl_1_1const__vector__iterator.png" usemap="#const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;_map" alt=""/>
  <map id="const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;_map" name="const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;_map">
<area href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!" alt="vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;" shape="rect" coords="0,56,319,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">backend::mem_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a6b7e1e1a085b19cc7f3ecae6dfa946fa">const_vector_iterator</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; const &amp;vec, std::size_t index, std::size_t start=0, <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="el" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988">stride</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a6b7e1e1a085b19cc7f3ecae6dfa946fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#aceaf632421d2ba9eac40e1b5a275744b">const_vector_iterator</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const &amp;elements, std::size_t index, std::size_t start=0, <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="el" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988">stride</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for vector-like treatment of arbitrary buffers.  <a href="#aceaf632421d2ba9eac40e1b5a275744b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a832e184e247b97ecb752bf291d814dff">operator*</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the iterator and returns the value of the element. For convenience only, performance is poor due to OpenCL overhead!  <a href="#a832e184e247b97ecb752bf291d814dff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a0b50df67a5cd6493e8839fd8990500a7">operator++</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a39f7c37604fd9845ff487b36b6f88602">operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ae01970b831b1c1dc3a9f22f7a4e19cf6">operator==</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a0c704f6470bc4c7392b964dd83a1d97b">operator!=</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">operator-</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">operator+</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> diff) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad">offset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of the current element index with respect to the beginning of the buffer.  <a href="#a00b50cd5f079fc83da8f148edd6dc3ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988">stride</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index increment in the underlying buffer when incrementing the iterator to the next element.  <a href="#ab4cecc3216a2369e8d0980f33303e988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c">elements_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the entry the iterator is currently pointing to.  <a href="#ac7b422c99f5eff7804206f01c871883c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SCALARTYPE, unsigned int ALIGNMENT&gt;<br/>
class viennacl::const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</h3>

<p>A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!! </p>
<p>Every dereference operation initiates a transfer from the GPU to the CPU. The overhead of such a transfer is around 50us, so 20.000 dereferences take one second. This is four orders of magnitude slower than similar dereferences on the CPU. However, increments and comparisons of iterators is as fast as for CPU types. If you need a fast iterator, copy the whole vector to the CPU first and iterate over the CPU object, e.g. std::vector&lt;float&gt; temp; copy(gpu_vector, temp); for (std::vector&lt;float&gt;::const_iterator iter = temp.begin(); iter != temp.end(); ++iter) { //do something } Note that you may obtain inconsistent data if entries of gpu_vector are manipulated elsewhere in the meanwhile.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCALARTYPE</td><td>The underlying floating point type (either float or double) </td></tr>
    <tr><td class="paramname">ALIGNMENT</td><td>Alignment of the underlying vector, </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector</a> </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a8ad60a9ff2530781950dbfd682353e64"></a><!-- doxytag: member="viennacl::const_vector_iterator::difference_type" ref="a8ad60a9ff2530781950dbfd682353e64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__iterator.html#a7f1b8fde63313dfc323ad4f7cb81b188">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a54da31d88e477d0e9f61b0715fdc8162"></a><!-- doxytag: member="viennacl::const_vector_iterator::handle_type" ref="a54da31d88e477d0e9f61b0715fdc8162" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">backend::mem_handle</a> <a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__iterator.html#a119eae92a73ab431d6d4f24f86141722">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae59e37ebbe3a193fa2dd307e94d99518"></a><!-- doxytag: member="viennacl::const_vector_iterator::value_type" ref="ae59e37ebbe3a193fa2dd307e94d99518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt; <a class="el" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6b7e1e1a085b19cc7f3ecae6dfa946fa"></a><!-- doxytag: member="viennacl::const_vector_iterator::const_vector_iterator" ref="a6b7e1e1a085b19cc7f3ecae6dfa946fa" args="(vector_base&lt; SCALARTYPE &gt; const &amp;vec, std::size_t index, std::size_t start=0, vcl_ptrdiff_t stride=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector over which to iterate </td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the iterator </td></tr>
    <tr><td class="paramname">start</td><td>First index of the element in the vector pointed to be the iterator (for <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a> and <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>) </td></tr>
    <tr><td class="paramname">stride</td><td>Stride for the support of <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceaf632421d2ba9eac40e1b5a275744b"></a><!-- doxytag: member="viennacl::const_vector_iterator::const_vector_iterator" ref="aceaf632421d2ba9eac40e1b5a275744b" args="(handle_type const &amp;elements, std::size_t index, std::size_t start=0, vcl_ptrdiff_t stride=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for vector-like treatment of arbitrary buffers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>The buffer over which to iterate </td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the iterator </td></tr>
    <tr><td class="paramname">start</td><td>First index of the element in the vector pointed to be the iterator (for <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a> and <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>) </td></tr>
    <tr><td class="paramname">stride</td><td>Stride for the support of <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a82f9d6c89ae9a767448d32726520d77f"></a><!-- doxytag: member="viennacl::const_vector_iterator::handle" ref="a82f9d6c89ae9a767448d32726520d77f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const&amp; <a class="el" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00b50cd5f079fc83da8f148edd6dc3ad"></a><!-- doxytag: member="viennacl::const_vector_iterator::offset" ref="a00b50cd5f079fc83da8f148edd6dc3ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad">offset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset of the current element index with respect to the beginning of the buffer. </p>

</div>
</div>
<a class="anchor" id="a0c704f6470bc4c7392b964dd83a1d97b"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator!=" ref="a0c704f6470bc4c7392b964dd83a1d97b" args="(self_type const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a832e184e247b97ecb752bf291d814dff"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator*" ref="a832e184e247b97ecb752bf291d814dff" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">value_type</a> operator* </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences the iterator and returns the value of the element. For convenience only, performance is poor due to OpenCL overhead! </p>

</div>
</div>
<a class="anchor" id="a63fe5e79738641bc4c5fd1f07740e3c7"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator+" ref="a63fe5e79738641bc4c5fd1f07740e3c7" args="(difference_type diff) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a>&#160;</td>
          <td class="paramname"><em>diff</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0b50df67a5cd6493e8839fd8990500a7"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator++" ref="a0b50df67a5cd6493e8839fd8990500a7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> operator++ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a39f7c37604fd9845ff487b36b6f88602"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator++" ref="a39f7c37604fd9845ff487b36b6f88602" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aec7de6121b5440524976b3baf978fb5c"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator&#45;" ref="aec7de6121b5440524976b3baf978fb5c" args="(self_type const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae01970b831b1c1dc3a9f22f7a4e19cf6"></a><!-- doxytag: member="viennacl::const_vector_iterator::operator==" ref="ae01970b831b1c1dc3a9f22f7a4e19cf6" args="(self_type const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1const__vector__iterator.html">self_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4cecc3216a2369e8d0980f33303e988"></a><!-- doxytag: member="viennacl::const_vector_iterator::stride" ref="ab4cecc3216a2369e8d0980f33303e988" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988">stride</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index increment in the underlying buffer when incrementing the iterator to the next element. </p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ac7b422c99f5eff7804206f01c871883c"></a><!-- doxytag: member="viennacl::const_vector_iterator::elements_" ref="ac7b422c99f5eff7804206f01c871883c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> const&amp; <a class="el" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c">elements_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the entry the iterator is currently pointing to. </p>

</div>
</div>
<a class="anchor" id="af6e2d105c9719fcec9af80de8f674eb3"></a><!-- doxytag: member="viennacl::const_vector_iterator::index_" ref="af6e2d105c9719fcec9af80de8f674eb3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bfb6b7495ce1eb3ca8c893b4e01e7fb"></a><!-- doxytag: member="viennacl::const_vector_iterator::start_" ref="a8bfb6b7495ce1eb3ca8c893b4e01e7fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a46b7e18d2c57d43846852ed15166661e"></a><!-- doxytag: member="viennacl::const_vector_iterator::stride_" ref="a46b7e18d2c57d43846852ed15166661e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="el" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>viennacl/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
