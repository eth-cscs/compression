<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg::host_based Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">host_based</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg::host_based Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the host-based linear algebra backend. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation)  <a href="#a8fff650777bb47541ee70c67a25faa00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a08c38699206e277bf5d709d0a7d652cd">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation)  <a href="#a08c38699206e277bf5d709d0a7d652cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aebc69ca6f6f56e707dfd734fa012d4cb">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation)  <a href="#aebc69ca6f6f56e707dfd734fa012d4cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8983c22febdaed6bea82107c9ee703c1">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation)  <a href="#a8983c22febdaed6bea82107c9ee703c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a035b582c7138a65609eda6bff21eae40">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad49aa03302e698f44dbc49e81faf8c38">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#ad49aa03302e698f44dbc49e81faf8c38"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae5d411cb73e0e3e15cc8311ee09ff624">am</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac92a348043088864b013d9ffb40692f9">ambm</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adfbfc453162208627e54b020c6c8d223">ambm_m</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad2a289cf8e3d6dc17a186db366b6375a">matrix_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad95a3b2ea4b00bae1007e468f31e5236">matrix_diagonal_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#af9f708f5debeea50a45efb78b3e1f66b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a2e3e94d4038bb010bb86023b613fa6ff">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a2e3e94d4038bb010bb86023b613fa6ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac9a523b23a6acfedb255d6bbabbe240f">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#ac9a523b23a6acfedb255d6bbabbe240f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afe7804f787bac3c655bbde0a4d7f2f95">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#afe7804f787bac3c655bbde0a4d7f2f95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa730ef19275e56a333ea4029aa4b44c2">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aa730ef19275e56a333ea4029aa4b44c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aca398a45efe3258f77a7d5cd552018f5">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aca398a45efe3258f77a7d5cd552018f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aeea972c660ef714340be2fe25c473914">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#aeea972c660ef714340be2fe25c473914"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a7a544192e04d3ceccf76ade70225ca82">as</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a54012ccc3543adf4387f22b86909b8b1">asbs</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a38a3666cff9e5b37b75076987b7326c9">asbs_s</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a008702a083918762ac8a51ca2f3c332b">swap</a> (S1 &amp;s1, S2 &amp;s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two scalars, data is copied.  <a href="#a008702a083918762ac8a51ca2f3c332b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acc0ac63dacb65197ab4db5aeb0e44df7">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#acc0ac63dacb65197ab4db5aeb0e44df7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae2f9a94f9f5c0e068d8126f850c7c9d9">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ae2f9a94f9f5c0e068d8126f850c7c9d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bda6585eb1f3a9c153537c737dd7dcd">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a3bda6585eb1f3a9c153537c737dd7dcd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad2b5d908f83ee5f0533895aed846eadf">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ad2b5d908f83ee5f0533895aed846eadf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a1e3eabcf4e6c9aa7c2c7a942df68d409">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a1e3eabcf4e6c9aa7c2c7a942df68d409"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa7395737ad4441e78b4391c00af3c663">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#aa7395737ad4441e78b4391c00af3c663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a92e9d5f3a337dcce673a27d12b5b8c7c">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a92e9d5f3a337dcce673a27d12b5b8c7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a38c2e71cc1920ec5803aee5d21f98995">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a38c2e71cc1920ec5803aee5d21f98995"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a9e71fb4577e6a51a6531e35bd50ea8cf">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a9e71fb4577e6a51a6531e35bd50ea8cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac823213902af7383f4fabd2f6a29ac91">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#ac823213902af7383f4fabd2f6a29ac91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afc2e1977cd2b6069ed9ba376bb792a98">prod_impl</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>.  <a href="#afc2e1977cd2b6069ed9ba376bb792a98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aea41f806a665d5b04951eb88110c729a">prod_impl</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>.  <a href="#aea41f806a665d5b04951eb88110c729a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae0510d18bfe6db3992174b8e0f736fec">_axpy</a> (const T *, T *, std::size_t, T)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adefdf7e9424d04364089ebe905f137d4">_dot</a> (std::size_t, const T *, const T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aebd8604669905bc84e0a76449dceb825">_dotc</a> (std::size_t, const T *, const T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a6efa773c8f905b74ff7d2ce5711a2d54">_swap</a> (std::size_t, T *, T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5330ce3310af35bf7e43e39b921ec488">_copy</a> (std::size_t, T *, T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acea939097ca92d5bd5b81817ec7f7cff">_nrm2</a> (const T *, std::size_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a428ff2757bcae82dc9ac5f3ca964f12a">inplace_tred2</a> (ScalarType **A, std::size_t n, std::size_t block_size=1, std::size_t num_threads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace reduction of a dense n x n row-major or column-major hermitian (or real symmetric) matrix to tridiagonal form using householder similarity transforms (preserving eigenvalues)  <a href="#a428ff2757bcae82dc9ac5f3ca964f12a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a30540919e6f95e0ddbd680b301ed1b71">lu_factorize_row_major</a> (ScalarType **A, std::size_t m, std::size_t n, std::size_t *piv=NULL, std::size_t block_size=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace lu factorization of an m x n dense row-major matrix with optional partial pivoting, returning true for an even number of pivots, false for an odd number of pivots. Factorization is successful if there are no nonzero values on the diagonal.  <a href="#a30540919e6f95e0ddbd680b301ed1b71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af622498faa237d0b91980a063b8c724a">inplace_qr_col_major</a> (ScalarType **A, std::size_t m, std::size_t n, std::size_t block_size=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace qr factorization of an m x n dense column-major matrix, returning the householder normalization coefficients.  <a href="#af622498faa237d0b91980a063b8c724a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a02d91b8dfa0f279e9bf56036907a88ed">inplace_qr_row_major</a> (ScalarType **A, std::size_t m, std::size_t n, std::size_t block_size=8, std::size_t num_threads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace qr factorization of an m x n dense row-major matrix, returning the householder normalization coefficients.  <a href="#a02d91b8dfa0f279e9bf56036907a88ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ab21ad6a8cd5d94e2dc686b17cf0c5ef1">av</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a685e5bc3c606e372099f1c7c3df21c94">avbv</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a975076957b01c923cdb1728ee65ae259">avbv_v</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad0a31e2d9245ac1f22d1ef4efd7ed2e6">vector_assign</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, const T &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to a vector (-range/-slice)  <a href="#ad0a31e2d9245ac1f22d1ef4efd7ed2e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac370a4948707c297fe7ffbc4cd532314">vector_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#ac370a4948707c297fe7ffbc4cd532314"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5f0c27d301285beeca3c262795ca99ef">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#a5f0c27d301285beeca3c262795ca99ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3cdd8dff31ffac7296a40450b49dbf80">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a3cdd8dff31ffac7296a40450b49dbf80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8edf47c18ba79b54e66c0d79f179beaf">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a8edf47c18ba79b54e66c0d79f179beaf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bb4cf7b8852122dc4772065f8539a59">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation.  <a href="#a3bb4cf7b8852122dc4772065f8539a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5c3b448e695efcfc4ac7d0a2d924d61a">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a5c3b448e695efcfc4ac7d0a2d924d61a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ade43319359c56542d6efff648dd2c1b8">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#ade43319359c56542d6efff648dd2c1b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a107fe04dd7a510612fc50ec0b3f4d7ef">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2, T alpha, T beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a107fe04dd7a510612fc50ec0b3f4d7ef"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae0510d18bfe6db3992174b8e0f736fec"></a><!-- doxytag: member="viennacl::linalg::host_based::_axpy" ref="ae0510d18bfe6db3992174b8e0f736fec" args="(const T *, T *, std::size_t, T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae0510d18bfe6db3992174b8e0f736fec">_axpy</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5330ce3310af35bf7e43e39b921ec488"></a><!-- doxytag: member="viennacl::linalg::host_based::_copy" ref="a5330ce3310af35bf7e43e39b921ec488" args="(std::size_t, T *, T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5330ce3310af35bf7e43e39b921ec488">_copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adefdf7e9424d04364089ebe905f137d4"></a><!-- doxytag: member="viennacl::linalg::host_based::_dot" ref="adefdf7e9424d04364089ebe905f137d4" args="(std::size_t, const T *, const T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adefdf7e9424d04364089ebe905f137d4">_dot</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aebd8604669905bc84e0a76449dceb825"></a><!-- doxytag: member="viennacl::linalg::host_based::_dotc" ref="aebd8604669905bc84e0a76449dceb825" args="(std::size_t, const T *, const T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aebd8604669905bc84e0a76449dceb825">_dotc</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acea939097ca92d5bd5b81817ec7f7cff"></a><!-- doxytag: member="viennacl::linalg::host_based::_nrm2" ref="acea939097ca92d5bd5b81817ec7f7cff" args="(const T *, std::size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acea939097ca92d5bd5b81817ec7f7cff">_nrm2</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6efa773c8f905b74ff7d2ce5711a2d54"></a><!-- doxytag: member="viennacl::linalg::host_based::_swap" ref="a6efa773c8f905b74ff7d2ce5711a2d54" args="(std::size_t, T *, T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a6efa773c8f905b74ff7d2ce5711a2d54">_swap</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5d411cb73e0e3e15cc8311ee09ff624"></a><!-- doxytag: member="viennacl::linalg::host_based::am" ref="ae5d411cb73e0e3e15cc8311ee09ff624" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae5d411cb73e0e3e15cc8311ee09ff624">viennacl::linalg::host_based::am</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac92a348043088864b013d9ffb40692f9"></a><!-- doxytag: member="viennacl::linalg::host_based::ambm" ref="ac92a348043088864b013d9ffb40692f9" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac92a348043088864b013d9ffb40692f9">viennacl::linalg::host_based::ambm</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adfbfc453162208627e54b020c6c8d223"></a><!-- doxytag: member="viennacl::linalg::host_based::ambm_m" ref="adfbfc453162208627e54b020c6c8d223" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adfbfc453162208627e54b020c6c8d223">viennacl::linalg::host_based::ambm_m</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a544192e04d3ceccf76ade70225ca82"></a><!-- doxytag: member="viennacl::linalg::host_based::as" ref="a7a544192e04d3ceccf76ade70225ca82" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a7a544192e04d3ceccf76ade70225ca82">viennacl::linalg::host_based::as</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54012ccc3543adf4387f22b86909b8b1"></a><!-- doxytag: member="viennacl::linalg::host_based::asbs" ref="a54012ccc3543adf4387f22b86909b8b1" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a54012ccc3543adf4387f22b86909b8b1">viennacl::linalg::host_based::asbs</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38a3666cff9e5b37b75076987b7326c9"></a><!-- doxytag: member="viennacl::linalg::host_based::asbs_s" ref="a38a3666cff9e5b37b75076987b7326c9" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a38a3666cff9e5b37b75076987b7326c9">viennacl::linalg::host_based::asbs_s</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab21ad6a8cd5d94e2dc686b17cf0c5ef1"></a><!-- doxytag: member="viennacl::linalg::host_based::av" ref="ab21ad6a8cd5d94e2dc686b17cf0c5ef1" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ab21ad6a8cd5d94e2dc686b17cf0c5ef1">viennacl::linalg::host_based::av</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a685e5bc3c606e372099f1c7c3df21c94"></a><!-- doxytag: member="viennacl::linalg::host_based::avbv" ref="a685e5bc3c606e372099f1c7c3df21c94" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a685e5bc3c606e372099f1c7c3df21c94">viennacl::linalg::host_based::avbv</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a975076957b01c923cdb1728ee65ae259"></a><!-- doxytag: member="viennacl::linalg::host_based::avbv_v" ref="a975076957b01c923cdb1728ee65ae259" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a975076957b01c923cdb1728ee65ae259">viennacl::linalg::host_based::avbv_v</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f0c27d301285beeca3c262795ca99ef"></a><!-- doxytag: member="viennacl::linalg::host_based::element_op" ref="a5f0c27d301285beeca3c262795ca99ef" args="(vector_base&lt; T &gt; &amp;vec1, vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5f0c27d301285beeca3c262795ca99ef">viennacl::linalg::host_based::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade43319359c56542d6efff648dd2c1b8"></a><!-- doxytag: member="viennacl::linalg::host_based::index_norm_inf" ref="ade43319359c56542d6efff648dd2c1b8" args="(vector_base&lt; T &gt; const &amp;vec1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ade43319359c56542d6efff648dd2c1b8">viennacl::linalg::host_based::index_norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar (unsigned int), since gpu scalars are floating point types. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cdd8dff31ffac7296a40450b49dbf80"></a><!-- doxytag: member="viennacl::linalg::host_based::inner_prod_impl" ref="a3cdd8dff31ffac7296a40450b49dbf80" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, S3 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3cdd8dff31ffac7296a40450b49dbf80">viennacl::linalg::host_based::inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af622498faa237d0b91980a063b8c724a"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_qr_col_major" ref="af622498faa237d0b91980a063b8c724a" args="(ScalarType **A, std::size_t m, std::size_t n, std::size_t block_size=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ScalarType&gt; <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af622498faa237d0b91980a063b8c724a">viennacl::linalg::host_based::inplace_qr_col_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace qr factorization of an m x n dense column-major matrix, returning the householder normalization coefficients. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense column-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02d91b8dfa0f279e9bf56036907a88ed"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_qr_row_major" ref="a02d91b8dfa0f279e9bf56036907a88ed" args="(ScalarType **A, std::size_t m, std::size_t n, std::size_t block_size=8, std::size_t num_threads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ScalarType&gt; <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a02d91b8dfa0f279e9bf56036907a88ed">viennacl::linalg::host_based::inplace_qr_row_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace qr factorization of an m x n dense row-major matrix, returning the householder normalization coefficients. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense row-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fff650777bb47541ee70c67a25faa00"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a8fff650777bb47541ee70c67a25faa00" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08c38699206e277bf5d709d0a7d652cd"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a08c38699206e277bf5d709d0a7d652cd" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The proxy for the transposed matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebc69ca6f6f56e707dfd734fa012d4cb"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="aebc69ca6f6f56e707dfd734fa012d4cb" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8983c22febdaed6bea82107c9ee703c1"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a8983c22febdaed6bea82107c9ee703c1" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2f9a94f9f5c0e068d8126f850c7c9d9"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ae2f9a94f9f5c0e068d8126f850c7c9d9" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bda6585eb1f3a9c153537c737dd7dcd"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a3bda6585eb1f3a9c153537c737dd7dcd" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2b5d908f83ee5f0533895aed846eadf"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ad2b5d908f83ee5f0533895aed846eadf" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e3eabcf4e6c9aa7c2c7a942df68d409"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a1e3eabcf4e6c9aa7c2c7a942df68d409" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035b582c7138a65609eda6bff21eae40"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a035b582c7138a65609eda6bff21eae40" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad49aa03302e698f44dbc49e81faf8c38"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ad49aa03302e698f44dbc49e81faf8c38" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7395737ad4441e78b4391c00af3c663"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="aa7395737ad4441e78b4391c00af3c663" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92e9d5f3a337dcce673a27d12b5b8c7c"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a92e9d5f3a337dcce673a27d12b5b8c7c" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38c2e71cc1920ec5803aee5d21f98995"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a38c2e71cc1920ec5803aee5d21f98995" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e71fb4577e6a51a6531e35bd50ea8cf"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a9e71fb4577e6a51a6531e35bd50ea8cf" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a428ff2757bcae82dc9ac5f3ca964f12a"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_tred2" ref="a428ff2757bcae82dc9ac5f3ca964f12a" args="(ScalarType **A, std::size_t n, std::size_t block_size=1, std::size_t num_threads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a428ff2757bcae82dc9ac5f3ca964f12a">viennacl::linalg::host_based::inplace_tred2</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace reduction of a dense n x n row-major or column-major hermitian (or real symmetric) matrix to tridiagonal form using householder similarity transforms (preserving eigenvalues) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense hermitian matrix to be tridiagonalized </td></tr>
    <tr><td class="paramname">n</td><td>The height and width of the hermitian matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
    <tr><td class="paramname">num_threads</td><td>The number of threads to be used with OpenMP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30540919e6f95e0ddbd680b301ed1b71"></a><!-- doxytag: member="viennacl::linalg::host_based::lu_factorize_row_major" ref="a30540919e6f95e0ddbd680b301ed1b71" args="(ScalarType **A, std::size_t m, std::size_t n, std::size_t *piv=NULL, std::size_t block_size=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a30540919e6f95e0ddbd680b301ed1b71">viennacl::linalg::host_based::lu_factorize_row_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>piv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace lu factorization of an m x n dense row-major matrix with optional partial pivoting, returning true for an even number of pivots, false for an odd number of pivots. Factorization is successful if there are no nonzero values on the diagonal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense row-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">piv</td><td>The optional pivot vector to store the pivot indices. If piv is NULL, no partial pivoting will be performed. </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2a289cf8e3d6dc17a186db366b6375a"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_assign" ref="ad2a289cf8e3d6dc17a186db366b6375a" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad2a289cf8e3d6dc17a186db366b6375a">viennacl::linalg::host_based::matrix_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad95a3b2ea4b00bae1007e468f31e5236"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_diagonal_assign" ref="ad95a3b2ea4b00bae1007e468f31e5236" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad95a3b2ea4b00bae1007e468f31e5236">viennacl::linalg::host_based::matrix_diagonal_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8edf47c18ba79b54e66c0d79f179beaf"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_1_impl" ref="a8edf47c18ba79b54e66c0d79f179beaf" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8edf47c18ba79b54e66c0d79f179beaf">viennacl::linalg::host_based::norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bb4cf7b8852122dc4772065f8539a59"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_2_impl" ref="a3bb4cf7b8852122dc4772065f8539a59" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bb4cf7b8852122dc4772065f8539a59">viennacl::linalg::host_based::norm_2_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - implementation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c3b448e695efcfc4ac7d0a2d924d61a"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_inf_impl" ref="a5c3b448e695efcfc4ac7d0a2d924d61a" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5c3b448e695efcfc4ac7d0a2d924d61a">viennacl::linalg::host_based::norm_inf_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a107fe04dd7a510612fc50ec0b3f4d7ef"></a><!-- doxytag: member="viennacl::linalg::host_based::plane_rotation" ref="a107fe04dd7a510612fc50ec0b3f4d7ef" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2, T alpha, T beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a107fe04dd7a510612fc50ec0b3f4d7ef">viennacl::linalg::host_based::plane_rotation</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">alpha</td><td>The first transformation coefficient </td></tr>
    <tr><td class="paramname">beta</td><td>The second transformation coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc0ac63dacb65197ab4db5aeb0e44df7"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="acc0ac63dacb65197ab4db5aeb0e44df7" args="(const viennacl::compressed_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9f708f5debeea50a45efb78b3e1f66b"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="af9f708f5debeea50a45efb78b3e1f66b" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e3e94d4038bb010bb86023b613fa6ff"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a2e3e94d4038bb010bb86023b613fa6ff" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_trans</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9a523b23a6acfedb255d6bbabbe240f"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="ac9a523b23a6acfedb255d6bbabbe240f" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

</div>
</div>
<a class="anchor" id="afe7804f787bac3c655bbde0a4d7f2f95"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="afe7804f787bac3c655bbde0a4d7f2f95" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

</div>
</div>
<a class="anchor" id="aa730ef19275e56a333ea4029aa4b44c2"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aa730ef19275e56a333ea4029aa4b44c2" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

</div>
</div>
<a class="anchor" id="aca398a45efe3258f77a7d5cd552018f5"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aca398a45efe3258f77a7d5cd552018f5" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

</div>
</div>
<a class="anchor" id="ac823213902af7383f4fabd2f6a29ac91"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="ac823213902af7383f4fabd2f6a29ac91" args="(const viennacl::coordinate_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc2e1977cd2b6069ed9ba376bb792a98"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="afc2e1977cd2b6069ed9ba376bb792a98" args="(const viennacl::ell_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea41f806a665d5b04951eb88110c729a"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aea41f806a665d5b04951eb88110c729a" args="(const viennacl::hyb_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeea972c660ef714340be2fe25c473914"></a><!-- doxytag: member="viennacl::linalg::host_based::scaled_rank_1_update" ref="aeea972c660ef714340be2fe25c473914" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t, bool reciprocal_alpha, bool flip_sign_alpha, const vector_base&lt; NumericT &gt; &amp;vec1, const vector_base&lt; NumericT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aeea972c660ef714340be2fe25c473914">viennacl::linalg::host_based::scaled_rank_1_update</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>The matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>The scaling factor (either a viennacl::scalar&lt;&gt;, float, or double) </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>Use 1/alpha instead of alpha </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>Use -alpha instead of alpha </td></tr>
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a008702a083918762ac8a51ca2f3c332b"></a><!-- doxytag: member="viennacl::linalg::host_based::swap" ref="a008702a083918762ac8a51ca2f3c332b" args="(S1 &amp;s1, S2 &amp;s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a008702a083918762ac8a51ca2f3c332b">viennacl::linalg::host_based::swap</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two scalars, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0a31e2d9245ac1f22d1ef4efd7ed2e6"></a><!-- doxytag: member="viennacl::linalg::host_based::vector_assign" ref="ad0a31e2d9245ac1f22d1ef4efd7ed2e6" args="(vector_base&lt; T &gt; &amp;vec1, const T &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad0a31e2d9245ac1f22d1ef4efd7ed2e6">viennacl::linalg::host_based::vector_assign</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a constant value to a vector (-range/-slice) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector to which the value should be assigned </td></tr>
    <tr><td class="paramname">alpha</td><td>The value to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac370a4948707c297fe7ffbc4cd532314"></a><!-- doxytag: member="viennacl::linalg::host_based::vector_swap" ref="ac370a4948707c297fe7ffbc4cd532314" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac370a4948707c297fe7ffbc4cd532314">viennacl::linalg::host_based::vector_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector (or -range, or -slice) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:56 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
