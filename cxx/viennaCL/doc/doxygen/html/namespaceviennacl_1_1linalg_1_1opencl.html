<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg::opencl Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">opencl</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg::opencl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Holds all routines providing OpenCL linear algebra operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for OpenCL-accelerated linear algebra operations. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems. Matlab notation: A \ B.  <a href="#a616f2526f5e89961ab739fa5b132f172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa24b3d6656b3d3dea2e386a6769dc4e9">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems with transposed right hand side.  <a href="#aa24b3d6656b3d3dea2e386a6769dc4e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad28cb8939f01aa0b5d2448e615adf405">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems that stem from transposed triangular systems.  <a href="#ad28cb8939f01aa0b5d2448e615adf405"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a2ab1298a0bdfd41ac19aec716baf2ca6">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense transposed triangular systems with transposed right hand side. Matlab notation: A' \ B'.  <a href="#a2ab1298a0bdfd41ac19aec716baf2ca6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adfd91ef486d6c8ebbe91fffd8763de10">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#af2399a986583f0284e562c63cfee3b7b">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#af2399a986583f0284e562c63cfee3b7b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a01b9127d6eb8f0f005fd5c15737dbbf9">am</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a52c22452b02bcbfa0fcebcc0ac1ead65">ambm</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9758f9436e7b3db888bc8be88beaa322">ambm_m</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8597e07365b404573f052ff2089073e4">matrix_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abad0214892ec7c665b37bdfaf3829bc0">matrix_diagonal_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#adcbfc4c4d10aa70e33bddf25ac1bd59c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a972c6ffd063ee24ec70d673ba401f47d">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a972c6ffd063ee24ec70d673ba401f47d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adf6bc839f4dbacf60f69e70ff55a5ab5">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#adf6bc839f4dbacf60f69e70ff55a5ab5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a554ee1a9856fb109afab7f5a5fa80e90">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a554ee1a9856fb109afab7f5a5fa80e90"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9d5857a76f559b9af33ffaa9a0d131a4">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a9d5857a76f559b9af33ffaa9a0d131a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae24f8d8a654308c7eee6b2c252d5aff5">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#ae24f8d8a654308c7eee6b2c252d5aff5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a2abc2571cef022a736510cd7facf93e3">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#a2abc2571cef022a736510cd7facf93e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a0af5c9e69afaeca83d5b7e26bb975be6">as</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abebc432d755b1dde06892f0ccc760e5a">asbs</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad423ab2f0d737473de6ae9d7635cfe9b">asbs_s</a> (S1 &amp;vec1, S2 const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aea6abefea5037346ccb3d7aea32587b7">swap</a> (S1 &amp;s1, S2 &amp;s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two scalars, data is copied.  <a href="#aea6abefea5037346ccb3d7aea32587b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a597760a07c0ddad55896753e742d7331">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a597760a07c0ddad55896753e742d7331"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a47974f44b71dcbe9638afbe49deb2a06">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a47974f44b71dcbe9638afbe49deb2a06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ab53b942e511f628b6e67fda0f7287ce9">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#ab53b942e511f628b6e67fda0f7287ce9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a546a4a6c4539204b6fe70484ef797456">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of an upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a546a4a6c4539204b6fe70484ef797456"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a12f79edca8490b7ea80119e72ad676b1">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of an upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a12f79edca8490b7ea80119e72ad676b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a5ae507412a743e3dfd3ec42c25ad44bb">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a5ae507412a743e3dfd3ec42c25ad44bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9b113f79dfeb84e639621e15e0bad003">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a9b113f79dfeb84e639621e15e0bad003"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8ad59f48491c9d41439f28679e404efe">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a8ad59f48491c9d41439f28679e404efe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9309494abdddd29630d0ecb423965f95">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a9309494abdddd29630d0ecb423965f95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae44279436c85bf7418c8cabfe93d749d">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#ae44279436c85bf7418c8cabfe93d749d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#acd615212d873d571e60769e8e5be9026">prod_impl</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a38b7579053076ed2eb22a1b6c2204dfa">prod_impl</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a00794ea443c4dee13fda2b965eebf87d">prod_impl</a> (const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a>.  <a href="#a00794ea443c4dee13fda2b965eebf87d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1e05d4bec3d0096832cb0c967dcdd91f">av</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abca074ee79f84a64ab002b034aa9fae4">avbv</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3bd2e72b9e6271a22ae870606758e903">avbv_v</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aff6626405fb9482cec2fb323e03d5ecc">vector_assign</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, const T &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to a vector (-range/-slice)  <a href="#aff6626405fb9482cec2fb323e03d5ecc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8d0663f2f9916ed1ec639bcd1d240a7d">vector_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#a8d0663f2f9916ed1ec639bcd1d240a7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ac0ef37c707eac2d74ae5babd9e9974f5">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#ac0ef37c707eac2d74ae5babd9e9974f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;partial_result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a1adcbf3b6d428fc941484c35ce7e083a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a21cf46147faedd5a95037598b93cf694">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a21cf46147faedd5a95037598b93cf694"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa3db821922ad772f03e524d7dabc022d">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#aa3db821922ad772f03e524d7dabc022d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8">norm_reduction_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;partial_result, cl_uint norm_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial work group results for vector norms.  <a href="#ad44f85d3504ba0dc38d734f14ec92de8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1ec36a29b89412455b3392fbca312a24">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a1ec36a29b89412455b3392fbca312a24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a61ed84aaf76cd26e36ef91598dc2f748">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on CPU.  <a href="#a61ed84aaf76cd26e36ef91598dc2f748"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a430b9424a974bdacda10b5a323976c0a">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation using OpenCL summation at second step.  <a href="#a430b9424a974bdacda10b5a323976c0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a500313611da0259aa03e288bac20eccb">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on CPU.  <a href="#a500313611da0259aa03e288bac20eccb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3448fa94672822135d5c8ca665543ad6">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a3448fa94672822135d5c8ca665543ad6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a4fad07ab525d7540817ecd9006a8bcc8">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a4fad07ab525d7540817ecd9006a8bcc8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae19ed387707bd0b8721dd7acb150b2d8">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#ae19ed387707bd0b8721dd7acb150b2d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7cf8faf72604a859321348b7fb549420">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2, T alpha, T beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a7cf8faf72604a859321348b7fb549420"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Holds all routines providing OpenCL linear algebra operations. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a01b9127d6eb8f0f005fd5c15737dbbf9"></a><!-- doxytag: member="viennacl::linalg::opencl::am" ref="a01b9127d6eb8f0f005fd5c15737dbbf9" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a01b9127d6eb8f0f005fd5c15737dbbf9">viennacl::linalg::opencl::am</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52c22452b02bcbfa0fcebcc0ac1ead65"></a><!-- doxytag: member="viennacl::linalg::opencl::ambm" ref="a52c22452b02bcbfa0fcebcc0ac1ead65" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a52c22452b02bcbfa0fcebcc0ac1ead65">viennacl::linalg::opencl::ambm</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9758f9436e7b3db888bc8be88beaa322"></a><!-- doxytag: member="viennacl::linalg::opencl::ambm_m" ref="a9758f9436e7b3db888bc8be88beaa322" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9758f9436e7b3db888bc8be88beaa322">viennacl::linalg::opencl::ambm_m</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0af5c9e69afaeca83d5b7e26bb975be6"></a><!-- doxytag: member="viennacl::linalg::opencl::as" ref="a0af5c9e69afaeca83d5b7e26bb975be6" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a0af5c9e69afaeca83d5b7e26bb975be6">viennacl::linalg::opencl::as</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abebc432d755b1dde06892f0ccc760e5a"></a><!-- doxytag: member="viennacl::linalg::opencl::asbs" ref="abebc432d755b1dde06892f0ccc760e5a" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abebc432d755b1dde06892f0ccc760e5a">viennacl::linalg::opencl::asbs</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad423ab2f0d737473de6ae9d7635cfe9b"></a><!-- doxytag: member="viennacl::linalg::opencl::asbs_s" ref="ad423ab2f0d737473de6ae9d7635cfe9b" args="(S1 &amp;vec1, S2 const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad423ab2f0d737473de6ae9d7635cfe9b">viennacl::linalg::opencl::asbs_s</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e05d4bec3d0096832cb0c967dcdd91f"></a><!-- doxytag: member="viennacl::linalg::opencl::av" ref="a1e05d4bec3d0096832cb0c967dcdd91f" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1e05d4bec3d0096832cb0c967dcdd91f">viennacl::linalg::opencl::av</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abca074ee79f84a64ab002b034aa9fae4"></a><!-- doxytag: member="viennacl::linalg::opencl::avbv" ref="abca074ee79f84a64ab002b034aa9fae4" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abca074ee79f84a64ab002b034aa9fae4">viennacl::linalg::opencl::avbv</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bd2e72b9e6271a22ae870606758e903"></a><!-- doxytag: member="viennacl::linalg::opencl::avbv_v" ref="a3bd2e72b9e6271a22ae870606758e903" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3bd2e72b9e6271a22ae870606758e903">viennacl::linalg::opencl::avbv_v</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac0ef37c707eac2d74ae5babd9e9974f5"></a><!-- doxytag: member="viennacl::linalg::opencl::element_op" ref="ac0ef37c707eac2d74ae5babd9e9974f5" args="(vector_base&lt; T &gt; &amp;vec1, vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ac0ef37c707eac2d74ae5babd9e9974f5">viennacl::linalg::opencl::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae19ed387707bd0b8721dd7acb150b2d8"></a><!-- doxytag: member="viennacl::linalg::opencl::index_norm_inf" ref="ae19ed387707bd0b8721dd7acb150b2d8" args="(vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae19ed387707bd0b8721dd7acb150b2d8">viennacl::linalg::opencl::index_norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar (unsigned int), since gpu scalars are floating point types. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3db821922ad772f03e524d7dabc022d"></a><!-- doxytag: member="viennacl::linalg::opencl::inner_prod_cpu" ref="aa3db821922ad772f03e524d7dabc022d" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa3db821922ad772f03e524d7dabc022d">viennacl::linalg::opencl::inner_prod_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1adcbf3b6d428fc941484c35ce7e083a"></a><!-- doxytag: member="viennacl::linalg::opencl::inner_prod_impl" ref="a1adcbf3b6d428fc941484c35ce7e083a" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, vector_base&lt; T &gt; &amp;partial_result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a">viennacl::linalg::opencl::inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the partial inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">partial_result</td><td>The results of each group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21cf46147faedd5a95037598b93cf694"></a><!-- doxytag: member="viennacl::linalg::opencl::inner_prod_impl" ref="a21cf46147faedd5a95037598b93cf694" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a">viennacl::linalg::opencl::inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a616f2526f5e89961ab739fa5b132f172"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a616f2526f5e89961ab739fa5b132f172" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems. Matlab notation: A \ B. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa24b3d6656b3d3dea2e386a6769dc4e9"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="aa24b3d6656b3d3dea2e386a6769dc4e9" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems with transposed right hand side. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47974f44b71dcbe9638afbe49deb2a06"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a47974f44b71dcbe9638afbe49deb2a06" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad28cb8939f01aa0b5d2448e615adf405"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="ad28cb8939f01aa0b5d2448e615adf405" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems that stem from transposed triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab53b942e511f628b6e67fda0f7287ce9"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="ab53b942e511f628b6e67fda0f7287ce9" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ab1298a0bdfd41ac19aec716baf2ca6"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a2ab1298a0bdfd41ac19aec716baf2ca6" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense transposed triangular systems with transposed right hand side. Matlab notation: A' \ B'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a546a4a6c4539204b6fe70484ef797456"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a546a4a6c4539204b6fe70484ef797456" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::unit_upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of an upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd91ef486d6c8ebbe91fffd8763de10"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="adfd91ef486d6c8ebbe91fffd8763de10" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12f79edca8490b7ea80119e72ad676b1"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a12f79edca8490b7ea80119e72ad676b1" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of an upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2399a986583f0284e562c63cfee3b7b"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="af2399a986583f0284e562c63cfee3b7b" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ae507412a743e3dfd3ec42c25ad44bb"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a5ae507412a743e3dfd3ec42c25ad44bb" args="(matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_L, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_L</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b113f79dfeb84e639621e15e0bad003"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a9b113f79dfeb84e639621e15e0bad003" args="(matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_L, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_L</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ad59f48491c9d41439f28679e404efe"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a8ad59f48491c9d41439f28679e404efe" args="(matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_U, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::unit_upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_U</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9309494abdddd29630d0ecb423965f95"></a><!-- doxytag: member="viennacl::linalg::opencl::inplace_solve" ref="a9309494abdddd29630d0ecb423965f95" args="(matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy_U, vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a616f2526f5e89961ab739fa5b132f172">viennacl::linalg::opencl::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_U</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8597e07365b404573f052ff2089073e4"></a><!-- doxytag: member="viennacl::linalg::opencl::matrix_assign" ref="a8597e07365b404573f052ff2089073e4" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8597e07365b404573f052ff2089073e4">viennacl::linalg::opencl::matrix_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abad0214892ec7c665b37bdfaf3829bc0"></a><!-- doxytag: member="viennacl::linalg::opencl::matrix_diagonal_assign" ref="abad0214892ec7c665b37bdfaf3829bc0" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#abad0214892ec7c665b37bdfaf3829bc0">viennacl::linalg::opencl::matrix_diagonal_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a61ed84aaf76cd26e36ef91598dc2f748"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_1_cpu" ref="a61ed84aaf76cd26e36ef91598dc2f748" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a61ed84aaf76cd26e36ef91598dc2f748">viennacl::linalg::opencl::norm_1_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ec36a29b89412455b3392fbca312a24"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_1_impl" ref="a1ec36a29b89412455b3392fbca312a24" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1ec36a29b89412455b3392fbca312a24">viennacl::linalg::opencl::norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a500313611da0259aa03e288bac20eccb"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_2_cpu" ref="a500313611da0259aa03e288bac20eccb" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a500313611da0259aa03e288bac20eccb">viennacl::linalg::opencl::norm_2_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a430b9424a974bdacda10b5a323976c0a"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_2_impl" ref="a430b9424a974bdacda10b5a323976c0a" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a430b9424a974bdacda10b5a323976c0a">viennacl::linalg::opencl::norm_2_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - implementation using OpenCL summation at second step. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fad07ab525d7540817ecd9006a8bcc8"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_inf_cpu" ref="a4fad07ab525d7540817ecd9006a8bcc8" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a4fad07ab525d7540817ecd9006a8bcc8">viennacl::linalg::opencl::norm_inf_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3448fa94672822135d5c8ca665543ad6"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_inf_impl" ref="a3448fa94672822135d5c8ca665543ad6" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3448fa94672822135d5c8ca665543ad6">viennacl::linalg::opencl::norm_inf_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad44f85d3504ba0dc38d734f14ec92de8"></a><!-- doxytag: member="viennacl::linalg::opencl::norm_reduction_impl" ref="ad44f85d3504ba0dc38d734f14ec92de8" args="(vector_base&lt; T &gt; const &amp;vec, vector_base&lt; T &gt; &amp;partial_result, cl_uint norm_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8">viennacl::linalg::opencl::norm_reduction_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint&#160;</td>
          <td class="paramname"><em>norm_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the partial work group results for vector norms. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">partial_result</td><td>The result scalar </td></tr>
    <tr><td class="paramname">norm_id</td><td>Norm selector. 0: norm_inf, 1: norm_1, 2: norm_2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cf8faf72604a859321348b7fb549420"></a><!-- doxytag: member="viennacl::linalg::opencl::plane_rotation" ref="a7cf8faf72604a859321348b7fb549420" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2, T alpha, T beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7cf8faf72604a859321348b7fb549420">viennacl::linalg::opencl::plane_rotation</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">alpha</td><td>The first transformation coefficient </td></tr>
    <tr><td class="paramname">beta</td><td>The second transformation coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00794ea443c4dee13fda2b965eebf87d"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a00794ea443c4dee13fda2b965eebf87d" args="(const viennacl::vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a597760a07c0ddad55896753e742d7331"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a597760a07c0ddad55896753e742d7331" args="(const viennacl::compressed_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; TYPE &gt; &amp;vec, viennacl::vector_base&lt; TYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcbfc4c4d10aa70e33bddf25ac1bd59c"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="adcbfc4c4d10aa70e33bddf25ac1bd59c" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a972c6ffd063ee24ec70d673ba401f47d"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a972c6ffd063ee24ec70d673ba401f47d" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_trans</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae44279436c85bf7418c8cabfe93d749d"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="ae44279436c85bf7418c8cabfe93d749d" args="(const viennacl::coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd615212d873d571e60769e8e5be9026"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="acd615212d873d571e60769e8e5be9026" args="(const viennacl::ell_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; TYPE &gt; &amp;vec, viennacl::vector_base&lt; TYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38b7579053076ed2eb22a1b6c2204dfa"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a38b7579053076ed2eb22a1b6c2204dfa" args="(const viennacl::hyb_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; TYPE &gt; &amp;vec, viennacl::vector_base&lt; TYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf6bc839f4dbacf60f69e70ff55a5ab5"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="adf6bc839f4dbacf60f69e70ff55a5ab5" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

</div>
</div>
<a class="anchor" id="a554ee1a9856fb109afab7f5a5fa80e90"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a554ee1a9856fb109afab7f5a5fa80e90" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

</div>
</div>
<a class="anchor" id="a9d5857a76f559b9af33ffaa9a0d131a4"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="a9d5857a76f559b9af33ffaa9a0d131a4" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

</div>
</div>
<a class="anchor" id="ae24f8d8a654308c7eee6b2c252d5aff5"></a><!-- doxytag: member="viennacl::linalg::opencl::prod_impl" ref="ae24f8d8a654308c7eee6b2c252d5aff5" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">viennacl::linalg::opencl::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

</div>
</div>
<a class="anchor" id="a2abc2571cef022a736510cd7facf93e3"></a><!-- doxytag: member="viennacl::linalg::opencl::scaled_rank_1_update" ref="a2abc2571cef022a736510cd7facf93e3" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, const vector_base&lt; NumericT &gt; &amp;vec1, const vector_base&lt; NumericT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a2abc2571cef022a736510cd7facf93e3">viennacl::linalg::opencl::scaled_rank_1_update</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>The matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>The scaling factor (either a viennacl::scalar&lt;&gt;, float, or double) </td></tr>
    <tr><td class="paramname">len_alpha</td><td>Length of the buffer for an eventual final reduction step (currently always '1') </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>Use 1/alpha instead of alpha </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>Use -alpha instead of alpha </td></tr>
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea6abefea5037346ccb3d7aea32587b7"></a><!-- doxytag: member="viennacl::linalg::opencl::swap" ref="aea6abefea5037346ccb3d7aea32587b7" args="(S1 &amp;s1, S2 &amp;s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aea6abefea5037346ccb3d7aea32587b7">viennacl::linalg::opencl::swap</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two scalars, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff6626405fb9482cec2fb323e03d5ecc"></a><!-- doxytag: member="viennacl::linalg::opencl::vector_assign" ref="aff6626405fb9482cec2fb323e03d5ecc" args="(vector_base&lt; T &gt; &amp;vec1, const T &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#aff6626405fb9482cec2fb323e03d5ecc">viennacl::linalg::opencl::vector_assign</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a constant value to a vector (-range/-slice) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector to which the value should be assigned </td></tr>
    <tr><td class="paramname">alpha</td><td>The value to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d0663f2f9916ed1ec639bcd1d240a7d"></a><!-- doxytag: member="viennacl::linalg::opencl::vector_swap" ref="a8d0663f2f9916ed1ec639bcd1d240a7d" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8d0663f2f9916ed1ec639bcd1d240a7d">viennacl::linalg::opencl::vector_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector (or -range, or -slice) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:56 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
