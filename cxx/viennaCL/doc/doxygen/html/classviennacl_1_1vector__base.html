<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: vector_base&lt; SCALARTYPE, SizeType, DistanceType &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vector_base&lt; SCALARTYPE, SizeType, DistanceType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="viennacl::vector_base" -->
<p>Common base class for dense vectors, vector ranges, and vector slices.  
 <a href="classviennacl_1_1vector__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html">viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT</a><br class="typebreak"/>
&lt; SCALARTYPE &gt;::ResultType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aed985c700866b1bae61cb8bcd5d322fe">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SCALARTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">backend::mem_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DistanceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a><br class="typebreak"/>
&lt; SCALARTYPE, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a><br class="typebreak"/>
&lt; SCALARTYPE, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5">vector_base</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor in order to be compatible with various containers.  <a href="#aa9dcc7c0c8bc7c616450c167c8a62ab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#af2a0b5272f0911e822835d939b5c09aa">vector_base</a> (<a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> &amp;h, <a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size, <a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_start, <a class="el" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> vec_stride)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An explicit constructor for wrapping an existing vector into a <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a> or <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>.  <a href="#af2a0b5272f0911e822835d939b5c09aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ac4cf80248dcf5e641aca0b3007c7deb7">vector_base</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector and allocates the necessary memory.  <a href="#ac4cf80248dcf5e641aca0b3007c7deb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#af7c353f70c3cee2b9fba12bf58d27118">vector_base</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size, <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> mem_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer of size 'vec_size' in the specified memory domain an uses this as the active domain.  <a href="#af7c353f70c3cee2b9fba12bf58d27118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130">operator=</a> (const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized.  <a href="#aa5c64abfb6feb1fe07365d9d0bf47130"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a8ddbade4c1fc2f09576e3e1a911b396a">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 @ alpha, where @ denotes either multiplication or division, and alpha is either a CPU or a GPU scalar.  <a href="#a8ddbade4c1fc2f09576e3e1a911b396a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a93c8163b27126bf6c57ecb85b49feabf">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 +- v3.  <a href="#a93c8163b27126bf6c57ecb85b49feabf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a27377e4c65395ce7c525c131d4c1f766">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a27377e4c65395ce7c525c131d4c1f766"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a1c342de5e734f41cbd12ddc916f7d61b">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a1c342de5e734f41cbd12ddc916f7d61b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a78ddfb4afeb752a38bda7fbee71a9c3e">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a78ddfb4afeb752a38bda7fbee71a9c3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a7dbdd7ea90aef1bb84605b3c86ccf3f7">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 = v2 * / v3.  <a href="#a7dbdd7ea90aef1bb84605b3c86ccf3f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ae4c78fdea9013f3617ac2e87c0697324">operator=</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a4dcdb6c15f3d51904a8693ff9895c067">operator=</a> (<a class="el" href="classviennacl_1_1unit__vector.html">unit_vector</a>&lt; SCALARTYPE &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector from the supplied unit vector.  <a href="#a4dcdb6c15f3d51904a8693ff9895c067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#adf893b2b113ffa442bdbf2cc700d3d96">operator=</a> (<a class="el" href="classviennacl_1_1zero__vector.html">zero_vector</a>&lt; SCALARTYPE &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector from the supplied zero vector.  <a href="#adf893b2b113ffa442bdbf2cc700d3d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a7d0d055bd01dd6fd360e05636443b8b9">operator=</a> (<a class="el" href="classviennacl_1_1scalar__vector.html">scalar_vector</a>&lt; SCALARTYPE &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector from the supplied scalar vector.  <a href="#a7d0d055bd01dd6fd360e05636443b8b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a7e384c7a2f30a89bb334f8df2bf2f2a9">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a7e384c7a2f30a89bb334f8df2bf2f2a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a8ea8b9ec85456e8340b12584ad645e2a">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for v1 = trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a8ea8b9ec85456e8340b12584ad645e2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt; SCALARTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ad39a7d06af546a8df947a8a36722eb03">operator()</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write access to a single element of the vector.  <a href="#ad39a7d06af546a8df947a8a36722eb03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt; SCALARTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#af8f3f9c5c359c354201a0e4386b4cfcc">operator[]</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write access to a single element of the vector.  <a href="#af8f3f9c5c359c354201a0e4386b4cfcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a>&lt; SCALARTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a0a081021edabde1ededaa17d2190d4c2">operator()</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to a single element of the vector.  <a href="#a0a081021edabde1ededaa17d2190d4c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a>&lt; SCALARTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#af5300af0b7779ed3ca0b1abaaacc5d64">operator[]</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to a single element of the vector.  <a href="#af5300af0b7779ed3ca0b1abaaacc5d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ae901a1ce2027fc044e8f7b9665826f5d">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#afede1545613592581a6fc4b813fac86d">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a131b09f05f2e3a9aceb0b376fb23b638">operator*=</a> (SCALARTYPE val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a vector (or proxy) by a CPU scalar value.  <a href="#a131b09f05f2e3a9aceb0b376fb23b638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ac0fce9b73d5213e8604dc604e71a608e">operator/=</a> (SCALARTYPE val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a CPU scalar value.  <a href="#ac0fce9b73d5213e8604dc604e71a608e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, <br class="typebreak"/>
op_prod &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a4b41a15beb1edf38c09d5bee8f75474b">operator*</a> (SCALARTYPE <a class="el" href="classviennacl_1_1value.html">value</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by a CPU scalar 'alpha' and returns an expression template.  <a href="#a4b41a15beb1edf38c09d5bee8f75474b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, <br class="typebreak"/>
op_prod &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a0604ab0124a1a15735f40b408a31ba04">operator/</a> (SCALARTYPE <a class="el" href="classviennacl_1_1value.html">value</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by a CPU scalar 'alpha' and returns an expression template.  <a href="#a0604ab0124a1a15735f40b408a31ba04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, <br class="typebreak"/>
op_prod &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a041289decd3a01e20701a355a7f9c177">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.  <a href="#a041289decd3a01e20701a355a7f9c177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the beginning of the vector (STL like)  <a href="#ad69bd11391be1a1dba5c8202259664f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the end of the vector (STL like)  <a href="#acad38d52497a975bfb6f2f6acd76631f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const-iterator pointing to the beginning of the vector (STL like)  <a href="#aa4b02d4f1a8500fb07a551069060709f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const-iterator pointing to the end of the vector (STL like)  <a href="#a350132543d80a1c1e5be844e6d2878ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aec44f1e87d499827231c9087be3bd99b">swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the entries of the two vectors.  <a href="#aec44f1e87d499827231c9087be3bd99b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the vector (cf. std::vector)  <a href="#a503ab01f6c0142145d3434f6924714e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c">internal_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal length of the vector, which is given by <a class="el" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size()</a> plus the extra memory due to padding the memory with zeros up to a multiple of 'ALIGNMENT'.  <a href="#aa50eb28af8d336f420b4de7b67ce738c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ae8a8f4bf838f0a8a0f1d5fc75f43be27">start</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within the buffer.  <a href="#ae8a8f4bf838f0a8a0f1d5fc75f43be27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa1ac19fa335be66e75aa873f4e29fc4c">stride</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride within the buffer (in multiples of sizeof(SCALARTYPE))  <a href="#aa1ac19fa335be66e75aa873f4e29fc4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ac6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true is the size is zero.  <a href="#ac6e61de369e994009e36f344f99c15ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938">handle</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory handle.  <a href="#a0830e530145e6372224c89153128e938"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory handle.  <a href="#aa1b198b314716d29e7aa65e6b6b71af9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all entries to zero. Does not change the size of the vector.  <a href="#ac8bb3912a3ce86b15842e79d0b421204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a4d7af104d914cb4ffd07463d5e19d721">memory_domain</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a03ed50af9196539f90b41d7bad4a3b22">alignment</a> = 1</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a06bd1620b92852143daab47c58918b30">set_handle</a> (<a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> const &amp;h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#a7d9d5c3cb020f5f2f5f160d624f387a0">fast_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.  <a href="#a7d9d5c3cb020f5f2f5f160d624f387a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e">pad</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible size.  <a href="#ae715ade8c14c274c4a1f416423380f1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ad2283ab2934e9bfcd2335d00cb56519a">switch_memory_domain</a> (<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> new_domain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">resize</a> (<a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> new_size, bool preserve=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the allocated memory for the vector. Pads the memory to be a multiple of 'ALIGNMENT'.  <a href="#ac3afd1fbe76f7fed3e2b36b1297fa42c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SCALARTYPE, typename SizeType, typename DistanceType&gt;<br/>
class viennacl::vector_base&lt; SCALARTYPE, SizeType, DistanceType &gt;</h3>

<p>Common base class for dense vectors, vector ranges, and vector slices. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCALARTYPE</td><td>The floating point type, either 'float' or 'double' </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a38e4539acc7af91c7c6ba4f803325478"></a><!-- doxytag: member="viennacl::vector_base::const_iterator" ref="a38e4539acc7af91c7c6ba4f803325478" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt;SCALARTYPE, 1&gt; <a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#a6d765100480b5a770ee53c8622f082cd">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a6d765100480b5a770ee53c8622f082cd">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afe14f79ef563aa2fc6b051029e0eb93b"></a><!-- doxytag: member="viennacl::vector_base::cpu_value_type" ref="afe14f79ef563aa2fc6b051029e0eb93b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SCALARTYPE <a class="el" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#a0f557108a40b02b4f5702112b95ce817">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a0f557108a40b02b4f5702112b95ce817">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3dfbb913139aab3a7932d35f1ad1422a"></a><!-- doxytag: member="viennacl::vector_base::difference_type" ref="a3dfbb913139aab3a7932d35f1ad1422a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DistanceType <a class="el" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#a88b7d72f89c7a92bd77b57038d738e58">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a61cf5b87281e5aa0e75df273fbdb556d">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a54da31d88e477d0e9f61b0715fdc8162"></a><!-- doxytag: member="viennacl::vector_base::handle_type" ref="a54da31d88e477d0e9f61b0715fdc8162" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">backend::mem_handle</a> <a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af259ae13e9ceb731eee5811dd73c743f"></a><!-- doxytag: member="viennacl::vector_base::iterator" ref="af259ae13e9ceb731eee5811dd73c743f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt;SCALARTYPE, 1&gt; <a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#aa846ab6a97b3df77255e600f36efd21a">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#aa846ab6a97b3df77255e600f36efd21a">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a233dcbba0ec084278552de99c8b0a231"></a><!-- doxytag: member="viennacl::vector_base::size_type" ref="a233dcbba0ec084278552de99c8b0a231" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SizeType <a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector.html#a6d6dadd7b4260bf281cc6277f382acac">vector&lt; SCALARTYPE, ALIGNMENT &gt;</a>, <a class="el" href="classviennacl_1_1vector.html#a6d6dadd7b4260bf281cc6277f382acac">vector&lt; ScalarType &gt;</a>, <a class="el" href="classviennacl_1_1vector__slice.html#a3575504375152dc3650702b2533a205a">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a4f6b067ada73ffc04a616496d0566f4c">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aed985c700866b1bae61cb8bcd5d322fe"></a><!-- doxytag: member="viennacl::vector_base::value_type" ref="aed985c700866b1bae61cb8bcd5d322fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;typename <a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html">viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT</a>&lt;SCALARTYPE&gt;::ResultType&gt; <a class="el" href="classviennacl_1_1vector__base.html#aed985c700866b1bae61cb8bcd5d322fe">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#a492a5cfcd346dc908ebf7cbc32e6dd5a">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a492a5cfcd346dc908ebf7cbc32e6dd5a">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa9dcc7c0c8bc7c616450c167c8a62ab5"></a><!-- doxytag: member="viennacl::vector_base::vector_base" ref="aa9dcc7c0c8bc7c616450c167c8a62ab5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor in order to be compatible with various containers. </p>

</div>
</div>
<a class="anchor" id="af2a0b5272f0911e822835d939b5c09aa"></a><!-- doxytag: member="viennacl::vector_base::vector_base" ref="af2a0b5272f0911e822835d939b5c09aa" args="(viennacl::backend::mem_handle &amp;h, size_type vec_size, size_type vec_start, difference_type vec_stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>vec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>vec_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a>&#160;</td>
          <td class="paramname"><em>vec_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An explicit constructor for wrapping an existing vector into a <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a> or <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The existing memory handle from a vector/vector_range/vector_slice </td></tr>
    <tr><td class="paramname">vec_size</td><td>The length (i.e. size) of the buffer </td></tr>
    <tr><td class="paramname">vec_start</td><td>The offset from the beginning of the buffer identified by 'h' </td></tr>
    <tr><td class="paramname">vec_stride</td><td>Increment between two elements in the original buffer (in multiples of SCALARTYPE) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4cf80248dcf5e641aca0b3007c7deb7"></a><!-- doxytag: member="viennacl::vector_base::vector_base" ref="ac4cf80248dcf5e641aca0b3007c7deb7" args="(size_type vec_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>vec_size</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a vector and allocates the necessary memory. </p>

</div>
</div>
<a class="anchor" id="af7c353f70c3cee2b9fba12bf58d27118"></a><!-- doxytag: member="viennacl::vector_base::vector_base" ref="af7c353f70c3cee2b9fba12bf58d27118" args="(size_type vec_size, viennacl::memory_types mem_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>vec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a>&#160;</td>
          <td class="paramname"><em>mem_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a buffer of size 'vec_size' in the specified memory domain an uses this as the active domain. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad69bd11391be1a1dba5c8202259664f8"></a><!-- doxytag: member="viennacl::vector_base::begin" ref="ad69bd11391be1a1dba5c8202259664f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a> <a class="el" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an iterator pointing to the beginning of the vector (STL like) </p>

</div>
</div>
<a class="anchor" id="aa4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="viennacl::vector_base::begin" ref="aa4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a> <a class="el" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const-iterator pointing to the beginning of the vector (STL like) </p>

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="viennacl::vector_base::clear" ref="ac8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets all entries to zero. Does not change the size of the vector. </p>

</div>
</div>
<a class="anchor" id="ac6e61de369e994009e36f344f99c15ad"></a><!-- doxytag: member="viennacl::vector_base::empty" ref="ac6e61de369e994009e36f344f99c15ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviennacl_1_1vector__base.html#ac6e61de369e994009e36f344f99c15ad">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true is the size is zero. </p>

</div>
</div>
<a class="anchor" id="acad38d52497a975bfb6f2f6acd76631f"></a><!-- doxytag: member="viennacl::vector_base::end" ref="acad38d52497a975bfb6f2f6acd76631f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a> <a class="el" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an iterator pointing to the end of the vector (STL like) </p>

</div>
</div>
<a class="anchor" id="a350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="viennacl::vector_base::end" ref="a350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a> <a class="el" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const-iterator pointing to the end of the vector (STL like) </p>

</div>
</div>
<a class="anchor" id="a7d9d5c3cb020f5f2f5f160d624f387a0"></a><!-- doxytag: member="viennacl::vector_base::fast_swap" ref="a7d9d5c3cb020f5f2f5f160d624f387a0" args="(self_type &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; <a class="el" href="classviennacl_1_1vector__base.html#a7d9d5c3cb020f5f2f5f160d624f387a0">fast_swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy. </p>

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector.html#a7d9d5c3cb020f5f2f5f160d624f387a0">vector&lt; ScalarType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0830e530145e6372224c89153128e938"></a><!-- doxytag: member="viennacl::vector_base::handle" ref="a0830e530145e6372224c89153128e938" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a>&amp; <a class="el" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the memory handle. </p>

</div>
</div>
<a class="anchor" id="aa1b198b314716d29e7aa65e6b6b71af9"></a><!-- doxytag: member="viennacl::vector_base::handle" ref="aa1b198b314716d29e7aa65e6b6b71af9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a>&amp; <a class="el" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the memory handle. </p>

</div>
</div>
<a class="anchor" id="aa50eb28af8d336f420b4de7b67ce738c"></a><!-- doxytag: member="viennacl::vector_base::internal_size" ref="aa50eb28af8d336f420b4de7b67ce738c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="el" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c">internal_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the internal length of the vector, which is given by <a class="el" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size()</a> plus the extra memory due to padding the memory with zeros up to a multiple of 'ALIGNMENT'. </p>

</div>
</div>
<a class="anchor" id="a4d7af104d914cb4ffd07463d5e19d721"></a><!-- doxytag: member="viennacl::vector_base::memory_domain" ref="a4d7af104d914cb4ffd07463d5e19d721" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> <a class="el" href="classviennacl_1_1vector__base.html#a4d7af104d914cb4ffd07463d5e19d721">memory_domain</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad39a7d06af546a8df947a8a36722eb03"></a><!-- doxytag: member="viennacl::vector_base::operator()" ref="ad39a7d06af546a8df947a8a36722eb03" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt;SCALARTYPE&gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read-write access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="a0a081021edabde1ededaa17d2190d4c2"></a><!-- doxytag: member="viennacl::vector_base::operator()" ref="a0a081021edabde1ededaa17d2190d4c2" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a>&lt;SCALARTYPE&gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="a4b41a15beb1edf38c09d5bee8f75474b"></a><!-- doxytag: member="viennacl::vector_base::operator*" ref="a4b41a15beb1edf38c09d5bee8f75474b" args="(SCALARTYPE value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, op_prod&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a CPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a131b09f05f2e3a9aceb0b376fb23b638"></a><!-- doxytag: member="viennacl::vector_base::operator*=" ref="a131b09f05f2e3a9aceb0b376fb23b638" args="(SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector (or proxy) by a CPU scalar value. </p>

</div>
</div>
<a class="anchor" id="ae901a1ce2027fc044e8f7b9665826f5d"></a><!-- doxytag: member="viennacl::vector_base::operator+=" ref="ae901a1ce2027fc044e8f7b9665826f5d" args="(const self_type &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a041289decd3a01e20701a355a7f9c177"></a><!-- doxytag: member="viennacl::vector_base::operator&#45;" ref="a041289decd3a01e20701a355a7f9c177" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, op_prod&gt; operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sign flip for the vector. Emulated to be equivalent to -1.0 * vector. </p>

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f">vector&lt; SCALARTYPE, ALIGNMENT &gt;</a>, and <a class="el" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f">vector&lt; ScalarType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afede1545613592581a6fc4b813fac86d"></a><!-- doxytag: member="viennacl::vector_base::operator&#45;=" ref="afede1545613592581a6fc4b813fac86d" args="(const self_type &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0604ab0124a1a15735f40b408a31ba04"></a><!-- doxytag: member="viennacl::vector_base::operator/" ref="a0604ab0124a1a15735f40b408a31ba04" args="(SCALARTYPE value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a>, const SCALARTYPE, op_prod&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a CPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="ac0fce9b73d5213e8604dc604e71a608e"></a><!-- doxytag: member="viennacl::vector_base::operator/=" ref="ac0fce9b73d5213e8604dc604e71a608e" args="(SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a CPU scalar value. </p>

</div>
</div>
<a class="anchor" id="aa5c64abfb6feb1fe07365d9d0bf47130"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="aa5c64abfb6feb1fe07365d9d0bf47130" args="(const self_type &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized. </p>

</div>
</div>
<a class="anchor" id="a8ddbade4c1fc2f09576e3e1a911b396a"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a8ddbade4c1fc2f09576e3e1a911b396a" args="(const vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp; &gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 @ alpha, where @ denotes either multiplication or division, and alpha is either a CPU or a GPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93c8163b27126bf6c57ecb85b49feabf"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a93c8163b27126bf6c57ecb85b49feabf" args="(const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 +- v3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27377e4c65395ce7c525c131d4c1f766"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a27377e4c65395ce7c525c131d4c1f766" args="(const vector_expression&lt; const vector_base&lt; T &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c342de5e734f41cbd12ddc916f7d61b"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a1c342de5e734f41cbd12ddc916f7d61b" args="(const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78ddfb4afeb752a38bda7fbee71a9c3e"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a78ddfb4afeb752a38bda7fbee71a9c3e" args="(const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dbdd7ea90aef1bb84605b3c86ccf3f7"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a7dbdd7ea90aef1bb84605b3c86ccf3f7" args="(const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&gt;::type operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 * / v3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4c78fdea9013f3617ac2e87c0697324"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="ae4c78fdea9013f3617ac2e87c0697324" args="(const vector_base&lt; T &gt; &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dcdb6c15f3d51904a8693ff9895c067"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a4dcdb6c15f3d51904a8693ff9895c067" args="(unit_vector&lt; SCALARTYPE &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1unit__vector.html">unit_vector</a>&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the vector from the supplied unit vector. </p>

</div>
</div>
<a class="anchor" id="adf893b2b113ffa442bdbf2cc700d3d96"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="adf893b2b113ffa442bdbf2cc700d3d96" args="(zero_vector&lt; SCALARTYPE &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1zero__vector.html">zero_vector</a>&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the vector from the supplied zero vector. </p>

</div>
</div>
<a class="anchor" id="a7d0d055bd01dd6fd360e05636443b8b9"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a7d0d055bd01dd6fd360e05636443b8b9" args="(scalar_vector&lt; SCALARTYPE &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar__vector.html">scalar_vector</a>&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the vector from the supplied scalar vector. </p>

</div>
</div>
<a class="anchor" id="a7e384c7a2f30a89bb334f8df2bf2f2a9"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a7e384c7a2f30a89bb334f8df2bf2f2a9" args="(const viennacl::vector_expression&lt; const matrix_base&lt; SCALARTYPE, F &gt;, const vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ea8b9ec85456e8340b12584ad645e2a"></a><!-- doxytag: member="viennacl::vector_base::operator=" ref="a8ea8b9ec85456e8340b12584ad645e2a" args="(const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; SCALARTYPE, F &gt;, const matrix_base&lt; SCALARTYPE, F &gt;, op_trans &gt;, const vector_base&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8f3f9c5c359c354201a0e4386b4cfcc"></a><!-- doxytag: member="viennacl::vector_base::operator[]" ref="af8f3f9c5c359c354201a0e4386b4cfcc" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt;SCALARTYPE&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read-write access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="af5300af0b7779ed3ca0b1abaaacc5d64"></a><!-- doxytag: member="viennacl::vector_base::operator[]" ref="af5300af0b7779ed3ca0b1abaaacc5d64" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a>&lt;SCALARTYPE&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="ae715ade8c14c274c4a1f416423380f1e"></a><!-- doxytag: member="viennacl::vector_base::pad" ref="ae715ade8c14c274c4a1f416423380f1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e">pad</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible size. </p>

</div>
</div>
<a class="anchor" id="ac3afd1fbe76f7fed3e2b36b1297fa42c"></a><!-- doxytag: member="viennacl::vector_base::resize" ref="ac3afd1fbe76f7fed3e2b36b1297fa42c" args="(size_type new_size, bool preserve=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviennacl_1_1vector__base.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">resize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the allocated memory for the vector. Pads the memory to be a multiple of 'ALIGNMENT'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>The new size of the vector </td></tr>
    <tr><td class="paramname">preserve</td><td>If true, old entries of the vector are preserved, otherwise eventually discarded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">vector&lt; SCALARTYPE, ALIGNMENT &gt;</a>, and <a class="el" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">vector&lt; ScalarType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a06bd1620b92852143daab47c58918b30"></a><!-- doxytag: member="viennacl::vector_base::set_handle" ref="a06bd1620b92852143daab47c58918b30" args="(viennacl::backend::mem_handle const &amp;h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviennacl_1_1vector__base.html#a06bd1620b92852143daab47c58918b30">set_handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a503ab01f6c0142145d3434f6924714e7"></a><!-- doxytag: member="viennacl::vector_base::size" ref="a503ab01f6c0142145d3434f6924714e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="el" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of the vector (cf. std::vector) </p>

</div>
</div>
<a class="anchor" id="ae8a8f4bf838f0a8a0f1d5fc75f43be27"></a><!-- doxytag: member="viennacl::vector_base::start" ref="ae8a8f4bf838f0a8a0f1d5fc75f43be27" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="el" href="classviennacl_1_1vector__base.html#ae8a8f4bf838f0a8a0f1d5fc75f43be27">start</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the offset within the buffer. </p>

</div>
</div>
<a class="anchor" id="aa1ac19fa335be66e75aa873f4e29fc4c"></a><!-- doxytag: member="viennacl::vector_base::stride" ref="aa1ac19fa335be66e75aa873f4e29fc4c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="el" href="classviennacl_1_1vector__base.html#aa1ac19fa335be66e75aa873f4e29fc4c">stride</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the stride within the buffer (in multiples of sizeof(SCALARTYPE)) </p>

</div>
</div>
<a class="anchor" id="aec44f1e87d499827231c9087be3bd99b"></a><!-- doxytag: member="viennacl::vector_base::swap" ref="aec44f1e87d499827231c9087be3bd99b" args="(self_type &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a>&amp; <a class="el" href="classviennacl_1_1vector__base.html#aec44f1e87d499827231c9087be3bd99b">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">self_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the entries of the two vectors. </p>

</div>
</div>
<a class="anchor" id="ad2283ab2934e9bfcd2335d00cb56519a"></a><!-- doxytag: member="viennacl::vector_base::switch_memory_domain" ref="ad2283ab2934e9bfcd2335d00cb56519a" args="(viennacl::memory_types new_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviennacl_1_1vector__base.html#ad2283ab2934e9bfcd2335d00cb56519a">switch_memory_domain</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a>&#160;</td>
          <td class="paramname"><em>new_domain</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector.html#ad2283ab2934e9bfcd2335d00cb56519a">vector&lt; SCALARTYPE, ALIGNMENT &gt;</a>, and <a class="el" href="classviennacl_1_1vector.html#ad2283ab2934e9bfcd2335d00cb56519a">vector&lt; ScalarType &gt;</a>.</p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a03ed50af9196539f90b41d7bad4a3b22"></a><!-- doxytag: member="viennacl::vector_base::alignment" ref="a03ed50af9196539f90b41d7bad4a3b22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="el" href="classviennacl_1_1vector__base.html#a03ed50af9196539f90b41d7bad4a3b22">alignment</a> = 1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennacl_1_1vector__slice.html#a7850dd2939e8bb3d97d803481d7daf15">vector_slice&lt; VectorType &gt;</a>, and <a class="el" href="classviennacl_1_1vector__range.html#a7850dd2939e8bb3d97d803481d7daf15">vector_range&lt; VectorType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>viennacl/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
