<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/linalg/host_based/direct_solve.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/linalg/host_based/direct_solve.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="host__based_2direct__solve_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_LINALG_HOST_BASED_DIRECT_SOLVE_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_LINALG_HOST_BASED_DIRECT_SOLVE_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2013, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment">               </span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="vector_8hpp.html" title="The vector type with operator-overloads and proxy classes is defined here. Linear algebra operations ...">viennacl/vector.hpp</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html" title="Implementation of the dense matrix class.">viennacl/matrix.hpp</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="host__based_2common_8hpp.html" title="Common routines for single-threaded or OpenMP-enabled execution on CPU.">viennacl/linalg/host_based/common.hpp</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keyword">namespace </span>viennacl
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <span class="keyword">namespace </span>linalg
<a name="l00033"></a>00033   {
<a name="l00034"></a>00034     <span class="keyword">namespace </span>host_based
<a name="l00035"></a>00035     {
<a name="l00036"></a>00036       
<a name="l00037"></a>00037       <span class="keyword">namespace </span>detail
<a name="l00038"></a>00038       {
<a name="l00039"></a>00039         <span class="comment">//</span>
<a name="l00040"></a>00040         <span class="comment">// Upper solve:</span>
<a name="l00041"></a>00041         <span class="comment">//</span>
<a name="l00042"></a>00042         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00043"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ae07452dab379b0abeac2cd9735d10328">00043</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ae07452dab379b0abeac2cd9735d10328">upper_inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <span class="keywordtype">bool</span> unit_diagonal)
<a name="l00044"></a>00044         {
<a name="l00045"></a>00045           <span class="keyword">typedef</span> <span class="keyword">typename</span> MatrixType2::value_type   value_type;
<a name="l00046"></a>00046           
<a name="l00047"></a>00047           <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; A_size; ++i)
<a name="l00048"></a>00048           {
<a name="l00049"></a>00049             std::size_t current_row = A_size - i - 1;
<a name="l00050"></a>00050             
<a name="l00051"></a>00051             <span class="keywordflow">for</span> (std::size_t j = current_row + 1; j &lt; A_size; ++j)
<a name="l00052"></a>00052             {
<a name="l00053"></a>00053               value_type A_element = A(current_row, j);
<a name="l00054"></a>00054               <span class="keywordflow">for</span> (std::size_t k=0; k &lt; B_size; ++k)
<a name="l00055"></a>00055                 B(current_row, k) -= A_element * B(j, k);
<a name="l00056"></a>00056             }
<a name="l00057"></a>00057             
<a name="l00058"></a>00058             <span class="keywordflow">if</span> (!unit_diagonal)
<a name="l00059"></a>00059             {
<a name="l00060"></a>00060               value_type A_diag = A(current_row, current_row);
<a name="l00061"></a>00061               <span class="keywordflow">for</span> (std::size_t k=0; k &lt; B_size; ++k)
<a name="l00062"></a>00062                 B(current_row, k) /= A_diag;
<a name="l00063"></a>00063             }
<a name="l00064"></a>00064           }
<a name="l00065"></a>00065         }
<a name="l00066"></a>00066           
<a name="l00067"></a>00067         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00068"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">00068</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <a class="code" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal.">viennacl::linalg::unit_upper_tag</a>)
<a name="l00069"></a>00069         {
<a name="l00070"></a>00070           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ae07452dab379b0abeac2cd9735d10328">upper_inplace_solve_matrix</a>(A, B, A_size, B_size, <span class="keyword">true</span>);
<a name="l00071"></a>00071         }
<a name="l00072"></a>00072           
<a name="l00073"></a>00073         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00074"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ae392a1c6e8b52823440773d92956edb3">00074</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <a class="code" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix.">viennacl::linalg::upper_tag</a>)
<a name="l00075"></a>00075         {
<a name="l00076"></a>00076           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ae07452dab379b0abeac2cd9735d10328">upper_inplace_solve_matrix</a>(A, B, A_size, B_size, <span class="keyword">false</span>);
<a name="l00077"></a>00077         }
<a name="l00078"></a>00078           
<a name="l00079"></a>00079         <span class="comment">//</span>
<a name="l00080"></a>00080         <span class="comment">// Lower solve:</span>
<a name="l00081"></a>00081         <span class="comment">//</span>
<a name="l00082"></a>00082         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00083"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a50d08888306ebe2a616573db179db70b">00083</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a50d08888306ebe2a616573db179db70b">lower_inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <span class="keywordtype">bool</span> unit_diagonal)
<a name="l00084"></a>00084         {
<a name="l00085"></a>00085           <span class="keyword">typedef</span> <span class="keyword">typename</span> MatrixType2::value_type   value_type;
<a name="l00086"></a>00086           
<a name="l00087"></a>00087           <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; A_size; ++i)
<a name="l00088"></a>00088           {
<a name="l00089"></a>00089             <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; i; ++j)
<a name="l00090"></a>00090             {
<a name="l00091"></a>00091               value_type A_element = A(i, j);
<a name="l00092"></a>00092               <span class="keywordflow">for</span> (std::size_t k=0; k &lt; B_size; ++k)
<a name="l00093"></a>00093                 B(i, k) -= A_element * B(j, k);
<a name="l00094"></a>00094             }
<a name="l00095"></a>00095             
<a name="l00096"></a>00096             <span class="keywordflow">if</span> (!unit_diagonal)
<a name="l00097"></a>00097             {
<a name="l00098"></a>00098               value_type A_diag = A(i, i);
<a name="l00099"></a>00099               <span class="keywordflow">for</span> (std::size_t k=0; k &lt; B_size; ++k)
<a name="l00100"></a>00100                 B(i, k) /= A_diag;
<a name="l00101"></a>00101             }
<a name="l00102"></a>00102           }
<a name="l00103"></a>00103         }
<a name="l00104"></a>00104           
<a name="l00105"></a>00105         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00106"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a9015d57a105837a7092df3522a1fe22a">00106</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <a class="code" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal.">viennacl::linalg::unit_lower_tag</a>)
<a name="l00107"></a>00107         {
<a name="l00108"></a>00108           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a50d08888306ebe2a616573db179db70b">lower_inplace_solve_matrix</a>(A, B, A_size, B_size, <span class="keyword">true</span>);
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110           
<a name="l00111"></a>00111         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType1, <span class="keyword">typename</span> MatrixType2&gt;
<a name="l00112"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a80332719f542ba4a149829caebf9947d">00112</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">inplace_solve_matrix</a>(MatrixType1 &amp; A, MatrixType2 &amp; B, std::size_t A_size, std::size_t B_size, <a class="code" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix.">viennacl::linalg::lower_tag</a>)
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a50d08888306ebe2a616573db179db70b">lower_inplace_solve_matrix</a>(A, B, A_size, B_size, <span class="keyword">false</span>);
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116           
<a name="l00117"></a>00117       }
<a name="l00118"></a>00118       
<a name="l00119"></a>00119       <span class="comment">//</span>
<a name="l00120"></a>00120       <span class="comment">// Note: By convention, all size checks are performed in the calling frontend. No need to double-check here.</span>
<a name="l00121"></a>00121       <span class="comment">//</span>
<a name="l00122"></a>00122       
<a name="l00124"></a>00124 
<a name="l00129"></a>00129       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00130"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">00130</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; A, <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a> &amp; B, SOLVERTAG)
<a name="l00131"></a>00131       {
<a name="l00132"></a>00132         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00133"></a>00133        
<a name="l00134"></a>00134         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(A);
<a name="l00135"></a>00135         value_type       * data_B = detail::extract_raw_pointer&lt;value_type&gt;(B);
<a name="l00136"></a>00136         
<a name="l00137"></a>00137         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A);
<a name="l00138"></a>00138         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A);
<a name="l00139"></a>00139         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A);
<a name="l00140"></a>00140         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A);
<a name="l00141"></a>00141         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A);
<a name="l00142"></a>00142         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A);
<a name="l00143"></a>00143         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A);
<a name="l00144"></a>00144         
<a name="l00145"></a>00145         std::size_t B_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(B);
<a name="l00146"></a>00146         std::size_t B_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(B);
<a name="l00147"></a>00147         std::size_t B_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(B);
<a name="l00148"></a>00148         std::size_t B_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(B);
<a name="l00149"></a>00149         std::size_t B_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B);
<a name="l00150"></a>00150         std::size_t B_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(B);
<a name="l00151"></a>00151         std::size_t B_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(B);
<a name="l00152"></a>00152         
<a name="l00153"></a>00153         
<a name="l00154"></a>00154         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F1::orientation_category, false&gt;</a>   wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00155"></a>00155         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type,       typename F2::orientation_category, false&gt;</a>   wrapper_B(data_B, B_start1, B_start2, B_inc1, B_inc2, B_internal_size1, B_internal_size2);
<a name="l00156"></a>00156         
<a name="l00157"></a>00157         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">detail::inplace_solve_matrix</a>(wrapper_A, wrapper_B, A_size2, B_size2, SOLVERTAG());
<a name="l00158"></a>00158       }
<a name="l00159"></a>00159       
<a name="l00165"></a>00165       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00166"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a08c38699206e277bf5d709d0a7d652cd">00166</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; A,
<a name="l00167"></a>00167                          <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, op_trans&gt; proxy_B,
<a name="l00168"></a>00168                          SOLVERTAG)
<a name="l00169"></a>00169       {
<a name="l00170"></a>00170         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00171"></a>00171        
<a name="l00172"></a>00172         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(A);
<a name="l00173"></a>00173         value_type       * data_B = <span class="keyword">const_cast&lt;</span>value_type *<span class="keyword">&gt;</span>(detail::extract_raw_pointer&lt;value_type&gt;(proxy_B.lhs()));
<a name="l00174"></a>00174         
<a name="l00175"></a>00175         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A);
<a name="l00176"></a>00176         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A);
<a name="l00177"></a>00177         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A);
<a name="l00178"></a>00178         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A);
<a name="l00179"></a>00179         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A);
<a name="l00180"></a>00180         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A);
<a name="l00181"></a>00181         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A);
<a name="l00182"></a>00182         
<a name="l00183"></a>00183         std::size_t B_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy_B.lhs());
<a name="l00184"></a>00184         std::size_t B_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy_B.lhs());
<a name="l00185"></a>00185         std::size_t B_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy_B.lhs());
<a name="l00186"></a>00186         std::size_t B_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy_B.lhs());
<a name="l00187"></a>00187         std::size_t B_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy_B.lhs());
<a name="l00188"></a>00188         std::size_t B_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy_B.lhs());
<a name="l00189"></a>00189         std::size_t B_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy_B.lhs());
<a name="l00190"></a>00190         
<a name="l00191"></a>00191         
<a name="l00192"></a>00192         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F1::orientation_category, false&gt;</a>   wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00193"></a>00193         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type,       typename F2::orientation_category, true&gt;</a>   wrapper_B(data_B, B_start1, B_start2, B_inc1, B_inc2, B_internal_size1, B_internal_size2);
<a name="l00194"></a>00194         
<a name="l00195"></a>00195         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">detail::inplace_solve_matrix</a>(wrapper_A, wrapper_B, A_size2, B_size1, SOLVERTAG());
<a name="l00196"></a>00196       }
<a name="l00197"></a>00197       
<a name="l00198"></a>00198       <span class="comment">//upper triangular solver for transposed lower triangular matrices</span>
<a name="l00204"></a>00204 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00205"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#aebc69ca6f6f56e707dfd734fa012d4cb">00205</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, op_trans&gt; &amp; proxy_A,
<a name="l00206"></a>00206                          <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a> &amp; B,
<a name="l00207"></a>00207                          SOLVERTAG)
<a name="l00208"></a>00208       {
<a name="l00209"></a>00209         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00210"></a>00210        
<a name="l00211"></a>00211         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(proxy_A.lhs());
<a name="l00212"></a>00212         value_type       * data_B = <span class="keyword">const_cast&lt;</span>value_type *<span class="keyword">&gt;</span>(detail::extract_raw_pointer&lt;value_type&gt;(B));
<a name="l00213"></a>00213         
<a name="l00214"></a>00214         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy_A.lhs());
<a name="l00215"></a>00215         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy_A.lhs());
<a name="l00216"></a>00216         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy_A.lhs());
<a name="l00217"></a>00217         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy_A.lhs());
<a name="l00218"></a>00218         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy_A.lhs());
<a name="l00219"></a>00219         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy_A.lhs());
<a name="l00220"></a>00220         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy_A.lhs());
<a name="l00221"></a>00221         
<a name="l00222"></a>00222         std::size_t B_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(B);
<a name="l00223"></a>00223         std::size_t B_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(B);
<a name="l00224"></a>00224         std::size_t B_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(B);
<a name="l00225"></a>00225         std::size_t B_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(B);
<a name="l00226"></a>00226         std::size_t B_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B);
<a name="l00227"></a>00227         std::size_t B_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(B);
<a name="l00228"></a>00228         std::size_t B_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(B);
<a name="l00229"></a>00229         
<a name="l00230"></a>00230         
<a name="l00231"></a>00231         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F1::orientation_category, true&gt;</a>    wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00232"></a>00232         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type,       typename F2::orientation_category, false&gt;</a>   wrapper_B(data_B, B_start1, B_start2, B_inc1, B_inc2, B_internal_size1, B_internal_size2);
<a name="l00233"></a>00233         
<a name="l00234"></a>00234         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">detail::inplace_solve_matrix</a>(wrapper_A, wrapper_B, A_size2, B_size2, SOLVERTAG());
<a name="l00235"></a>00235       }
<a name="l00236"></a>00236 
<a name="l00242"></a>00242       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00243"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8983c22febdaed6bea82107c9ee703c1">00243</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, op_trans&gt; &amp; proxy_A,
<a name="l00244"></a>00244                                <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, op_trans&gt;   proxy_B,
<a name="l00245"></a>00245                          SOLVERTAG)
<a name="l00246"></a>00246       {
<a name="l00247"></a>00247         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00248"></a>00248        
<a name="l00249"></a>00249         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(proxy_A.lhs());
<a name="l00250"></a>00250         value_type       * data_B = <span class="keyword">const_cast&lt;</span>value_type *<span class="keyword">&gt;</span>(detail::extract_raw_pointer&lt;value_type&gt;(proxy_B.lhs()));
<a name="l00251"></a>00251         
<a name="l00252"></a>00252         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy_A.lhs());
<a name="l00253"></a>00253         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy_A.lhs());
<a name="l00254"></a>00254         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy_A.lhs());
<a name="l00255"></a>00255         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy_A.lhs());
<a name="l00256"></a>00256         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy_A.lhs());
<a name="l00257"></a>00257         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy_A.lhs());
<a name="l00258"></a>00258         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy_A.lhs());
<a name="l00259"></a>00259         
<a name="l00260"></a>00260         std::size_t B_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy_B.lhs());
<a name="l00261"></a>00261         std::size_t B_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy_B.lhs());
<a name="l00262"></a>00262         std::size_t B_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy_B.lhs());
<a name="l00263"></a>00263         std::size_t B_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy_B.lhs());
<a name="l00264"></a>00264         std::size_t B_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy_B.lhs());
<a name="l00265"></a>00265         std::size_t B_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy_B.lhs());
<a name="l00266"></a>00266         std::size_t B_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy_B.lhs());
<a name="l00267"></a>00267         
<a name="l00268"></a>00268         
<a name="l00269"></a>00269         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F1::orientation_category, true&gt;</a>   wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00270"></a>00270         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type,       typename F2::orientation_category, true&gt;</a>   wrapper_B(data_B, B_start1, B_start2, B_inc1, B_inc2, B_internal_size1, B_internal_size2);
<a name="l00271"></a>00271         
<a name="l00272"></a>00272         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ab61ded187c7849cad623aa2a0a7b7f3e">detail::inplace_solve_matrix</a>(wrapper_A, wrapper_B, A_size2, B_size1, SOLVERTAG());
<a name="l00273"></a>00273       }
<a name="l00274"></a>00274       
<a name="l00275"></a>00275       <span class="comment">//</span>
<a name="l00276"></a>00276       <span class="comment">//  Solve on vector</span>
<a name="l00277"></a>00277       <span class="comment">//</span>
<a name="l00278"></a>00278       
<a name="l00279"></a>00279       <span class="keyword">namespace </span>detail
<a name="l00280"></a>00280       {
<a name="l00281"></a>00281         <span class="comment">//</span>
<a name="l00282"></a>00282         <span class="comment">// Upper solve:</span>
<a name="l00283"></a>00283         <span class="comment">//</span>
<a name="l00284"></a>00284         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00285"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ac7e700adb82a222a32e29bab98e9c281">00285</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ac7e700adb82a222a32e29bab98e9c281">upper_inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <span class="keywordtype">bool</span> unit_diagonal)
<a name="l00286"></a>00286         {
<a name="l00287"></a>00287           <span class="keyword">typedef</span> <span class="keyword">typename</span> VectorType::value_type   value_type;
<a name="l00288"></a>00288           
<a name="l00289"></a>00289           <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; A_size; ++i)
<a name="l00290"></a>00290           {
<a name="l00291"></a>00291             std::size_t current_row = A_size - i - 1;
<a name="l00292"></a>00292             
<a name="l00293"></a>00293             <span class="keywordflow">for</span> (std::size_t j = current_row + 1; j &lt; A_size; ++j)
<a name="l00294"></a>00294             {
<a name="l00295"></a>00295               value_type A_element = A(current_row, j);
<a name="l00296"></a>00296               b(current_row) -= A_element * b(j);
<a name="l00297"></a>00297             }
<a name="l00298"></a>00298             
<a name="l00299"></a>00299             <span class="keywordflow">if</span> (!unit_diagonal)
<a name="l00300"></a>00300               b(current_row) /= A(current_row, current_row);
<a name="l00301"></a>00301           }
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303           
<a name="l00304"></a>00304         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00305"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">00305</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <a class="code" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal.">viennacl::linalg::unit_upper_tag</a>)
<a name="l00306"></a>00306         {
<a name="l00307"></a>00307           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ac7e700adb82a222a32e29bab98e9c281">upper_inplace_solve_vector</a>(A, b, A_size, <span class="keyword">true</span>);
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309           
<a name="l00310"></a>00310         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00311"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a08fc6755a8a753637f07defad0a0a2c5">00311</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <a class="code" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix.">viennacl::linalg::upper_tag</a>)
<a name="l00312"></a>00312         {
<a name="l00313"></a>00313           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#ac7e700adb82a222a32e29bab98e9c281">upper_inplace_solve_vector</a>(A, b, A_size, <span class="keyword">false</span>);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315           
<a name="l00316"></a>00316         <span class="comment">//</span>
<a name="l00317"></a>00317         <span class="comment">// Lower solve:</span>
<a name="l00318"></a>00318         <span class="comment">//</span>
<a name="l00319"></a>00319         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00320"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#acdc3f84254aea22143124d40d11cb020">00320</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#acdc3f84254aea22143124d40d11cb020">lower_inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <span class="keywordtype">bool</span> unit_diagonal)
<a name="l00321"></a>00321         {
<a name="l00322"></a>00322           <span class="keyword">typedef</span> <span class="keyword">typename</span> VectorType::value_type   value_type;
<a name="l00323"></a>00323           
<a name="l00324"></a>00324           <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; A_size; ++i)
<a name="l00325"></a>00325           {
<a name="l00326"></a>00326             <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; i; ++j)
<a name="l00327"></a>00327             {
<a name="l00328"></a>00328               value_type A_element = A(i, j);
<a name="l00329"></a>00329               b(i) -= A_element * b(j);
<a name="l00330"></a>00330             }
<a name="l00331"></a>00331             
<a name="l00332"></a>00332             <span class="keywordflow">if</span> (!unit_diagonal)
<a name="l00333"></a>00333               b(i) /= A(i, i);
<a name="l00334"></a>00334           }
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336           
<a name="l00337"></a>00337         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00338"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a550b26f971919e1d11ac1f6b5c16d1bd">00338</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <a class="code" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal.">viennacl::linalg::unit_lower_tag</a>)
<a name="l00339"></a>00339         {
<a name="l00340"></a>00340           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#acdc3f84254aea22143124d40d11cb020">lower_inplace_solve_vector</a>(A, b, A_size, <span class="keyword">true</span>);
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342           
<a name="l00343"></a>00343         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00344"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a84a523c3d49923098663605d73afa5e6">00344</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">inplace_solve_vector</a>(MatrixType &amp; A, VectorType &amp; b, std::size_t A_size, <a class="code" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix.">viennacl::linalg::lower_tag</a>)
<a name="l00345"></a>00345         {
<a name="l00346"></a>00346           <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#acdc3f84254aea22143124d40d11cb020">lower_inplace_solve_vector</a>(A, b, A_size, <span class="keyword">false</span>);
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348           
<a name="l00349"></a>00349       }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00352"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a035b582c7138a65609eda6bff21eae40">00352</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat,
<a name="l00353"></a>00353                                <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec,
<a name="l00354"></a>00354                          SOLVERTAG)
<a name="l00355"></a>00355       {
<a name="l00356"></a>00356         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00357"></a>00357        
<a name="l00358"></a>00358         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(mat);
<a name="l00359"></a>00359         value_type       * data_v = detail::extract_raw_pointer&lt;value_type&gt;(vec);
<a name="l00360"></a>00360         
<a name="l00361"></a>00361         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat);
<a name="l00362"></a>00362         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat);
<a name="l00363"></a>00363         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat);
<a name="l00364"></a>00364         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat);
<a name="l00365"></a>00365         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat);
<a name="l00366"></a>00366         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat);
<a name="l00367"></a>00367         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat);
<a name="l00368"></a>00368         
<a name="l00369"></a>00369         std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">start1</a> = <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec);
<a name="l00370"></a>00370         std::size_t inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec);
<a name="l00371"></a>00371         
<a name="l00372"></a>00372         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F::orientation_category, false&gt;</a>   wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00373"></a>00373         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1vector__array__wrapper.html">detail::vector_array_wrapper&lt;value_type&gt;</a> wrapper_v(data_v, start1, inc1);
<a name="l00374"></a>00374         
<a name="l00375"></a>00375         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">detail::inplace_solve_vector</a>(wrapper_A, wrapper_v, A_size2, SOLVERTAG());
<a name="l00376"></a>00376       }
<a name="l00377"></a>00377       
<a name="l00378"></a>00378       
<a name="l00379"></a>00379 
<a name="l00385"></a>00385       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> SOLVERTAG&gt;
<a name="l00386"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad49aa03302e698f44dbc49e81faf8c38">00386</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, op_trans&gt; &amp; proxy,
<a name="l00387"></a>00387                          <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec,
<a name="l00388"></a>00388                          SOLVERTAG)
<a name="l00389"></a>00389       {
<a name="l00390"></a>00390         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00391"></a>00391        
<a name="l00392"></a>00392         value_type <span class="keyword">const</span> * data_A = detail::extract_raw_pointer&lt;value_type&gt;(proxy.lhs());
<a name="l00393"></a>00393         value_type       * data_v = detail::extract_raw_pointer&lt;value_type&gt;(vec);
<a name="l00394"></a>00394         
<a name="l00395"></a>00395         std::size_t A_start1 = <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy.lhs());
<a name="l00396"></a>00396         std::size_t A_start2 = <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy.lhs());
<a name="l00397"></a>00397         std::size_t A_inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy.lhs());
<a name="l00398"></a>00398         std::size_t A_inc2   = <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy.lhs());
<a name="l00399"></a>00399         std::size_t A_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(proxy.lhs());
<a name="l00400"></a>00400         std::size_t A_internal_size1  = <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy.lhs());
<a name="l00401"></a>00401         std::size_t A_internal_size2  = <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy.lhs());
<a name="l00402"></a>00402         
<a name="l00403"></a>00403         std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">start1</a> = <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec);
<a name="l00404"></a>00404         std::size_t inc1   = <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec);
<a name="l00405"></a>00405         
<a name="l00406"></a>00406         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1matrix__array__wrapper.html">detail::matrix_array_wrapper&lt;value_type const, typename F::orientation_category, true&gt;</a>   wrapper_A(data_A, A_start1, A_start2, A_inc1, A_inc2, A_internal_size1, A_internal_size2);
<a name="l00407"></a>00407         <a class="code" href="classviennacl_1_1linalg_1_1host__based_1_1detail_1_1vector__array__wrapper.html">detail::vector_array_wrapper&lt;value_type&gt;</a> wrapper_v(data_v, start1, inc1);
<a name="l00408"></a>00408         
<a name="l00409"></a>00409         <a class="code" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html#a435aea7e27851609ec19db42da340628">detail::inplace_solve_vector</a>(wrapper_A, wrapper_v, A_size2, SOLVERTAG());
<a name="l00410"></a>00410       }
<a name="l00411"></a>00411       
<a name="l00412"></a>00412       
<a name="l00413"></a>00413       
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:53 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
