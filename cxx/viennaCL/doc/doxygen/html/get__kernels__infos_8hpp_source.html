<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/generator/get_kernels_infos.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/generator/get_kernels_infos.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="get__kernels__infos_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_GENERATOR_CREATE_KERNEL_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_GENERATOR_CREATE_KERNEL_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2013, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00027"></a>00027 <span class="comment">// #include &quot;kernel_utils.hpp&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="operators_8hpp.html" title="Definition of the operators between the symbolic types. Experimental.">viennacl/generator/operators.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="symbolic__types_8hpp.html" title="Definition of the symbolic types. Experimental.">viennacl/generator/symbolic_types.hpp</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="tree__operations_8hpp.html" title="Functors for modifying the expression tree. Experimental.">viennacl/generator/tree_operations.hpp</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="tokens__management_8hpp.html" title="Creation and management of the tokens list. Experimental.">viennacl/generator/tokens_management.hpp</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="make__code_8hpp.html" title="Definition of code generation policies. Experimental.">viennacl/generator/make_code.hpp</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="typelist_8hpp.html" title="Generic implementation of a typelist. Experimental.">viennacl/generator/meta_tools/typelist.hpp</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="generator_2result__of_8hpp.html" title="Provides a set of metafunctions for type deductions within the kernel generator framework. Experimental.">viennacl/generator/result_of.hpp</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="shared__ptr_8hpp.html" title="Implementation of a shared pointer class (cf. std::shared_ptr, boost::shared_ptr). Will be used until C++11 is widely available.">viennacl/tools/shared_ptr.hpp</a>&quot;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">namespace </span>viennacl
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042 <span class="keyword">namespace </span>generator
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="namespaceviennacl_1_1generator.html#a9b2765b5394ac38f2ea1962c8f41a32d">00047</a> <span class="keyword">typedef</span> std::multimap&lt;std::string, std::pair&lt;unsigned int,viennacl::tools::shared_ptr&lt;result_of::runtime_wrapper&gt; &gt; &gt; <a class="code" href="namespaceviennacl_1_1generator.html#a9b2765b5394ac38f2ea1962c8f41a32d">runtime_wrappers_t</a>;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00050"></a><a class="code" href="structviennacl_1_1generator_1_1get__head.html">00050</a> <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1get__head.html">get_head</a>{
<a name="l00051"></a><a class="code" href="structviennacl_1_1generator_1_1get__head.html#a95edec1cdbfd0777887ffd0f5452a7cc">00051</a>     <span class="keyword">typedef</span> T <a class="code" href="structviennacl_1_1generator_1_1get__head.html#a95edec1cdbfd0777887ffd0f5452a7cc">Result</a>;
<a name="l00052"></a>00052 };
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Head, <span class="keyword">class</span> Tail&gt;
<a name="l00055"></a><a class="code" href="structviennacl_1_1generator_1_1get__head_3_01typelist_3_01_head_00_01_tail_01_4_01_4.html">00055</a> <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1get__head.html">get_head</a>&lt;<a class="code" href="structviennacl_1_1generator_1_1typelist.html">typelist</a>&lt;Head, Tail&gt; &gt;
<a name="l00056"></a>00056 {
<a name="l00057"></a><a class="code" href="structviennacl_1_1generator_1_1get__head_3_01typelist_3_01_head_00_01_tail_01_4_01_4.html#a81e2eb0aa25e173c994e936062141de8">00057</a>     <span class="keyword">typedef</span> Head <a class="code" href="structviennacl_1_1generator_1_1get__head_3_01typelist_3_01_head_00_01_tail_01_4_01_4.html#a81e2eb0aa25e173c994e936062141de8">Result</a>;
<a name="l00058"></a>00058 };
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00062"></a>00062 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00063"></a><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod.html">00063</a> <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod.html" title="Helper for register_kernels. Transform inner_product into phase 1 of inner_product implementation...">transform_inner_prod</a>
<a name="l00064"></a>00064 {
<a name="l00065"></a><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod.html#a95edec1cdbfd0777887ffd0f5452a7cc">00065</a>     <span class="keyword">typedef</span> T <a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod.html#a95edec1cdbfd0777887ffd0f5452a7cc">Result</a>;
<a name="l00066"></a>00066 };
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="keyword">template</span>&lt;<span class="keyword">class</span> LHS, <span class="keyword">class</span> RHS&gt;
<a name="l00069"></a><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod_3_01compound__node_3_01_l_h_s_00_01inner__8c543264d28169ec5c5c556d28a002e3.html">00069</a> <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod.html" title="Helper for register_kernels. Transform inner_product into phase 1 of inner_product implementation...">transform_inner_prod</a>&lt;<a class="code" href="classviennacl_1_1generator_1_1compound__node.html" title="Binary node class for storing expression trees.">compound_node</a>&lt;LHS,<a class="code" href="structviennacl_1_1generator_1_1inner__prod__type.html">inner_prod_type</a>,RHS&gt; &gt;
<a name="l00070"></a>00070 {
<a name="l00071"></a><a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod_3_01compound__node_3_01_l_h_s_00_01inner__8c543264d28169ec5c5c556d28a002e3.html#a8f20fd82275ae0ef6663a13d22f35dff">00071</a>     <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1generator_1_1inner__prod__impl__t.html">inner_prod_impl_t&lt;compound_node&lt;LHS,inner_prod_type,RHS&gt;</a> &gt; <a class="code" href="structviennacl_1_1generator_1_1transform__inner__prod_3_01compound__node_3_01_l_h_s_00_01inner__8c543264d28169ec5c5c556d28a002e3.html#a8f20fd82275ae0ef6663a13d22f35dff">Result</a>;
<a name="l00072"></a>00072 };
<a name="l00073"></a>00073 
<a name="l00080"></a>00080 <span class="keyword">template</span>&lt;<span class="keyword">class</span> TreeList, <span class="keyword">class</span> Res, <span class="keywordtype">int</span> CurrentIndex=0&gt;
<a name="l00081"></a>00081 <span class="keyword">struct </span>register_kernels;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Head,<span class="keyword">class</span> Tail, <span class="keyword">class</span> Res,<span class="keywordtype">int</span> CurrentIndex&gt;
<a name="l00084"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html">00084</a> <span class="keyword">struct </span>register_kernels&lt;<a class="code" href="structviennacl_1_1generator_1_1typelist.html">typelist</a>&lt;Head, Tail&gt;,Res,CurrentIndex &gt;
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086 <span class="keyword">private</span>:
<a name="l00087"></a>00087     <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1generator_1_1typelist.html">typelist&lt;Head, Tail&gt;</a> <a class="code" href="structviennacl_1_1generator_1_1typelist.html">self_type</a>;
<a name="l00088"></a>00088 <span class="keyword">public</span>:
<a name="l00089"></a>00089     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> List, <span class="keywordtype">int</span> Index&gt;
<a name="l00090"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html">00090</a>     <span class="keyword">struct </span>add_to_res
<a name="l00091"></a>00091     {
<a name="l00092"></a>00092         <span class="comment">//Gets the typelist at Index</span>
<a name="l00093"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a1661ac24e9fbe2c57ff7e2a41abeaca5">00093</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> typelist_utils::type_at&lt;List,Index&gt;::Result <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a1661ac24e9fbe2c57ff7e2a41abeaca5">Tmp</a>;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         <span class="comment">//Fuses it with the argument provided</span>
<a name="l00096"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a6428afa149c40ff89b896ca0d6a87d41">00096</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1typelist__utils_1_1fuse.html#a3c70298fec581589499e74259041ca98">typelist_utils::fuse&lt;Tmp,T&gt;::Result</a> <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a6428afa149c40ff89b896ca0d6a87d41">TmpRes</a>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         <span class="comment">//Replace the former typelist with the new typelist</span>
<a name="l00099"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a9da93698e5f7de4887f6ddd9ea8d106e">00099</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> typelist_utils::replace&lt;List,Tmp,TmpRes&gt;::Result <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a9da93698e5f7de4887f6ddd9ea8d106e">ResultIfTmpNotNull</a>;
<a name="l00100"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a06ee93a4fb69f82aca7f5fcdd5ddb018">00100</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> typelist_utils::append&lt;List,T&gt;::Result <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a06ee93a4fb69f82aca7f5fcdd5ddb018">ResultIfTmpNull</a>;
<a name="l00101"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a416c19426469eb5e97dedba57d52a912">00101</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1get__type__if.html">get_type_if&lt;ResultIfTmpNull,ResultIfTmpNotNull,result_of::is_null_type&lt;Tmp&gt;::value</a>&gt;<a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a416c19426469eb5e97dedba57d52a912">::Result</a> <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_re38afd7877281fe34368439275234973b.html#a416c19426469eb5e97dedba57d52a912">Result</a>;
<a name="l00102"></a>00102     };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">private</span>:
<a name="l00105"></a>00105     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1extract__if.html#af4e7d054dc316d953da2ef993ecc82f4">tree_utils::extract_if&lt;Head,result_of::is_inner_product_leaf&gt;::Result</a> InProds;
<a name="l00106"></a>00106     <span class="keyword">typedef</span> <span class="keyword">typename</span> add_to_res&lt;typename typelist_utils::ForEachType&lt;InProds,transform_inner_prod&gt;::Result,Res,CurrentIndex - 1&gt;<a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#aed633813841c681929fb94ffcbfc327d">::Result</a> TmpNewRes;
<a name="l00107"></a>00107     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> inc = <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;typename get_head&lt;Tail&gt;::Result</a>, <a class="code" href="structviennacl_1_1generator_1_1result__of_1_1or__is_1_1_pred.html">result_of::or_is&lt;result_of::is_product_leaf,result_of::is_inner_product_leaf&gt;::Pred</a> &gt;<a class="code" href="classviennacl_1_1value.html">::value</a>
<a name="l00108"></a>00108                             + <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;Head,result_of::is_product_leaf&gt;::value</a>;
<a name="l00109"></a>00109 <span class="keyword">public</span>:
<a name="l00110"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#ab182eb7b14652b659d8c7618f1d6c3fb">00110</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> add_to_res&lt;typelist&lt;Head,NullType&gt;,TmpNewRes,CurrentIndex&gt;<a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#aed633813841c681929fb94ffcbfc327d">::Result</a> <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#ab182eb7b14652b659d8c7618f1d6c3fb">NewRes</a>;
<a name="l00111"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#aed633813841c681929fb94ffcbfc327d">00111</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> register_kernels&lt;Tail,NewRes,CurrentIndex+inc&gt;::Result <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01typelist_3_01_head_00_01_tail_01_4_00_01_res_00_01_current_index_01_4.html#aed633813841c681929fb94ffcbfc327d">Result</a>;
<a name="l00112"></a>00112 };
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Res, <span class="keywordtype">int</span> CurrentIndex&gt;
<a name="l00115"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01_null_type_00_01_res_00_01_current_index_01_4.html">00115</a> <span class="keyword">struct </span>register_kernels&lt;<a class="code" href="structviennacl_1_1generator_1_1_null_type.html">NullType</a>,Res,CurrentIndex&gt;
<a name="l00116"></a>00116 {
<a name="l00117"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01_null_type_00_01_res_00_01_current_index_01_4.html#ae8df76c05a2c875303daddb04a1df5fd">00117</a>     <span class="keyword">typedef</span> Res <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01_null_type_00_01_res_00_01_current_index_01_4.html#ae8df76c05a2c875303daddb04a1df5fd">NewRes</a>;
<a name="l00118"></a><a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01_null_type_00_01_res_00_01_current_index_01_4.html#a9fcf0c0c6dc4ab0259791adf189cfbdc">00118</a>     <span class="keyword">typedef</span> Res <a class="code" href="structviennacl_1_1generator_1_1register__kernels_3_01_null_type_00_01_res_00_01_current_index_01_4.html#a9fcf0c0c6dc4ab0259791adf189cfbdc">Result</a>;
<a name="l00119"></a>00119 };
<a name="l00120"></a>00120 
<a name="l00125"></a>00125 <span class="keyword">template</span>&lt;<span class="keyword">class</span> ARG&gt;
<a name="l00126"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos.html">00126</a> <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos.html" title="functor to get the information necessary to create a program">program_infos</a>
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128 
<a name="l00129"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos.html#ae3e6275a6d15b6738beed8ebbc6900b9">00129</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos.html#ae3e6275a6d15b6738beed8ebbc6900b9">first_has_ip</a> = <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;typename ARG::Head,result_of::is_inner_product_leaf&gt;::value</a>;
<a name="l00130"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos.html#a6abc3ba76abdc21e5c1d7423334d2453">00130</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> register_kernels&lt;ARG,NullType,first_has_ip&gt;::Result          <a class="code" href="structviennacl_1_1generator_1_1program__infos.html#a6abc3ba76abdc21e5c1d7423334d2453">KernelsList</a>;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Operations&gt;
<a name="l00133"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args.html">00133</a>     <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args.html">fill_args</a>
<a name="l00134"></a>00134     {
<a name="l00135"></a>00135     <span class="keyword">private</span>:
<a name="l00136"></a>00136             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1extract__if.html" title="Extracts the types in the tree satisfying a certain predicate.">tree_utils::extract_if&lt;typename get_operations_from_expressions&lt;Operations&gt;::Unrolled</a>,<a class="code" href="structviennacl_1_1generator_1_1result__of_1_1is__kernel__argument.html">result_of::is_kernel_argument</a>&gt;::Result IntermediateType;
<a name="l00137"></a>00137             <span class="keyword">typedef</span> <span class="keyword">typename</span> typelist_utils::no_duplicates&lt;IntermediateType&gt;::Result Arguments;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="keyword">public</span>:
<a name="l00140"></a>00140         <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00141"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args_1_1functor.html">00141</a>         <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args_1_1functor.html">functor</a>{
<a name="l00142"></a>00142         <span class="keyword">private</span>:
<a name="l00143"></a>00143             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1_null_type.html">result_of::expression_type&lt;U&gt;::Result</a> <a class="code" href="structviennacl_1_1generator_1_1_null_type.html">ExpressionType</a>;
<a name="l00144"></a>00144         <span class="keyword">public</span>:
<a name="l00145"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args_1_1functor.html#a4fc4a1a7f48ddecad79e578c64a9c19d">00145</a>             <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args_1_1functor.html#a4fc4a1a7f48ddecad79e578c64a9c19d">execute</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; arg_pos, <a class="code" href="namespaceviennacl_1_1generator.html#a9b2765b5394ac38f2ea1962c8f41a32d">runtime_wrappers_t</a> &amp; runtime_wrappers, std::string <span class="keyword">const</span> &amp; name)
<a name="l00146"></a>00146             {
<a name="l00147"></a>00147                 runtime_wrappers.insert(runtime_wrappers_t::value_type(name,
<a name="l00148"></a>00148                                                                        std::make_pair(arg_pos,
<a name="l00149"></a>00149                                                                                       ExpressionType::runtime_descriptor())
<a name="l00150"></a>00150                                                                        )
<a name="l00151"></a>00151                                         );
<a name="l00152"></a>00152                 runtime_wrappers.size();
<a name="l00153"></a>00153                 arg_pos += ExpressionType::n_args();
<a name="l00154"></a>00154             }
<a name="l00155"></a>00155         };
<a name="l00156"></a>00156 
<a name="l00157"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args.html#af071afe71e59993dbe74839cfc44ebae">00157</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args.html#af071afe71e59993dbe74839cfc44ebae">execute</a>(<a class="code" href="namespaceviennacl_1_1generator.html#a9b2765b5394ac38f2ea1962c8f41a32d">runtime_wrappers_t</a> &amp; runtime_wrappers,std::string <span class="keyword">const</span> &amp; operation_name)
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> arg_pos = 0;
<a name="l00160"></a>00160             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = typelist_utils::index_of&lt;KernelsList,Operations&gt;::value;
<a name="l00161"></a>00161             std::string current_kernel_name(<span class="stringliteral">&quot;__&quot;</span> + operation_name + <span class="stringliteral">&quot;_k&quot;</span> + <a class="code" href="namespaceviennacl_1_1generator.html#ab8ded718e586b1f6e1a44fd1582624ea">to_string</a>(n));
<a name="l00162"></a>00162             <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__args.html#af071afe71e59993dbe74839cfc44ebae">typelist_utils::ForEach&lt;Arguments,functor&gt;::execute</a>(arg_pos,runtime_wrappers,current_kernel_name);
<a name="l00163"></a>00163             <span class="keywordflow">if</span>(<a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;Operations,result_of::is_inner_product_leaf&gt;::value</a> || <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;Operations,result_of::is_product_leaf&gt;::value</a>){
<a name="l00164"></a>00164                 runtime_wrappers.insert(runtime_wrappers_t::value_type(current_kernel_name,
<a name="l00165"></a>00165                                                                        std::make_pair(arg_pos,
<a name="l00166"></a>00166                                                                                       <span class="keyword">new</span> <a class="code" href="classviennacl_1_1generator_1_1result__of_1_1shared__memory__wrapper.html">result_of::shared_memory_wrapper</a>())));
<a name="l00167"></a>00167             }
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     };
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Operations&gt;
<a name="l00174"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources.html">00174</a>     <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources.html">fill_sources</a>
<a name="l00175"></a>00175     {
<a name="l00176"></a>00176     <span class="keyword">private</span>:
<a name="l00177"></a>00177             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1extract__if.html" title="Extracts the types in the tree satisfying a certain predicate.">tree_utils::extract_if&lt;typename get_operations_from_expressions&lt;Operations&gt;::Unrolled</a>,<a class="code" href="structviennacl_1_1generator_1_1result__of_1_1is__kernel__argument.html">result_of::is_kernel_argument</a>&gt;::Result IntermediateType;
<a name="l00178"></a>00178             <span class="keyword">typedef</span> <span class="keyword">typename</span> typelist_utils::no_duplicates&lt;IntermediateType&gt;::Result Arguments;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="keyword">public</span>:
<a name="l00181"></a>00181         <span class="keyword">template</span>&lt;<span class="keyword">class</span> TList&gt;
<a name="l00182"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code.html">00182</a>         <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code.html">header_code</a>
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184 
<a name="l00185"></a>00185             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00186"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code_1_1functor.html">00186</a>             <span class="keyword">struct </span><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code_1_1functor.html">functor</a>{
<a name="l00187"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code_1_1functor.html#aa1b52f67022d5ce3c5dc23b02068cbd1">00187</a>                 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code_1_1functor.html#aa1b52f67022d5ce3c5dc23b02068cbd1">execute</a>(std::string &amp; res,<span class="keywordtype">bool</span> &amp; is_first){
<a name="l00188"></a>00188                     <span class="keywordflow">if</span>(is_first){
<a name="l00189"></a>00189                         res+=T::kernel_arguments();
<a name="l00190"></a>00190                         is_first=<span class="keyword">false</span>;
<a name="l00191"></a>00191                     }
<a name="l00192"></a>00192                     <span class="keywordflow">else</span>{
<a name="l00193"></a>00193                         res+=<span class="stringliteral">&quot;, &quot;</span>+T::kernel_arguments();
<a name="l00194"></a>00194                     }
<a name="l00195"></a>00195                 }
<a name="l00196"></a>00196             };
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="keyword">public</span>:
<a name="l00199"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code.html#a33ff64afae7ff803f824357275d1413a">00199</a>             <span class="keyword">static</span> <span class="keyword">const</span> std::string <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code.html#a33ff64afae7ff803f824357275d1413a">value</a> ( std::string <span class="keyword">const</span> &amp; name )
<a name="l00200"></a>00200             {
<a name="l00201"></a>00201                 std::string res;
<a name="l00202"></a>00202                 res+=<span class="stringliteral">&quot;__kernel void &quot;</span> + name + <span class="stringliteral">&quot;(\n&quot;</span>;
<a name="l00203"></a>00203                 <span class="keywordtype">bool</span> state=<span class="keyword">true</span>;
<a name="l00204"></a>00204                 <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources.html#a53182e644a9896ae44d793b768b90ea0">typelist_utils::ForEach&lt;Arguments,functor&gt;::execute</a>(res,state);
<a name="l00205"></a>00205                 <span class="keywordflow">if</span>(<a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;TList,result_of::is_inner_product_leaf&gt;::value</a> || <a class="code" href="structviennacl_1_1generator_1_1tree__utils_1_1count__if.html" title="Functor for counting the number of elements satisfying a Pred.">tree_utils::count_if&lt;Operations,result_of::is_product_leaf&gt;::value</a>)
<a name="l00206"></a>00206                     res+=<span class="stringliteral">&quot;,__local float* shared_memory_ptr\n&quot;</span>;
<a name="l00207"></a>00207                 res+=<span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00208"></a>00208                 <span class="keywordflow">return</span> res;
<a name="l00209"></a>00209             }
<a name="l00210"></a>00210         };
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources.html#a53182e644a9896ae44d793b768b90ea0">00213</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources.html#a53182e644a9896ae44d793b768b90ea0">execute</a>(std::map&lt;std::string,std::string&gt; &amp; sources,std::string <span class="keyword">const</span> &amp; operation_name)
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = typelist_utils::index_of&lt;KernelsList,Operations&gt;::value;
<a name="l00216"></a>00216             std::string current_kernel_name(<span class="stringliteral">&quot;__&quot;</span> + operation_name + <span class="stringliteral">&quot;_k&quot;</span> + <a class="code" href="namespaceviennacl_1_1generator.html#ab8ded718e586b1f6e1a44fd1582624ea">to_string</a>(n));
<a name="l00217"></a>00217             sources.insert(std::make_pair(current_kernel_name,
<a name="l00218"></a>00218                                           <a class="code" href="structviennacl_1_1generator_1_1program__infos_1_1fill__sources_1_1header__code.html">header_code&lt;Operations&gt;::value</a>(current_kernel_name)
<a name="l00219"></a>00219                                           +<a class="code" href="structviennacl_1_1generator_1_1body__code.html" title="Functor to generates the body code of a kernel from a typelist of expressions.">body_code&lt;Operations&gt;::value</a>()));
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221     };
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 
<a name="l00227"></a><a class="code" href="structviennacl_1_1generator_1_1program__infos.html#aadb7204bd16d199f529f0d65a755e267">00227</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structviennacl_1_1generator_1_1program__infos.html#aadb7204bd16d199f529f0d65a755e267" title="Generates the source using the name operation_name. Fills the sources map and the runtime_wrappers ma...">fill</a>(std::string <span class="keyword">const</span> &amp; operation_name, std::map&lt;std::string,std::string&gt; &amp; sources, <a class="code" href="namespaceviennacl_1_1generator.html#a9b2765b5394ac38f2ea1962c8f41a32d">runtime_wrappers_t</a> &amp; runtime_wrappers)
<a name="l00228"></a>00228     {
<a name="l00229"></a>00229         <span class="comment">//std::cout &lt;&lt; KernelsList::name() &lt;&lt; std::endl;</span>
<a name="l00230"></a>00230         typelist_utils::ForEach&lt;KernelsList,fill_sources&gt;::execute(sources,operation_name);
<a name="l00231"></a>00231         typelist_utils::ForEach&lt;KernelsList,fill_args&gt;::execute(runtime_wrappers,operation_name);
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233 };
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 } <span class="comment">// namespace generator</span>
<a name="l00238"></a>00238 } <span class="comment">// namespace viennacl</span>
<a name="l00239"></a>00239 <span class="preprocessor">#endif</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:52 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
