<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides all linear algebra operations which are not covered by operator overloads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda.html">cuda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all CUDA compute kernels used by ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding implementation details for linear algebra routines. Usually not of interest for a library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">host_based</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">kernels</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing the OpenCL kernels. Deprecated, will be moved to <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html" title="Holds all routines providing OpenCL linear algebra operations.">viennacl::linalg::opencl</a> in future releases. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">opencl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all routines providing OpenCL linear algebra operations. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__precond.html">amg_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">AMG preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1amg__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">amg_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">AMG preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1amg__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the stabilized Bi-conjugate gradient solver. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1bicgstab__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1cg__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1block__ilu__precond.html">block_ilu_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A block ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1block__ilu__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1block__ilu__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a13eb668a78413bda5acd40ae0a399595.html">block_ilu_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, ILUTag &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1block__ilu__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a13eb668a78413bda5acd40ae0a399595.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__tag.html">ilu0_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete LU factorization with static pattern (ILU0)  <a href="classviennacl_1_1linalg_1_1ilu0__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__precond.html">ilu0_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilu0__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">ilu0_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilu0__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete LU factorization with threshold (ILUT)  <a href="classviennacl_1_1linalg_1_1ilut__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond.html">ilut_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">ilut_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the solver GMRES. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1gmres__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html">ichol0_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete Cholesky factorization with static pattern (ILU0)  <a href="classviennacl_1_1linalg_1_1ichol0__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__precond.html">ichol0_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Incomplete Cholesky preconditioner class with static pattern (ICHOL0), can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ichol0__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">ichol0_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ichol0__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__tag.html">jacobi_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for a jacobi preconditioner.  <a href="classviennacl_1_1linalg_1_1jacobi__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond.html">jacobi_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines. Generic version for non-ViennaCL matrices.  <a href="classviennacl_1_1linalg_1_1jacobi__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond_3_01_matrix_type_00_01true_01_4.html">jacobi_precond&lt; MatrixType, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1jacobi__precond_3_01_matrix_type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html">lanczos_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the lanczos algorithm.  <a href="classviennacl_1_1linalg_1_1lanczos__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1nmf__config.html">nmf_config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1power__iter__tag.html">power_iter_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the power iteration algorithm.  <a href="classviennacl_1_1linalg_1_1power__iter__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling__tag.html">row_scaling_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for a row preconditioner.  <a href="classviennacl_1_1linalg_1_1row__scaling__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling.html">row_scaling</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi-type preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines. This is a diagonal preconditioner with the diagonal entries being (configurable) row norms of the matrix.  <a href="classviennacl_1_1linalg_1_1row__scaling.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling_3_01_matrix_type_00_01true_01_4.html">row_scaling&lt; MatrixType, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1row__scaling_3_01_matrix_type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1spai__precond.html">spai_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the SParse Approximate Inverse Algorithm.  <a href="classviennacl_1_1linalg_1_1spai__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1spai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00_85d4c7cd827146fed2347215919b14e6.html">spai_precond&lt; viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1fspai__precond.html">fspai_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Factored SParse Approximate Inverse Algorithm.  <a href="classviennacl_1_1linalg_1_1fspai__precond.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1fspai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00e2257d431089a1252a9a2c07955b0dee.html">fspai_precond&lt; viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html">detail::amg::amg_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">viennacl::linalg::detail::spai::spai_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7c0e3dee6941202d84ebbf88fa3f77ba">spai_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">viennacl::linalg::detail::spai::fspai_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94fe4b190b9f52b4f5f0fd6ebca44cff">fspai_tag</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">convolve_i</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">element_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, op_div &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">element_div</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - dispatcher interface.  <a href="#ab7cbb9fc8635e8ceb18dd181c0aa2324"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a84c0f006e2e4f840e0bebfd9a9fed0e8">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5006ea75a0379d56e1dd8dbf6d817a41">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64080f662904aa976e0767a4693211ea">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface.  <a href="#abce7fb4d0ee0a5f82313eff5b07d03cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab92256482cf6a71434a0501847dd70fe">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abd75024e6302d26cd8f26559e9b6a31c">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9c68566e658fd80448dabb02bfbf018c">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - dispatcher interface.  <a href="#a546e0f416d08c99d21344dda5398859c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2487c579ee752a9fcc31c12d0bddf604">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acddd2a99867a55480dde2b4dba0a588c">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU.  <a href="#acddd2a99867a55480dde2b4dba0a588c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1d55e0e715a14ef4b336c06018c38db7">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a1d55e0e715a14ef4b336c06018c38db7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abeaca00d5581387446ab0948dde72f44">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - dispatcher interface.  <a href="#abeaca00d5581387446ab0948dde72f44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9d1a04d42e467eb9e0cd4b3a17cfc317">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a9d1a04d42e467eb9e0cd4b3a17cfc317"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a063fa23bfd77e19e93046d256027f438">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface.  <a href="#a063fa23bfd77e19e93046d256027f438"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a609941700fc79f0978daf50acaa93656">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a609941700fc79f0978daf50acaa93656"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5f7158a5f1fb8b67e2e6849b202a86a9">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a5f7158a5f1fb8b67e2e6849b202a86a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac8921e7938a67173daaf6c9a0e40e3e0">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#ac8921e7938a67173daaf6c9a0e40e3e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57092218bb316cdd6e7a9e8a758f3e99">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector with final reduction on the CPU.  <a href="#a57092218bb316cdd6e7a9e8a758f3e99"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad0fb517b1788ab9c44ee93021c32ba3f">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad0fb517b1788ab9c44ee93021c32ba3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7d991b4fc1435b34ddf9940911009e82">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a7d991b4fc1435b34ddf9940911009e82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a43e399b80730abedb939a3d08e326a8f">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a43e399b80730abedb939a3d08e326a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#aaa45f913d8815ef5ca24d70443d31bd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a49db0fe7daf624d43003ec4a08f3a8a3">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a49db0fe7daf624d43003ec4a08f3a8a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
SparseMatrixType, const <a class="el" href="classviennacl_1_1vector.html">vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae7a946e478e53f6464d1dedeb3a46c89">prod_impl</a> (const SparseMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InternalType1 , typename InternalType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8e11ae0a1b97997ccc1dd2622841b108">amg_setup</a> (InternalType1 &amp;A, InternalType1 &amp;P, InternalType2 &amp;Pointvector, <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup AMG preconditioner.  <a href="#a8e11ae0a1b97997ccc1dd2622841b108"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename InternalType1 , typename InternalType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae9b5668dc901d2bd9868440b02a21c44">amg_init</a> (MatrixType const &amp;mat, InternalType1 &amp;A, InternalType1 &amp;P, InternalType2 &amp;Pointvector, <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize AMG preconditioner.  <a href="#ae9b5668dc901d2bd9868440b02a21c44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InternalType1 , typename InternalType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8b46ab307a64df8fcf45c19fcbffb1d7">amg_transform_cpu</a> (InternalType1 &amp;A, InternalType1 &amp;P, InternalType1 &amp;R, InternalType2 &amp;A_setup, InternalType2 &amp;P_setup, <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save operators after setup phase for CPU computation.  <a href="#a8b46ab307a64df8fcf45c19fcbffb1d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InternalType1 , typename InternalType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af1db0aa9042114f6c4258cbe6376eb50">amg_transform_gpu</a> (InternalType1 &amp;A, InternalType1 &amp;P, InternalType1 &amp;R, InternalType2 &amp;A_setup, InternalType2 &amp;P_setup, <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save operators after setup phase for GPU computation.  <a href="#af1db0aa9042114f6c4258cbe6376eb50"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InternalVectorType , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a047d012a7c5ae638614447a2d52895cb">amg_setup_apply</a> (InternalVectorType &amp;result, InternalVectorType &amp;rhs, InternalVectorType &amp;residual, SparseMatrixType const &amp;A, <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup data structures for precondition phase.  <a href="#a047d012a7c5ae638614447a2d52895cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aadf9be8a31e606c2fb2a2a46d1031011">amg_lu</a> (boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;op, boost::numeric::ublas::permutation_matrix&lt;&gt; &amp;Permutation, SparseMatrixType const &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-compute LU factorization for direct solve (ublas library).  <a href="#aadf9be8a31e606c2fb2a2a46d1031011"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the stabilized Bi-conjugate gradient solver.  <a href="#a814104601016f71207386c80bdda8093"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a71032b6a3aee256117e1c51e2dbea0f9">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa00ad2441a0fa5060717d2203aaa194a">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the preconditioned stabilized Bi-conjugate gradient solver.  <a href="#aa00ad2441a0fa5060717d2203aaa194a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename VectorT::value_type &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a54d70c731aed90556e228b7f14ac3a52">bisect</a> (VectorT const &amp;alphas, VectorT const &amp;betas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the bisect-algorithm for the calculation of the eigenvalues of a tridiagonal matrix. Experimental - interface might change.  <a href="#a54d70c731aed90556e228b7f14ac3a52"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae4e9abff733ebe1feda607b4ccea8fc1">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the conjugate gradient solver without preconditioner.  <a href="#ae4e9abff733ebe1feda607b4ccea8fc1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab371cd27fe8c8ed7870ea5cdbd0662af">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9c3315abaffb516302e24193e488012a">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the preconditioned conjugate gradient solver.  <a href="#a9c3315abaffb516302e24193e488012a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aab70efb53fa182b4f1bbd9f33e177875">prod_impl</a> (const <a class="el" href="classviennacl_1_1circulant__matrix.html">viennacl::circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a>.  <a href="#aab70efb53fa182b4f1bbd9f33e177875"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2f7e122a5571e19d861deec3910eb953">precondition</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1ilu0__tag.html">ilu0_tag</a> const &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices.  <a href="#a2f7e122a5571e19d861deec3910eb953"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename SizeType , typename SparseVector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a32eec41e03cdd02c40689912b38afdc9">setup_w</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; const &amp;A, SizeType row, SparseVector &amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatcher overload for extracting the row of nonzeros of a compressed matrix.  <a href="#a32eec41e03cdd02c40689912b38afdc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename SizeType , typename SparseVector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0deaaae3d6b0d1014d4dffd11345dc4c">setup_w</a> (std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; const &amp;A, SizeType row, SparseVector &amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatcher overload for extracting the row of nonzeros of a STL-grown sparse matrix.  <a href="#a0deaaae3d6b0d1014d4dffd11345dc4c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename ScalarType , typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab21b0d140ee1815089d449b50379011f">precondition</a> (SparseMatrixType const &amp;A, std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; &amp;output, <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with threshold. Optimized implementation for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#ab21b0d140ee1815089d449b50379011f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems. Matlab notation: A \ B.  <a href="#aa75503af5629061a7cb9aad57ddb93e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa364ee657c06e95073ad3e4d896c4c74">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems with transposed right hand side.  <a href="#aa364ee657c06e95073ad3e4d896c4c74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a964cf6862e1143703815fb3ae144ee81">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense triangular systems that stem from transposed triangular systems.  <a href="#a964cf6862e1143703815fb3ae144ee81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1c3ea032c153aa3431aac14b606f033a">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense transposed triangular systems with transposed right hand side. Matlab notation: A' \ B'.  <a href="#a1c3ea032c153aa3431aac14b606f033a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acecd8a34364ee447a70ac9238814a306">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76b7629e309062ce6c44badda302aa24">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#a76b7629e309062ce6c44badda302aa24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a38ccd566bd220d22edd83efaa9f46d37">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#a38ccd566bd220d22edd83efaa9f46d37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a87193b0851afc957fc9f404d4e37f4c2">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;proxy, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#a87193b0851afc957fc9f404d4e37f4c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab0843082eba52dcefb6eca38eae65d88">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#ab0843082eba52dcefb6eca38eae65d88"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6c81e49ec0a097373d91a1d4ff6b60ef">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#a6c81e49ec0a097373d91a1d4ff6b60ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3241685b395fe49991dd94d6249d5274">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;proxy_B, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#a3241685b395fe49991dd94d6249d5274"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afb467467a7ac39b7e339e15d59d89e91">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a>  <a href="#afb467467a7ac39b7e339e15d59d89e91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7bbb1edc792ea86d1733f53ba7982592">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the GMRES solver.  <a href="#a7bbb1edc792ea86d1733f53ba7982592"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab591ff273997061d053e458b5c0914da">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used.  <a href="#ab591ff273997061d053e458b5c0914da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac6c0068bc315bae6be4333cc419c5e0e">prod_impl</a> (const <a class="el" href="classviennacl_1_1hankel__matrix.html">viennacl::hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a>.  <a href="#ac6c0068bc315bae6be4333cc419c5e0e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae15e75e9c94551d2c133359056d4e630">precondition</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html">ichol0_tag</a> const &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices.  <a href="#ae15e75e9c94551d2c133359056d4e630"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT1 , typename VectorT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a><br class="typebreak"/>
&lt; VectorT1 &gt;::type &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
typename VectorT1::value_type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">inner_prod</a> (VectorT1 const &amp;v1, VectorT2 const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad273e72f4a44fcd9802e3609d06af5e6">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;vector2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS, RHS, OP &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae4c12bee75a1dff46f0bd4b48abca2a5">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;vector2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS, RHS, OP &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac71bae6daf6dc8a5803071f79565582a">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vector2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS1, RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aac998ca060d47ba7c4b8bc1a994060ac">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vector2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7afda6c5b14466eaec9b3bd9db81d988">eig</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html">lanczos_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of eigenvalues using lanczos.  <a href="#a7afda6c5b14466eaec9b3bd9db81d988"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad65e1a218cb0f80511efe283492abc44">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a> &gt; &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LU factorization of a row-major dense matrix.  <a href="#ad65e1a218cb0f80511efe283492abc44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a445605d4c8e66a0b4e332e6992d4653c">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">viennacl::column_major</a> &gt; &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LU factorization of a column-major dense matrix.  <a href="#a445605d4c8e66a0b4e332e6992d4653c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a71bf0e8b5778b85239f046125cf610a3">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a71bf0e8b5778b85239f046125cf610a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a293d663addc176b5166524fe9257b7af">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a293d663addc176b5166524fe9257b7af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6f0db810dab59f2ecded1a5c8d8b0473">am</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abe7161810c732e58a047eac3ec15134a">ambm</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">ambm_m</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6ebd54b74107b1b98cf6f4bf11fd94f9">matrix_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab481481940dea4d443101db27bd87a00">matrix_diagonal_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a450121172f0d929f05ba8ff954a5e354">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a450121172f0d929f05ba8ff954a5e354"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64f211bc046e1dab1294e4097c6809a3">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a64f211bc046e1dab1294e4097c6809a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a441fec1b34b206f8e3825329c48791c2">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a441fec1b34b206f8e3825329c48791c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a54d0ead72872b835f3286d6e7348ca86">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a54d0ead72872b835f3286d6e7348ca86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a80b166d4b1b136b020820db3d7572b0d">outer_prod</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a80b166d4b1b136b020820db3d7572b0d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afaab5366d1d8890a5a8962a567fe7cb6">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#afaab5366d1d8890a5a8962a567fe7cb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a727542f4624926e74ff52ea5c75d546f">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the conjugate gradient solver without preconditioner.  <a href="#a727542f4624926e74ff52ea5c75d546f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab5579a603f93ad9fb66d8ebc358d7d5a">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aadee9fd42885065f6fa0048aa2b08d83">nmf</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; const &amp;V, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; &amp;W, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; &amp;H, <a class="el" href="classviennacl_1_1linalg_1_1nmf__config.html">nmf_config</a> const &amp;conf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The nonnegative matrix factorization (approximation) algorithm as suggested by Lee and Seung. Factorizes a matrix V with nonnegative entries into matrices W and H such that ||V - W*H|| is minimized.  <a href="#aadee9fd42885065f6fa0048aa2b08d83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">norm_1</a> (std::vector&lt; T, A &gt; const &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a464b2a90b50a88b535e98993e7994f31">norm_1</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#add18254bbe03030fb9a20c768e8c18f2">norm_1</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a07ce598e7f63cb1e9c75b2e2f3fbbc02">norm_1</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, viennacl::op_norm_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab5b81d05ed5510a3142a5f29e8b2525f">norm_1</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">norm_2</a> (std::vector&lt; T, A &gt; const &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a74e6f3ef1937f77eb6fa570d96c9d314">norm_2</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afb8b3d2c69031b74f97778dbc0419ffe">norm_2</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa783ab48afd63333ef3ea74ca41ab183">norm_2</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2a22bc2566ec601883db764cf08950c9">norm_2</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">norm_inf</a> (std::vector&lt; T, A &gt; const &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_inf &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a69f9505ad981bc47344c74c12aebc226">norm_inf</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_inf &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab1a0fb8fb93e786221984ef6242d0735">norm_inf</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a><br class="typebreak"/>
&lt; VectorType &gt;<br class="typebreak"/>
, viennacl::op_norm_inf &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afb1f4a590bb4b9e14a20e3946e365fd9">norm_inf</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, viennacl::op_norm_inf &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af6ac490ffc6af2faebcc33724bba120e">norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad8878598e5b2eac306142bab233d3530">eig</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1linalg_1_1power__iter__tag.html">power_iter_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of eigenvalues using poweriteration.  <a href="#ad8878598e5b2eac306142bab233d3530"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">prod</a> (std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename KEY , typename DATA , typename COMPARE , typename AMAP , typename AVEC , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4a8191b8e2833645bf9a50cf0385bf84">prod</a> (std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adb4b03c4436d0d255bdad9530f47aa36">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; const &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;, op_trans &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afc824308fb9e41411923061681552b88">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, op_trans &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab0e97631c585f85028bfd45023c6b0ff">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; const &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F1 &gt;, op_trans &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F2 &gt;, op_trans &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6d8cb3ba8e42665222c63a05598b1347">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; NumericT &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76d12d40e1910232c03aa9d988693abb">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; NumericT &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt;, op_trans &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; NumericT &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a10dd9cc2820e73305edc1a271ff64ca1">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; NumericT &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
SparseMatrixType, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a68fb776340b6102fdd9c166bd160191f">prod</a> (const SparseMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename StructuredMatrixType , class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">viennacl::is_any_dense_structured_matrix</a><br class="typebreak"/>
&lt; StructuredMatrixType &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const StructuredMatrixType, <br class="typebreak"/>
const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a895bfcd9f3517d830a9d1434d26ba151">prod</a> (const StructuredMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afedffd37d393726191b88e2dd3928370">qr_method_nsm</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;Q, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;D, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;E)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af118563c8639a90bebf15b2df477f0a4">qr_method_sym</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;Q, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;D)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76fc8bf8f5a20c576b7ddbad32d3e56d">recoverQ</a> (MatrixType const &amp;A, VectorType const &amp;betas, MatrixType &amp;Q, MatrixType &amp;R)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType1 , typename VectorType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adf77bb0fe92ef09522d0458ee9df03db">inplace_qr_apply_trans_Q</a> (MatrixType const &amp;A, VectorType1 const &amp;betas, VectorType2 &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Q^T b, where Q is an implicit orthogonal matrix defined via its Householder reflectors stored in A.  <a href="#adf77bb0fe92ef09522d0458ee9df03db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , unsigned int ALIGNMENT, typename VectorType1 , unsigned int A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa926ae9008c3343c337f2aa5a90e8734">inplace_qr_apply_trans_Q</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; const &amp;A, VectorType1 const &amp;betas, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1f0e3ecd9e48ea541f4d69504790dc44">inplace_qr</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; &amp;A, std::size_t block_size=16)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of inplace-QR factorization of a ViennaCL matrix A.  <a href="#a1f0e3ecd9e48ea541f4d69504790dc44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
MatrixType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a08a02fbf1c333de53b55189ffa776003">inplace_qr</a> (MatrixType &amp;A, std::size_t block_size=16)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of inplace-QR factorization for a general Boost.uBLAS compatible matrix A.  <a href="#a08a02fbf1c333de53b55189ffa776003"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a88d94d5150b88140d34f598e3cb31b6d">as</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 = s2 @ alpha, where s1 and s2 are GPU scalars, @ denotes multiplication or division, and alpha is either a GPU or a CPU scalar.  <a href="#a88d94d5150b88140d34f598e3cb31b6d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a05e31f1fadbe56011c80483fb56714f2">asbs</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 = s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar.  <a href="#a05e31f1fadbe56011c80483fb56714f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af1c3985dcb6df03140455b28622bae51">asbs_s</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 += s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar.  <a href="#af1c3985dcb6df03140455b28622bae51"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a376a98ceee0ab85880a4b5a9c343d802">swap</a> (S1 &amp;s1, S2 &amp;s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two scalars.  <a href="#a376a98ceee0ab85880a4b5a9c343d802"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af0e2c481d5920946ce6fce0874cd8138">prod_impl</a> (const SparseMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication involving a sparse matrix type.  <a href="#af0e2c481d5920946ce6fce0874cd8138"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2cd904fcd01a99005ca9f83f3c696b41">inplace_solve</a> (const SparseMatrixType &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out triangular inplace solves.  <a href="#a2cd904fcd01a99005ca9f83f3c696b41"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a02babae1af157516bd1e92d28c711957">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const SparseMatrixType, const SparseMatrixType, op_trans &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, SOLVERTAG tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out transposed triangular inplace solves.  <a href="#a02babae1af157516bd1e92d28c711957"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7dd4119fc5dfef5c067af3b46bd86191">svd</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;QL, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;QR)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of a matrix A. Experimental in 1.3.x.  <a href="#a7dd4119fc5dfef5c067af3b46bd86191"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae45beece755553455daea6973a60043d">prod_impl</a> (const <a class="el" href="classviennacl_1_1toeplitz__matrix.html">viennacl::toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a>.  <a href="#ae45beece755553455daea6973a60043d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9f72b2d3fa82b534f6c078b93f8648ee">inplace_tred2</a> (boost::numeric::ublas::matrix&lt; ScalarType &gt; const &amp;A, std::size_t block_size=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace reduction of a hermitian (or real symmetric) to tridiagonal form using householder similarity transforms (preserving eigenvalues)  <a href="#a9f72b2d3fa82b534f6c078b93f8648ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64b4f1d927a4df6416192cc8e69ed8aa">prod_impl</a> (const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a>.  <a href="#a64b4f1d927a4df6416192cc8e69ed8aa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5abc76193a54abea357ec6503ffaadcb">av</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">avbv</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">avbv_v</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aedeab8ab68ef95c6b3c432c0edb7a7fa">vector_assign</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, const T &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to a vector (-range/-slice)  <a href="#aedeab8ab68ef95c6b3c432c0edb7a7fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad345204a9420f9dd57bbad0b16fc40d9">vector_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#ad345204a9420f9dd57bbad0b16fc40d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a88e78e9d4c4c2757e900f9d72d3991d0">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#a88e78e9d4c4c2757e900f9d72d3991d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a26430c1bc54c7c07a50c32134fcd7947">element_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V1, const V2, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename V2 , typename V3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4b8a0af3f02276bed9a6d216ac521726">element_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V2, const V3, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 , typename OP1 , typename V3 , typename V4 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; V1 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4ecf8e15d42a341d0794d4c969a1447e">element_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V1, const V2, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V3, const V4, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8b09f0aec91078574a63d1806c924d41">element_div</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V1, const V2, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename V2 , typename V3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a63a73460fba00bf1e6f273045f99a84b">element_div</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V2, const V3, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 , typename OP1 , typename V3 , typename V4 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; V1 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae3cfbb2715c16fca13c0f54c5d54808d">element_div</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V1, const V2, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const V3, const V4, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94c58051a4819c96e29cd360e784c68f">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a94c58051a4819c96e29cd360e784c68f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acbacf04789215a3a748eca63743d50af">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2, T alpha, T beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#acbacf04789215a3a748eca63743d50af"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6de29a74120ed8a125cc0ddf8aba9c61">double_float_conversion_program</a> = &quot;};\n&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0750da577721a3af695ce9cfcb28dd14">SVD_BIDIAG_PACK_KERNEL</a> = &quot;bidiag_pack&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0019a82670bbaab3b7daec6e8e587a5a">SVD_HOUSEHOLDER_UPDATE_A_LEFT_KERNEL</a> = &quot;house_update_A_left&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac64d6406567e29f42d21baf2830d2c22">SVD_HOUSEHOLDER_UPDATE_A_RIGHT_KERNEL</a> = &quot;house_update_A_right&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acf0f644472acbda3e4e8d3b9d72ca992">SVD_HOUSEHOLDER_UPDATE_QL_KERNEL</a> = &quot;house_update_QL&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0dc671ac410dc86b8031dc9097d9586b">SVD_HOUSEHOLDER_UPDATE_QR_KERNEL</a> = &quot;house_update_QR&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af3fa2ab151dba770754145268e11946b">SVD_COPY_COL_KERNEL</a> = &quot;copy_col&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adf8feda331e6ff1a9a67fe0c80802aac">SVD_COPY_ROW_KERNEL</a> = &quot;copy_row&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3a15021d34692d59f651cc79493dd5cd">SVD_MATRIX_TRANSPOSE_KERNEL</a> = &quot;transpose_inplace&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac82a3ff5bbef1bbe246778ae14f50c67">SVD_INVERSE_SIGNS_KERNEL</a> = &quot;inverse_signs&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4e27134265fd8973fec8d433c18eb03b">SVD_GIVENS_PREV_KERNEL</a> = &quot;givens_prev&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8683fc870df555bfbf6e76593cb5f0f4">SVD_GIVENS_NEXT_KERNEL</a> = &quot;givens_next&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a254db871b76950596d65413ff17b7554">SVD_FINAL_ITER_UPDATE_KERNEL</a> = &quot;final_iter_update&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1b17560d4300d1bb83de30864e5a5d2a">SVD_UPDATE_QR_COLUMN_KERNEL</a> = &quot;update_qr_column&quot;</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ac30c43a1f6aa29f7998168ae0a5ce911"></a><!-- doxytag: member="viennacl::linalg::amg_tag" ref="ac30c43a1f6aa29f7998168ae0a5ce911" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html">detail::amg::amg_tag</a> <a class="el" href="namespaceviennacl_1_1linalg.html#ac30c43a1f6aa29f7998168ae0a5ce911">amg_tag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94fe4b190b9f52b4f5f0fd6ebca44cff"></a><!-- doxytag: member="viennacl::linalg::fspai_tag" ref="a94fe4b190b9f52b4f5f0fd6ebca44cff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">viennacl::linalg::detail::spai::fspai_tag</a> <a class="el" href="namespaceviennacl_1_1linalg.html#a94fe4b190b9f52b4f5f0fd6ebca44cff">fspai_tag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c0e3dee6941202d84ebbf88fa3f77ba"></a><!-- doxytag: member="viennacl::linalg::spai_tag" ref="a7c0e3dee6941202d84ebbf88fa3f77ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">viennacl::linalg::detail::spai::spai_tag</a> <a class="el" href="namespaceviennacl_1_1linalg.html#a7c0e3dee6941202d84ebbf88fa3f77ba">spai_tag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6f0db810dab59f2ecded1a5c8d8b0473"></a><!-- doxytag: member="viennacl::linalg::am" ref="a6f0db810dab59f2ecded1a5c8d8b0473" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a6f0db810dab59f2ecded1a5c8d8b0473">viennacl::linalg::am</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe7161810c732e58a047eac3ec15134a"></a><!-- doxytag: member="viennacl::linalg::ambm" ref="abe7161810c732e58a047eac3ec15134a" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abe7161810c732e58a047eac3ec15134a">viennacl::linalg::ambm</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b86d87cdfa2ffd2fd5ddca91d975439"></a><!-- doxytag: member="viennacl::linalg::ambm_m" ref="a0b86d87cdfa2ffd2fd5ddca91d975439" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a0b86d87cdfa2ffd2fd5ddca91d975439">viennacl::linalg::ambm_m</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9b5668dc901d2bd9868440b02a21c44"></a><!-- doxytag: member="viennacl::linalg::amg_init" ref="ae9b5668dc901d2bd9868440b02a21c44" args="(MatrixType const &amp;mat, InternalType1 &amp;A, InternalType1 &amp;P, InternalType2 &amp;Pointvector, amg_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ae9b5668dc901d2bd9868440b02a21c44">viennacl::linalg::amg_init</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>Pointvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amg_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize AMG preconditioner. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>System matrix </td></tr>
    <tr><td class="paramname">A</td><td>Operator matrices on all levels </td></tr>
    <tr><td class="paramname">P</td><td>Prolongation/Interpolation operators on all levels </td></tr>
    <tr><td class="paramname">Pointvector</td><td>Vector of points on all levels </td></tr>
    <tr><td class="paramname">tag</td><td>AMG preconditioner tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadf9be8a31e606c2fb2a2a46d1031011"></a><!-- doxytag: member="viennacl::linalg::amg_lu" ref="aadf9be8a31e606c2fb2a2a46d1031011" args="(boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;op, boost::numeric::ublas::permutation_matrix&lt;&gt; &amp;Permutation, SparseMatrixType const &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aadf9be8a31e606c2fb2a2a46d1031011">viennacl::linalg::amg_lu</a> </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::permutation_matrix&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pre-compute LU factorization for direct solve (ublas library). </p>
<p>Speeds up precondition phase as this is computed only once overall instead of once per iteration.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Operator matrix for direct solve </td></tr>
    <tr><td class="paramname">Permutation</td><td>Permutation matrix which saves the factorization result </td></tr>
    <tr><td class="paramname">A</td><td>Operator matrix on coarsest level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e11ae0a1b97997ccc1dd2622841b108"></a><!-- doxytag: member="viennacl::linalg::amg_setup" ref="a8e11ae0a1b97997ccc1dd2622841b108" args="(InternalType1 &amp;A, InternalType1 &amp;P, InternalType2 &amp;Pointvector, amg_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a8e11ae0a1b97997ccc1dd2622841b108">viennacl::linalg::amg_setup</a> </td>
          <td>(</td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>Pointvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amg_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup AMG preconditioner. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Operator matrices on all levels </td></tr>
    <tr><td class="paramname">P</td><td>Prolongation/Interpolation operators on all levels </td></tr>
    <tr><td class="paramname">Pointvector</td><td>Vector of points on all levels </td></tr>
    <tr><td class="paramname">tag</td><td>AMG preconditioner tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a047d012a7c5ae638614447a2d52895cb"></a><!-- doxytag: member="viennacl::linalg::amg_setup_apply" ref="a047d012a7c5ae638614447a2d52895cb" args="(InternalVectorType &amp;result, InternalVectorType &amp;rhs, InternalVectorType &amp;residual, SparseMatrixType const &amp;A, amg_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a047d012a7c5ae638614447a2d52895cb">viennacl::linalg::amg_setup_apply</a> </td>
          <td>(</td>
          <td class="paramtype">InternalVectorType &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalVectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalVectorType &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup data structures for precondition phase. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Result vector on all levels </td></tr>
    <tr><td class="paramname">rhs</td><td>RHS vector on all levels </td></tr>
    <tr><td class="paramname">residual</td><td>Residual vector on all levels </td></tr>
    <tr><td class="paramname">A</td><td>Operators matrices on all levels from setup phase </td></tr>
    <tr><td class="paramname">tag</td><td>AMG preconditioner tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b46ab307a64df8fcf45c19fcbffb1d7"></a><!-- doxytag: member="viennacl::linalg::amg_transform_cpu" ref="a8b46ab307a64df8fcf45c19fcbffb1d7" args="(InternalType1 &amp;A, InternalType1 &amp;P, InternalType1 &amp;R, InternalType2 &amp;A_setup, InternalType2 &amp;P_setup, amg_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a8b46ab307a64df8fcf45c19fcbffb1d7">viennacl::linalg::amg_transform_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>A_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>P_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amg_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save operators after setup phase for CPU computation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Operator matrices on all levels on the CPU </td></tr>
    <tr><td class="paramname">P</td><td>Prolongation/Interpolation operators on all levels on the CPU </td></tr>
    <tr><td class="paramname">R</td><td>Restriction operators on all levels on the CPU </td></tr>
    <tr><td class="paramname">A_setup</td><td>Operators matrices on all levels from setup phase </td></tr>
    <tr><td class="paramname">P_setup</td><td>Prolongation/Interpolation operators on all levels from setup phase </td></tr>
    <tr><td class="paramname">tag</td><td>AMG preconditioner tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1db0aa9042114f6c4258cbe6376eb50"></a><!-- doxytag: member="viennacl::linalg::amg_transform_gpu" ref="af1db0aa9042114f6c4258cbe6376eb50" args="(InternalType1 &amp;A, InternalType1 &amp;P, InternalType1 &amp;R, InternalType2 &amp;A_setup, InternalType2 &amp;P_setup, amg_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#af1db0aa9042114f6c4258cbe6376eb50">viennacl::linalg::amg_transform_gpu</a> </td>
          <td>(</td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType1 &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>A_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalType2 &amp;&#160;</td>
          <td class="paramname"><em>P_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amg_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save operators after setup phase for GPU computation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Operator matrices on all levels on the GPU </td></tr>
    <tr><td class="paramname">P</td><td>Prolongation/Interpolation operators on all levels on the GPU </td></tr>
    <tr><td class="paramname">R</td><td>Restriction operators on all levels on the GPU </td></tr>
    <tr><td class="paramname">A_setup</td><td>Operators matrices on all levels from setup phase </td></tr>
    <tr><td class="paramname">P_setup</td><td>Prolongation/Interpolation operators on all levels from setup phase </td></tr>
    <tr><td class="paramname">tag</td><td>AMG preconditioner tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88d94d5150b88140d34f598e3cb31b6d"></a><!-- doxytag: member="viennacl::linalg::as" ref="a88d94d5150b88140d34f598e3cb31b6d" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#a88d94d5150b88140d34f598e3cb31b6d">viennacl::linalg::as</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for the generic operation s1 = s2 @ alpha, where s1 and s2 are GPU scalars, @ denotes multiplication or division, and alpha is either a GPU or a CPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05e31f1fadbe56011c80483fb56714f2"></a><!-- doxytag: member="viennacl::linalg::asbs" ref="a05e31f1fadbe56011c80483fb56714f2" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#a05e31f1fadbe56011c80483fb56714f2">viennacl::linalg::asbs</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for the generic operation s1 = s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is a small GPU vector, which needs to be summed in order to obtain the final scalar, then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
    <tr><td class="paramname">s3</td><td>The third (GPU) scalar </td></tr>
    <tr><td class="paramname">beta</td><td>The scalar beta in the operation </td></tr>
    <tr><td class="paramname">len_beta</td><td>If beta is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_beta</td><td>If true, then s2 / beta instead of s2 * beta is computed </td></tr>
    <tr><td class="paramname">flip_sign_beta</td><td>If true, then (-beta) is used instead of beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1c3985dcb6df03140455b28622bae51"></a><!-- doxytag: member="viennacl::linalg::asbs_s" ref="af1c3985dcb6df03140455b28622bae51" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#af1c3985dcb6df03140455b28622bae51">viennacl::linalg::asbs_s</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for the generic operation s1 += s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is a small GPU vector, which needs to be summed in order to obtain the final scalar, then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
    <tr><td class="paramname">s3</td><td>The third (GPU) scalar </td></tr>
    <tr><td class="paramname">beta</td><td>The scalar beta in the operation </td></tr>
    <tr><td class="paramname">len_beta</td><td>If beta is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_beta</td><td>If true, then s2 / beta instead of s2 * beta is computed </td></tr>
    <tr><td class="paramname">flip_sign_beta</td><td>If true, then (-beta) is used instead of beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5abc76193a54abea357ec6503ffaadcb"></a><!-- doxytag: member="viennacl::linalg::av" ref="a5abc76193a54abea357ec6503ffaadcb" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a5abc76193a54abea357ec6503ffaadcb">viennacl::linalg::av</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9283e9543bbe348eb00d7c16b678ecad"></a><!-- doxytag: member="viennacl::linalg::avbv" ref="a9283e9543bbe348eb00d7c16b678ecad" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaeda7928989157a211111dfbfcb35793"></a><!-- doxytag: member="viennacl::linalg::avbv_v" ref="aaeda7928989157a211111dfbfcb35793" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, std::size_t len_beta, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">viennacl::linalg::avbv_v</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54d70c731aed90556e228b7f14ac3a52"></a><!-- doxytag: member="viennacl::linalg::bisect" ref="a54d70c731aed90556e228b7f14ac3a52" args="(VectorT const &amp;alphas, VectorT const &amp;betas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename VectorT::value_type&gt;::type &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a54d70c731aed90556e228b7f14ac3a52">viennacl::linalg::bisect</a> </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>alphas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the bisect-algorithm for the calculation of the eigenvalues of a tridiagonal matrix. Experimental - interface might change. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alphas</td><td>Elements of the main diagonal </td></tr>
    <tr><td class="paramname">betas</td><td>Elements of the secondary diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the eigenvalues of the tridiagonal matrix defined by alpha and beta </dd></dl>

</div>
</div>
<a class="anchor" id="a7b596f98d234d40fe9460d0077d1fcc3"></a><!-- doxytag: member="viennacl::linalg::convolve_i" ref="a7b596f98d234d40fe9460d0077d1fcc3" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">viennacl::linalg::convolve_i</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8878598e5b2eac306142bab233d3530"></a><!-- doxytag: member="viennacl::linalg::eig" ref="ad8878598e5b2eac306142bab233d3530" args="(MatrixT const &amp;matrix, power_iter_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#a7afda6c5b14466eaec9b3bd9db81d988">viennacl::linalg::eig</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">power_iter_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the calculation of eigenvalues using poweriteration. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with termination factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the largest eigenvalue computed by the power iteration method </dd></dl>

</div>
</div>
<a class="anchor" id="a7afda6c5b14466eaec9b3bd9db81d988"></a><!-- doxytag: member="viennacl::linalg::eig" ref="a7afda6c5b14466eaec9b3bd9db81d988" args="(MatrixT const &amp;matrix, lanczos_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a7afda6c5b14466eaec9b3bd9db81d988">viennacl::linalg::eig</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lanczos_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the calculation of eigenvalues using lanczos. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with several options for the lanczos algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the n largest eigenvalues (n defined in the <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html" title="A tag for the lanczos algorithm.">lanczos_tag</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a8b09f0aec91078574a63d1806c924d41"></a><!-- doxytag: member="viennacl::linalg::element_div" ref="a8b09f0aec91078574a63d1806c924d41" args="(vector_expression&lt; const V1, const V2, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">viennacl::linalg::element_div</a> </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const V1, const V2, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a63a73460fba00bf1e6f273045f99a84b"></a><!-- doxytag: member="viennacl::linalg::element_div" ref="a63a73460fba00bf1e6f273045f99a84b" args="(vector_base&lt; T &gt; const &amp;v1, vector_expression&lt; const V2, const V3, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">viennacl::linalg::element_div</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const V2, const V3, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3cfbb2715c16fca13c0f54c5d54808d"></a><!-- doxytag: member="viennacl::linalg::element_div" ref="ae3cfbb2715c16fca13c0f54c5d54808d" args="(vector_expression&lt; const V1, const V2, OP1 &gt; const &amp;proxy1, vector_expression&lt; const V3, const V4, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;V1&gt;::type&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">viennacl::linalg::element_div</a> </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const V1, const V2, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const V3, const V4, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaef3363b890dafbea83846825ea3d730"></a><!-- doxytag: member="viennacl::linalg::element_div" ref="aaef3363b890dafbea83846825ea3d730" args="(vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_div &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">element_div</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a88e78e9d4c4c2757e900f9d72d3991d0"></a><!-- doxytag: member="viennacl::linalg::element_op" ref="a88e78e9d4c4c2757e900f9d72d3991d0" args="(vector_base&lt; T &gt; &amp;vec1, vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a88e78e9d4c4c2757e900f9d72d3991d0">viennacl::linalg::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26430c1bc54c7c07a50c32134fcd7947"></a><!-- doxytag: member="viennacl::linalg::element_prod" ref="a26430c1bc54c7c07a50c32134fcd7947" args="(vector_expression&lt; const V1, const V2, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">viennacl::linalg::element_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const V1, const V2, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b8a0af3f02276bed9a6d216ac521726"></a><!-- doxytag: member="viennacl::linalg::element_prod" ref="a4b8a0af3f02276bed9a6d216ac521726" args="(vector_base&lt; T &gt; const &amp;v1, vector_expression&lt; const V2, const V3, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">viennacl::linalg::element_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const V2, const V3, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ecf8e15d42a341d0794d4c969a1447e"></a><!-- doxytag: member="viennacl::linalg::element_prod" ref="a4ecf8e15d42a341d0794d4c969a1447e" args="(vector_expression&lt; const V1, const V2, OP1 &gt; const &amp;proxy1, vector_expression&lt; const V3, const V4, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;V1&gt;::type&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">viennacl::linalg::element_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const V1, const V2, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const V3, const V4, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98122c5cd298059fc499f7ce8b278f79"></a><!-- doxytag: member="viennacl::linalg::element_prod" ref="a98122c5cd298059fc499f7ce8b278f79" args="(vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">element_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d991b4fc1435b34ddf9940911009e82"></a><!-- doxytag: member="viennacl::linalg::index_norm_inf" ref="a7d991b4fc1435b34ddf9940911009e82" args="(vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="namespaceviennacl_1_1linalg.html#a7d991b4fc1435b34ddf9940911009e82">index_norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar </dd></dl>

</div>
</div>
<a class="anchor" id="a43e399b80730abedb939a3d08e326a8f"></a><!-- doxytag: member="viennacl::linalg::index_norm_inf" ref="a43e399b80730abedb939a3d08e326a8f" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="namespaceviennacl_1_1linalg.html#a7d991b4fc1435b34ddf9940911009e82">index_norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab35950c4374eb3be08a03d852508c01a"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="ab35950c4374eb3be08a03d852508c01a" args="(VectorT1 const &amp;v1, VectorT2 const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT1 &gt;::type &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, typename VectorT1::value_type&gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">viennacl::linalg::inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype">VectorT1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad273e72f4a44fcd9802e3609d06af5e6"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="ad273e72f4a44fcd9802e3609d06af5e6" args="(vector_base&lt; NumericT &gt; const &amp;vector1, vector_base&lt; NumericT &gt; const &amp;vector2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, viennacl::op_inner_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">viennacl::linalg::inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4c12bee75a1dff46f0bd4b48abca2a5"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="ae4c12bee75a1dff46f0bd4b48abca2a5" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vector1, vector_base&lt; NumericT &gt; const &amp;vector2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS, RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, viennacl::op_inner_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">viennacl::linalg::inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac71bae6daf6dc8a5803071f79565582a"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="ac71bae6daf6dc8a5803071f79565582a" args="(vector_base&lt; NumericT &gt; const &amp;vector1, viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vector2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS, RHS, OP&gt;, viennacl::op_inner_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">viennacl::linalg::inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aac998ca060d47ba7c4b8bc1a994060ac"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="aac998ca060d47ba7c4b8bc1a994060ac" args="(viennacl::vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;vector1, viennacl::vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;vector2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS1, RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS2, RHS2, OP2&gt;, viennacl::op_inner_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">viennacl::linalg::inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abce7fb4d0ee0a5f82313eff5b07d03cc"></a><!-- doxytag: member="viennacl::linalg::inner_prod_cpu" ref="abce7fb4d0ee0a5f82313eff5b07d03cc" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab92256482cf6a71434a0501847dd70fe"></a><!-- doxytag: member="viennacl::linalg::inner_prod_cpu" ref="ab92256482cf6a71434a0501847dd70fe" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd75024e6302d26cd8f26559e9b6a31c"></a><!-- doxytag: member="viennacl::linalg::inner_prod_cpu" ref="abd75024e6302d26cd8f26559e9b6a31c" args="(vector_base&lt; T &gt; const &amp;vec1, viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c68566e658fd80448dabb02bfbf018c"></a><!-- doxytag: member="viennacl::linalg::inner_prod_cpu" ref="a9c68566e658fd80448dabb02bfbf018c" args="(viennacl::vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, viennacl::vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7cbb9fc8635e8ceb18dd181c0aa2324"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="ab7cbb9fc8635e8ceb18dd181c0aa2324" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - dispatcher interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84c0f006e2e4f840e0bebfd9a9fed0e8"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="a84c0f006e2e4f840e0bebfd9a9fed0e8" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5006ea75a0379d56e1dd8dbf6d817a41"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="a5006ea75a0379d56e1dd8dbf6d817a41" args="(vector_base&lt; T &gt; const &amp;vec1, viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64080f662904aa976e0767a4693211ea"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="a64080f662904aa976e0767a4693211ea" args="(viennacl::vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, viennacl::vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f0e3ecd9e48ea541f4d69504790dc44"></a><!-- doxytag: member="viennacl::linalg::inplace_qr" ref="a1f0e3ecd9e48ea541f4d69504790dc44" args="(viennacl::matrix&lt; T, F, ALIGNMENT &gt; &amp;A, std::size_t block_size=16)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a1f0e3ecd9e48ea541f4d69504790dc44">viennacl::linalg::inplace_qr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of inplace-QR factorization of a ViennaCL matrix A. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense ViennaCL matrix to be factored </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08a02fbf1c333de53b55189ffa776003"></a><!-- doxytag: member="viennacl::linalg::inplace_qr" ref="a08a02fbf1c333de53b55189ffa776003" args="(MatrixType &amp;A, std::size_t block_size=16)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MatrixType::value_type&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a1f0e3ecd9e48ea541f4d69504790dc44">viennacl::linalg::inplace_qr</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of inplace-QR factorization for a general Boost.uBLAS compatible matrix A. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense compatible to Boost.uBLAS </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf77bb0fe92ef09522d0458ee9df03db"></a><!-- doxytag: member="viennacl::linalg::inplace_qr_apply_trans_Q" ref="adf77bb0fe92ef09522d0458ee9df03db" args="(MatrixType const &amp;A, VectorType1 const &amp;betas, VectorType2 &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#adf77bb0fe92ef09522d0458ee9df03db">viennacl::linalg::inplace_qr_apply_trans_Q</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType1 const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes Q^T b, where Q is an implicit orthogonal matrix defined via its Householder reflectors stored in A. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix holding the Householder reflectors in the lower triangular part. Typically obtained from calling <a class="el" href="namespaceviennacl_1_1linalg.html#a1f0e3ecd9e48ea541f4d69504790dc44" title="Overload of inplace-QR factorization of a ViennaCL matrix A.">inplace_qr()</a> on the original matrix </td></tr>
    <tr><td class="paramname">betas</td><td>The scalars beta_i for each Householder reflector (I - beta_i v_i v_i^T) </td></tr>
    <tr><td class="paramname">b</td><td>The vector b to which the result Q^T b is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa926ae9008c3343c337f2aa5a90e8734"></a><!-- doxytag: member="viennacl::linalg::inplace_qr_apply_trans_Q" ref="aa926ae9008c3343c337f2aa5a90e8734" args="(viennacl::matrix&lt; T, F, ALIGNMENT &gt; const &amp;A, VectorType1 const &amp;betas, viennacl::vector&lt; T, A2 &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#adf77bb0fe92ef09522d0458ee9df03db">viennacl::linalg::inplace_qr_apply_trans_Q</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType1 const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa75503af5629061a7cb9aad57ddb93e3"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aa75503af5629061a7cb9aad57ddb93e3" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems. Matlab notation: A \ B. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa364ee657c06e95073ad3e4d896c4c74"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aa364ee657c06e95073ad3e4d896c4c74" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems with transposed right hand side. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a964cf6862e1143703815fb3ae144ee81"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a964cf6862e1143703815fb3ae144ee81" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense triangular systems that stem from transposed triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cd904fcd01a99005ca9f83f3c696b41"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a2cd904fcd01a99005ca9f83f3c696b41" args="(const SparseMatrixType &amp;mat, viennacl::vector_base&lt; ScalarType &gt; &amp;vec, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>&gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out triangular inplace solves. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag (<a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix.">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal.">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal.">unit_upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix.">upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c3ea032c153aa3431aac14b606f033a"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a1c3ea032c153aa3431aac14b606f033a" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense transposed triangular systems with transposed right hand side. Matlab notation: A' \ B'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02babae1af157516bd1e92d28c711957"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a02babae1af157516bd1e92d28c711957" args="(const matrix_expression&lt; const SparseMatrixType, const SparseMatrixType, op_trans &gt; &amp;mat, viennacl::vector_base&lt; ScalarType &gt; &amp;vec, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>&gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const SparseMatrixType, const SparseMatrixType, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out transposed triangular inplace solves. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag (<a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix.">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal.">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal.">unit_upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix.">upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acecd8a34364ee447a70ac9238814a306"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="acecd8a34364ee447a70ac9238814a306" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a76b7629e309062ce6c44badda302aa24"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a76b7629e309062ce6c44badda302aa24" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3">viennacl::linalg::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f72b2d3fa82b534f6c078b93f8648ee"></a><!-- doxytag: member="viennacl::linalg::inplace_tred2" ref="a9f72b2d3fa82b534f6c078b93f8648ee" args="(boost::numeric::ublas::matrix&lt; ScalarType &gt; const &amp;A, std::size_t block_size=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a9f72b2d3fa82b534f6c078b93f8648ee">viennacl::linalg::inplace_tred2</a> </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix&lt; ScalarType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace reduction of a hermitian (or real symmetric) to tridiagonal form using householder similarity transforms (preserving eigenvalues) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense matrix to be tridiagonalized </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad65e1a218cb0f80511efe283492abc44"></a><!-- doxytag: member="viennacl::linalg::lu_factorize" ref="ad65e1a218cb0f80511efe283492abc44" args="(matrix&lt; SCALARTYPE, viennacl::row_major &gt; &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ad65e1a218cb0f80511efe283492abc44">viennacl::linalg::lu_factorize</a> </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU factorization of a row-major dense matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a445605d4c8e66a0b4e332e6992d4653c"></a><!-- doxytag: member="viennacl::linalg::lu_factorize" ref="a445605d4c8e66a0b4e332e6992d4653c" args="(matrix&lt; SCALARTYPE, viennacl::column_major &gt; &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ad65e1a218cb0f80511efe283492abc44">viennacl::linalg::lu_factorize</a> </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">viennacl::column_major</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU factorization of a column-major dense matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71bf0e8b5778b85239f046125cf610a3"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a71bf0e8b5778b85239f046125cf610a3" args="(matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;A, matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a71bf0e8b5778b85239f046125cf610a3">viennacl::linalg::lu_substitute</a> </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a293d663addc176b5166524fe9257b7af"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a293d663addc176b5166524fe9257b7af" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;A, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a71bf0e8b5778b85239f046125cf610a3">viennacl::linalg::lu_substitute</a> </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ebd54b74107b1b98cf6f4bf11fd94f9"></a><!-- doxytag: member="viennacl::linalg::matrix_assign" ref="a6ebd54b74107b1b98cf6f4bf11fd94f9" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a6ebd54b74107b1b98cf6f4bf11fd94f9">viennacl::linalg::matrix_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab481481940dea4d443101db27bd87a00"></a><!-- doxytag: member="viennacl::linalg::matrix_diagonal_assign" ref="ab481481940dea4d443101db27bd87a00" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ab481481940dea4d443101db27bd87a00">viennacl::linalg::matrix_diagonal_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aadee9fd42885065f6fa0048aa2b08d83"></a><!-- doxytag: member="viennacl::linalg::nmf" ref="aadee9fd42885065f6fa0048aa2b08d83" args="(viennacl::matrix&lt; ScalarType &gt; const &amp;V, viennacl::matrix&lt; ScalarType &gt; &amp;W, viennacl::matrix&lt; ScalarType &gt; &amp;H, nmf_config const &amp;conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aadee9fd42885065f6fa0048aa2b08d83">viennacl::linalg::nmf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmf_config const &amp;&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The nonnegative matrix factorization (approximation) algorithm as suggested by Lee and Seung. Factorizes a matrix V with nonnegative entries into matrices W and H such that ||V - W*H|| is minimized. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Input matrix </td></tr>
    <tr><td class="paramname">W</td><td>First factor </td></tr>
    <tr><td class="paramname">H</td><td>Second factor </td></tr>
    <tr><td class="paramname">conf</td><td>A configuration object holding tolerances and the like </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2efad0d090dde0c127fa8b25a73836e4"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="a2efad0d090dde0c127fa8b25a73836e4" args="(std::vector&lt; T, A &gt; const &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">viennacl::linalg::norm_1</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a464b2a90b50a88b535e98993e7994f31"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="a464b2a90b50a88b535e98993e7994f31" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_1 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">viennacl::linalg::norm_1</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add18254bbe03030fb9a20c768e8c18f2"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="add18254bbe03030fb9a20c768e8c18f2" args="(viennacl::vector_range&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, viennacl::op_norm_1 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">viennacl::linalg::norm_1</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07ce598e7f63cb1e9c75b2e2f3fbbc02"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="a07ce598e7f63cb1e9c75b2e2f3fbbc02" args="(viennacl::vector_slice&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, viennacl::op_norm_1 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">viennacl::linalg::norm_1</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5b81d05ed5510a3142a5f29e8b2525f"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="ab5b81d05ed5510a3142a5f29e8b2525f" args="(viennacl::vector_expression&lt; const LHS, const RHS, OP &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, viennacl::op_norm_1&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">viennacl::linalg::norm_1</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acddd2a99867a55480dde2b4dba0a588c"></a><!-- doxytag: member="viennacl::linalg::norm_1_cpu" ref="acddd2a99867a55480dde2b4dba0a588c" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#acddd2a99867a55480dde2b4dba0a588c">norm_1_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on the CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d55e0e715a14ef4b336c06018c38db7"></a><!-- doxytag: member="viennacl::linalg::norm_1_cpu" ref="a1d55e0e715a14ef4b336c06018c38db7" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#acddd2a99867a55480dde2b4dba0a588c">norm_1_cpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a546e0f416d08c99d21344dda5398859c"></a><!-- doxytag: member="viennacl::linalg::norm_1_impl" ref="a546e0f416d08c99d21344dda5398859c" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector - dispatcher interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2487c579ee752a9fcc31c12d0bddf604"></a><!-- doxytag: member="viennacl::linalg::norm_1_impl" ref="a2487c579ee752a9fcc31c12d0bddf604" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">viennacl::linalg::norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94c58051a4819c96e29cd360e784c68f"></a><!-- doxytag: member="viennacl::linalg::norm_1_impl" ref="a94c58051a4819c96e29cd360e784c68f" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">viennacl::linalg::norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae46f15d01c01f92a153b3f555a15096b"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="ae46f15d01c01f92a153b3f555a15096b" args="(std::vector&lt; T, A &gt; const &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e6f3ef1937f77eb6fa570d96c9d314"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="a74e6f3ef1937f77eb6fa570d96c9d314" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_2 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb8b3d2c69031b74f97778dbc0419ffe"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="afb8b3d2c69031b74f97778dbc0419ffe" args="(viennacl::vector_range&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, viennacl::op_norm_2 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa783ab48afd63333ef3ea74ca41ab183"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="aa783ab48afd63333ef3ea74ca41ab183" args="(viennacl::vector_slice&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, viennacl::op_norm_2 &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a22bc2566ec601883db764cf08950c9"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="a2a22bc2566ec601883db764cf08950c9" args="(viennacl::vector_expression&lt; const LHS, const RHS, OP &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, viennacl::op_norm_2&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a063fa23bfd77e19e93046d256027f438"></a><!-- doxytag: member="viennacl::linalg::norm_2_cpu" ref="a063fa23bfd77e19e93046d256027f438" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a063fa23bfd77e19e93046d256027f438">norm_2_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a609941700fc79f0978daf50acaa93656"></a><!-- doxytag: member="viennacl::linalg::norm_2_cpu" ref="a609941700fc79f0978daf50acaa93656" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a063fa23bfd77e19e93046d256027f438">norm_2_cpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abeaca00d5581387446ab0948dde72f44"></a><!-- doxytag: member="viennacl::linalg::norm_2_impl" ref="abeaca00d5581387446ab0948dde72f44" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abeaca00d5581387446ab0948dde72f44">norm_2_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - dispatcher interface. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d1a04d42e467eb9e0cd4b3a17cfc317"></a><!-- doxytag: member="viennacl::linalg::norm_2_impl" ref="a9d1a04d42e467eb9e0cd4b3a17cfc317" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#abeaca00d5581387446ab0948dde72f44">norm_2_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4de9152d556e89d823eb47a683ead11"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="ae4de9152d556e89d823eb47a683ead11" args="(std::vector&lt; T, A &gt; const &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">viennacl::linalg::norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69f9505ad981bc47344c74c12aebc226"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="a69f9505ad981bc47344c74c12aebc226" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_inf &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">viennacl::linalg::norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1a0fb8fb93e786221984ef6242d0735"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="ab1a0fb8fb93e786221984ef6242d0735" args="(viennacl::vector_range&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt;VectorType&gt;, viennacl::op_norm_inf &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">viennacl::linalg::norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb1f4a590bb4b9e14a20e3946e365fd9"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="afb1f4a590bb4b9e14a20e3946e365fd9" args="(viennacl::vector_slice&lt; VectorType &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, const <a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt;VectorType&gt;, viennacl::op_norm_inf &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">viennacl::linalg::norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6ac490ffc6af2faebcc33724bba120e"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="af6ac490ffc6af2faebcc33724bba120e" args="(viennacl::vector_expression&lt; const LHS, const RHS, OP &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, viennacl::op_norm_inf&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">viennacl::linalg::norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a57092218bb316cdd6e7a9e8a758f3e99"></a><!-- doxytag: member="viennacl::linalg::norm_inf_cpu" ref="a57092218bb316cdd6e7a9e8a758f3e99" args="(vector_base&lt; T &gt; const &amp;vec, T &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a57092218bb316cdd6e7a9e8a758f3e99">norm_inf_cpu</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector with final reduction on the CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0fb517b1788ab9c44ee93021c32ba3f"></a><!-- doxytag: member="viennacl::linalg::norm_inf_cpu" ref="ad0fb517b1788ab9c44ee93021c32ba3f" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a57092218bb316cdd6e7a9e8a758f3e99">norm_inf_cpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f7158a5f1fb8b67e2e6849b202a86a9"></a><!-- doxytag: member="viennacl::linalg::norm_inf_impl" ref="a5f7158a5f1fb8b67e2e6849b202a86a9" args="(vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a5f7158a5f1fb8b67e2e6849b202a86a9">norm_inf_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8921e7938a67173daaf6c9a0e40e3e0"></a><!-- doxytag: member="viennacl::linalg::norm_inf_impl" ref="ac8921e7938a67173daaf6c9a0e40e3e0" args="(viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a5f7158a5f1fb8b67e2e6849b202a86a9">norm_inf_impl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80b166d4b1b136b020820db3d7572b0d"></a><!-- doxytag: member="viennacl::linalg::outer_prod" ref="a80b166d4b1b136b020820db3d7572b0d" args="(const vector_base&lt; NumericT &gt; &amp;vec1, const vector_base&lt; NumericT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, op_prod&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a80b166d4b1b136b020820db3d7572b0d">viennacl::linalg::outer_prod</a> </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbacf04789215a3a748eca63743d50af"></a><!-- doxytag: member="viennacl::linalg::plane_rotation" ref="acbacf04789215a3a748eca63743d50af" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2, T alpha, T beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#acbacf04789215a3a748eca63743d50af">viennacl::linalg::plane_rotation</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">alpha</td><td>The first transformation coefficient (CPU scalar) </td></tr>
    <tr><td class="paramname">beta</td><td>The second transformation coefficient (CPU scalar) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15e75e9c94551d2c133359056d4e630"></a><!-- doxytag: member="viennacl::linalg::precondition" ref="ae15e75e9c94551d2c133359056d4e630" args="(viennacl::compressed_matrix&lt; ScalarType &gt; &amp;A, ichol0_tag const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a2f7e122a5571e19d861deec3910eb953">viennacl::linalg::precondition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ichol0_tag const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices. </p>
<p>Refer to Chih-Jen Lin and Jorge J. Mor, Incomplete Cholesky Factorizations with Limited Memory, SIAM J. Sci. Comput., 21(1), 2445 for one of many descriptions of incomplete Cholesky Factorizations</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix in CSR format // param tag An <a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html" title="A tag for incomplete Cholesky factorization with static pattern (ILU0)">ichol0_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f7e122a5571e19d861deec3910eb953"></a><!-- doxytag: member="viennacl::linalg::precondition" ref="a2f7e122a5571e19d861deec3910eb953" args="(viennacl::compressed_matrix&lt; ScalarType &gt; &amp;A, ilu0_tag const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a2f7e122a5571e19d861deec3910eb953">viennacl::linalg::precondition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilu0_tag const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices. </p>
<p>refer to the Algorithm in Saad's book (1996 edition)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The sparse matrix matrix. The result is directly written to A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab21b0d140ee1815089d449b50379011f"></a><!-- doxytag: member="viennacl::linalg::precondition" ref="ab21b0d140ee1815089d449b50379011f" args="(SparseMatrixType const &amp;A, std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; &amp;output, ilut_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a2f7e122a5571e19d861deec3910eb953">viennacl::linalg::precondition</a> </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilut_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of a ILU-preconditioner with threshold. Optimized implementation for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>refer to Algorithm 10.6 by Saad's book (1996 edition)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. Either a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> or of type std::vector&lt; std::map&lt;T, U&gt; &gt; </td></tr>
    <tr><td class="paramname">output</td><td>The output matrix. Type requirements: const_iterator1 for iteration along rows, const_iterator2 for iteration along columns and write access via operator() </td></tr>
    <tr><td class="paramname">tag</td><td>An <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html" title="A tag for incomplete LU factorization with threshold (ILUT)">ilut_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa18d10f8a90e38bd9ff43c650fc670ef"></a><!-- doxytag: member="viennacl::linalg::prod" ref="aa18d10f8a90e38bd9ff43c650fc670ef" args="(std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;matrix, VectorT const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a8191b8e2833645bf9a50cf0385bf84"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a4a8191b8e2833645bf9a50cf0385bf84" args="(std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;matrix, VectorT const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb4b03c4436d0d255bdad9530f47aa36"></a><!-- doxytag: member="viennacl::linalg::prod" ref="adb4b03c4436d0d255bdad9530f47aa36" args="(viennacl::matrix_base&lt; NumericT, F1 &gt; const &amp;A, viennacl::matrix_base&lt; NumericT, F2 &gt; const &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afc824308fb9e41411923061681552b88"></a><!-- doxytag: member="viennacl::linalg::prod" ref="afc824308fb9e41411923061681552b88" args="(viennacl::matrix_base&lt; NumericT, F1 &gt; const &amp;A, viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F2 &gt;, const viennacl::matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, op_trans&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0e97631c585f85028bfd45023c6b0ff"></a><!-- doxytag: member="viennacl::linalg::prod" ref="ab0e97631c585f85028bfd45023c6b0ff" args="(viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;A, viennacl::matrix_base&lt; NumericT, F2 &gt; const &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, op_trans&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d8cb3ba8e42665222c63a05598b1347"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a6d8cb3ba8e42665222c63a05598b1347" args="(viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;A, viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F2 &gt;, const viennacl::matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F1&gt;, op_trans&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F2&gt;, op_trans&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a76d12d40e1910232c03aa9d988693abb"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a76d12d40e1910232c03aa9d988693abb" args="(viennacl::matrix_base&lt; NumericT, F &gt; const &amp;matrix, viennacl::vector_base&lt; NumericT &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;NumericT&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a10dd9cc2820e73305edc1a271ff64ca1"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a10dd9cc2820e73305edc1a271ff64ca1" args="(viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F &gt;, const viennacl::matrix_base&lt; NumericT, F &gt;, op_trans &gt; const &amp;matrix, viennacl::vector_base&lt; NumericT &gt; const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;NumericT, F&gt;, op_trans&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;NumericT&gt;, viennacl::op_prod &gt; <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68fb776340b6102fdd9c166bd160191f"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a68fb776340b6102fdd9c166bd160191f" args="(const SparseMatrixType &amp;mat, const vector_base&lt; SCALARTYPE &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;SCALARTYPE&gt;, op_prod &gt; &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a895bfcd9f3517d830a9d1434d26ba151"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a895bfcd9f3517d830a9d1434d26ba151" args="(const StructuredMatrixType &amp;mat, const vector_base&lt; SCALARTYPE &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">viennacl::is_any_dense_structured_matrix</a>&lt;StructuredMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const StructuredMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;SCALARTYPE&gt;, op_prod &gt; &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a> </td>
          <td>(</td>
          <td class="paramtype">const StructuredMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64b4f1d927a4df6416192cc8e69ed8aa"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a64b4f1d927a4df6416192cc8e69ed8aa" args="(const viennacl::vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab70efb53fa182b4f1bbd9f33e177875"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="aab70efb53fa182b4f1bbd9f33e177875" args="(const viennacl::circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1circulant__matrix.html">viennacl::circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae45beece755553455daea6973a60043d"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="ae45beece755553455daea6973a60043d" args="(const viennacl::toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1toeplitz__matrix.html">viennacl::toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6c0068bc315bae6be4333cc419c5e0e"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="ac6c0068bc315bae6be4333cc419c5e0e" args="(const viennacl::hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; SCALARTYPE &gt; &amp;vec, viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hankel__matrix.html">viennacl::hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0e2c481d5920946ce6fce0874cd8138"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="af0e2c481d5920946ce6fce0874cd8138" args="(const SparseMatrixType &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>&gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication involving a sparse matrix type. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a450121172f0d929f05ba8ff954a5e354"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a450121172f0d929f05ba8ff954a5e354" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

</div>
</div>
<a class="anchor" id="a64f211bc046e1dab1294e4097c6809a3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a64f211bc046e1dab1294e4097c6809a3" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

</div>
</div>
<a class="anchor" id="a441fec1b34b206f8e3825329c48791c2"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a441fec1b34b206f8e3825329c48791c2" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

</div>
</div>
<a class="anchor" id="a54d0ead72872b835f3286d6e7348ca86"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a54d0ead72872b835f3286d6e7348ca86" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

</div>
</div>
<a class="anchor" id="aaa45f913d8815ef5ca24d70443d31bd4"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="aaa45f913d8815ef5ca24d70443d31bd4" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49db0fe7daf624d43003ec4a08f3a8a3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a49db0fe7daf624d43003ec4a08f3a8a3" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_trans</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a946e478e53f6464d1dedeb3a46c89"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="ae7a946e478e53f6464d1dedeb3a46c89" args="(const SparseMatrixType &amp;mat, const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, op_prod &gt; &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">viennacl::linalg::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afedffd37d393726191b88e2dd3928370"></a><!-- doxytag: member="viennacl::linalg::qr_method_nsm" ref="afedffd37d393726191b88e2dd3928370" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;A, viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;Q, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;D, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;E)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#afedffd37d393726191b88e2dd3928370">viennacl::linalg::qr_method_nsm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af118563c8639a90bebf15b2df477f0a4"></a><!-- doxytag: member="viennacl::linalg::qr_method_sym" ref="af118563c8639a90bebf15b2df477f0a4" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;A, viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;Q, boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#af118563c8639a90bebf15b2df477f0a4">viennacl::linalg::qr_method_sym</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a76fc8bf8f5a20c576b7ddbad32d3e56d"></a><!-- doxytag: member="viennacl::linalg::recoverQ" ref="a76fc8bf8f5a20c576b7ddbad32d3e56d" args="(MatrixType const &amp;A, VectorType const &amp;betas, MatrixType &amp;Q, MatrixType &amp;R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a76fc8bf8f5a20c576b7ddbad32d3e56d">viennacl::linalg::recoverQ</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afaab5366d1d8890a5a8962a567fe7cb6"></a><!-- doxytag: member="viennacl::linalg::scaled_rank_1_update" ref="afaab5366d1d8890a5a8962a567fe7cb6" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, std::size_t len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, const vector_base&lt; NumericT &gt; &amp;vec1, const vector_base&lt; NumericT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#afaab5366d1d8890a5a8962a567fe7cb6">viennacl::linalg::scaled_rank_1_update</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>The matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>The scaling factor (either a viennacl::scalar&lt;&gt;, float, or double) </td></tr>
    <tr><td class="paramname">len_alpha</td><td>Length of the buffer for an eventual final reduction step (currently always '1') </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>Use 1/alpha instead of alpha </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>Use -alpha instead of alpha </td></tr>
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32eec41e03cdd02c40689912b38afdc9"></a><!-- doxytag: member="viennacl::linalg::setup_w" ref="a32eec41e03cdd02c40689912b38afdc9" args="(viennacl::compressed_matrix&lt; ScalarType &gt; const &amp;A, SizeType row, SparseVector &amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarType <a class="el" href="namespaceviennacl_1_1linalg.html#a32eec41e03cdd02c40689912b38afdc9">viennacl::linalg::setup_w</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVector &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatcher overload for extracting the row of nonzeros of a compressed matrix. </p>

</div>
</div>
<a class="anchor" id="a0deaaae3d6b0d1014d4dffd11345dc4c"></a><!-- doxytag: member="viennacl::linalg::setup_w" ref="a0deaaae3d6b0d1014d4dffd11345dc4c" args="(std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; const &amp;A, SizeType row, SparseVector &amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarType <a class="el" href="namespaceviennacl_1_1linalg.html#a32eec41e03cdd02c40689912b38afdc9">viennacl::linalg::setup_w</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; SizeType, ScalarType &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVector &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatcher overload for extracting the row of nonzeros of a STL-grown sparse matrix. </p>

</div>
</div>
<a class="anchor" id="ae4e9abff733ebe1feda607b4ccea8fc1"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ae4e9abff733ebe1feda607b4ccea8fc1" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the conjugate gradient solver without preconditioner. </p>
<p>Following the algorithm in the book by Y. Saad "Iterative Methods for sparse linear systems"</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a814104601016f71207386c80bdda8093"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a814104601016f71207386c80bdda8093" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the stabilized Bi-conjugate gradient solver. </p>
<p>Following the description in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a727542f4624926e74ff52ea5c75d546f"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a727542f4624926e74ff52ea5c75d546f" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, mixed_precision_cg_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mixed_precision_cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the conjugate gradient solver without preconditioner. </p>
<p>Following the algorithm in the book by Y. Saad "Iterative Methods for sparse linear systems"</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="ab371cd27fe8c8ed7870ea5cdbd0662af"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab371cd27fe8c8ed7870ea5cdbd0662af" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag, viennacl::linalg::no_precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c3315abaffb516302e24193e488012a"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a9c3315abaffb516302e24193e488012a" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned conjugate gradient solver. </p>
<p>Following Algorithm 9.1 in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
    <tr><td class="paramname">precond</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a7bbb1edc792ea86d1733f53ba7982592"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a7bbb1edc792ea86d1733f53ba7982592" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the GMRES solver. </p>
<p>Following the algorithm proposed by Walker in "A Simpler GMRES"</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
    <tr><td class="paramname">precond</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a71032b6a3aee256117e1c51e2dbea0f9"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a71032b6a3aee256117e1c51e2dbea0f9" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag, viennacl::linalg::no_precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa00ad2441a0fa5060717d2203aaa194a"></a><!-- doxytag: member="viennacl::linalg::solve" ref="aa00ad2441a0fa5060717d2203aaa194a" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned stabilized Bi-conjugate gradient solver. </p>
<p>Following the description of the unpreconditioned case in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
    <tr><td class="paramname">precond</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="ab5579a603f93ad9fb66d8ebc358d7d5a"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab5579a603f93ad9fb66d8ebc358d7d5a" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, mixed_precision_cg_tag const &amp;tag, viennacl::linalg::no_precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mixed_precision_cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38ccd566bd220d22edd83efaa9f46d37"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a38ccd566bd220d22edd83efaa9f46d37" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F2&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87193b0851afc957fc9f404d4e37f4c2"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a87193b0851afc957fc9f404d4e37f4c2" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;proxy, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F2&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy</td><td>The transposed load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0843082eba52dcefb6eca38eae65d88"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab0843082eba52dcefb6eca38eae65d88" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c81e49ec0a097373d91a1d4ff6b60ef"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a6c81e49ec0a097373d91a1d4ff6b60ef" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy, const matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F2&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3241685b395fe49991dd94d6249d5274"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a3241685b395fe49991dd94d6249d5274" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;proxy_B, SOLVERTAG tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F2&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix of load vectors, where the solution is directly written to </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab591ff273997061d053e458b5c0914da"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab591ff273997061d053e458b5c0914da" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used. </p>

</div>
</div>
<a class="anchor" id="afb467467a7ac39b7e339e15d59d89e91"></a><!-- doxytag: member="viennacl::linalg::solve" ref="afb467467a7ac39b7e339e15d59d89e91" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy, const vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; <a class="el" href="namespaceviennacl_1_1linalg.html#a814104601016f71207386c80bdda8093">viennacl::linalg::solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#aa75503af5629061a7cb9aad57ddb93e3" title="Direct inplace solver for dense triangular systems. Matlab notation: A \ B.">inplace_solve()</a> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dd4119fc5dfef5c067af3b46bd86191"></a><!-- doxytag: member="viennacl::linalg::svd" ref="a7dd4119fc5dfef5c067af3b46bd86191" args="(viennacl::matrix&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;A, viennacl::matrix&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;QL, viennacl::matrix&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;QR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#a7dd4119fc5dfef5c067af3b46bd86191">viennacl::linalg::svd</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>QL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the singular value decomposition of a matrix A. Experimental in 1.3.x. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. Will be overwritten with a diagonal matrix containing the singular values on return </td></tr>
    <tr><td class="paramname">QL</td><td>The left orthogonal matrix </td></tr>
    <tr><td class="paramname">QR</td><td>The right orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a376a98ceee0ab85880a4b5a9c343d802"></a><!-- doxytag: member="viennacl::linalg::swap" ref="a376a98ceee0ab85880a4b5a9c343d802" args="(S1 &amp;s1, S2 &amp;s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &gt;::type <a class="el" href="namespaceviennacl_1_1linalg.html#a376a98ceee0ab85880a4b5a9c343d802">viennacl::linalg::swap</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedeab8ab68ef95c6b3c432c0edb7a7fa"></a><!-- doxytag: member="viennacl::linalg::vector_assign" ref="aedeab8ab68ef95c6b3c432c0edb7a7fa" args="(vector_base&lt; T &gt; &amp;vec1, const T &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#aedeab8ab68ef95c6b3c432c0edb7a7fa">viennacl::linalg::vector_assign</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a constant value to a vector (-range/-slice) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector to which the value should be assigned </td></tr>
    <tr><td class="paramname">alpha</td><td>The value to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad345204a9420f9dd57bbad0b16fc40d9"></a><!-- doxytag: member="viennacl::linalg::vector_swap" ref="ad345204a9420f9dd57bbad0b16fc40d9" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg.html#ad345204a9420f9dd57bbad0b16fc40d9">viennacl::linalg::vector_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector (or -range, or -slice) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a6de29a74120ed8a125cc0ddf8aba9c61"></a><!-- doxytag: member="viennacl::linalg::double_float_conversion_program" ref="a6de29a74120ed8a125cc0ddf8aba9c61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceviennacl_1_1linalg.html#a6de29a74120ed8a125cc0ddf8aba9c61">double_float_conversion_program</a> = &quot;};\n&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0750da577721a3af695ce9cfcb28dd14"></a><!-- doxytag: member="viennacl::linalg::SVD_BIDIAG_PACK_KERNEL" ref="a0750da577721a3af695ce9cfcb28dd14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a0750da577721a3af695ce9cfcb28dd14">SVD_BIDIAG_PACK_KERNEL</a> = &quot;bidiag_pack&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af3fa2ab151dba770754145268e11946b"></a><!-- doxytag: member="viennacl::linalg::SVD_COPY_COL_KERNEL" ref="af3fa2ab151dba770754145268e11946b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#af3fa2ab151dba770754145268e11946b">SVD_COPY_COL_KERNEL</a> = &quot;copy_col&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf8feda331e6ff1a9a67fe0c80802aac"></a><!-- doxytag: member="viennacl::linalg::SVD_COPY_ROW_KERNEL" ref="adf8feda331e6ff1a9a67fe0c80802aac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#adf8feda331e6ff1a9a67fe0c80802aac">SVD_COPY_ROW_KERNEL</a> = &quot;copy_row&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a254db871b76950596d65413ff17b7554"></a><!-- doxytag: member="viennacl::linalg::SVD_FINAL_ITER_UPDATE_KERNEL" ref="a254db871b76950596d65413ff17b7554" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a254db871b76950596d65413ff17b7554">SVD_FINAL_ITER_UPDATE_KERNEL</a> = &quot;final_iter_update&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8683fc870df555bfbf6e76593cb5f0f4"></a><!-- doxytag: member="viennacl::linalg::SVD_GIVENS_NEXT_KERNEL" ref="a8683fc870df555bfbf6e76593cb5f0f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a8683fc870df555bfbf6e76593cb5f0f4">SVD_GIVENS_NEXT_KERNEL</a> = &quot;givens_next&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e27134265fd8973fec8d433c18eb03b"></a><!-- doxytag: member="viennacl::linalg::SVD_GIVENS_PREV_KERNEL" ref="a4e27134265fd8973fec8d433c18eb03b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a4e27134265fd8973fec8d433c18eb03b">SVD_GIVENS_PREV_KERNEL</a> = &quot;givens_prev&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0019a82670bbaab3b7daec6e8e587a5a"></a><!-- doxytag: member="viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_A_LEFT_KERNEL" ref="a0019a82670bbaab3b7daec6e8e587a5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a0019a82670bbaab3b7daec6e8e587a5a">SVD_HOUSEHOLDER_UPDATE_A_LEFT_KERNEL</a> = &quot;house_update_A_left&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac64d6406567e29f42d21baf2830d2c22"></a><!-- doxytag: member="viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_A_RIGHT_KERNEL" ref="ac64d6406567e29f42d21baf2830d2c22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#ac64d6406567e29f42d21baf2830d2c22">SVD_HOUSEHOLDER_UPDATE_A_RIGHT_KERNEL</a> = &quot;house_update_A_right&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf0f644472acbda3e4e8d3b9d72ca992"></a><!-- doxytag: member="viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_QL_KERNEL" ref="acf0f644472acbda3e4e8d3b9d72ca992" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#acf0f644472acbda3e4e8d3b9d72ca992">SVD_HOUSEHOLDER_UPDATE_QL_KERNEL</a> = &quot;house_update_QL&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0dc671ac410dc86b8031dc9097d9586b"></a><!-- doxytag: member="viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_QR_KERNEL" ref="a0dc671ac410dc86b8031dc9097d9586b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a0dc671ac410dc86b8031dc9097d9586b">SVD_HOUSEHOLDER_UPDATE_QR_KERNEL</a> = &quot;house_update_QR&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac82a3ff5bbef1bbe246778ae14f50c67"></a><!-- doxytag: member="viennacl::linalg::SVD_INVERSE_SIGNS_KERNEL" ref="ac82a3ff5bbef1bbe246778ae14f50c67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#ac82a3ff5bbef1bbe246778ae14f50c67">SVD_INVERSE_SIGNS_KERNEL</a> = &quot;inverse_signs&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a15021d34692d59f651cc79493dd5cd"></a><!-- doxytag: member="viennacl::linalg::SVD_MATRIX_TRANSPOSE_KERNEL" ref="a3a15021d34692d59f651cc79493dd5cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a3a15021d34692d59f651cc79493dd5cd">SVD_MATRIX_TRANSPOSE_KERNEL</a> = &quot;transpose_inplace&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b17560d4300d1bb83de30864e5a5d2a"></a><!-- doxytag: member="viennacl::linalg::SVD_UPDATE_QR_COLUMN_KERNEL" ref="a1b17560d4300d1bb83de30864e5a5d2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="namespaceviennacl_1_1linalg.html#a1b17560d4300d1bb83de30864e5a5d2a">SVD_UPDATE_QR_COLUMN_KERNEL</a> = &quot;update_qr_column&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:56 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
