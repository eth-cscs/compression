<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">backend</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing routines for handling the different memory domains. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator.html">generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides an OpenCL kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">io</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides basic input-output functionality. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing many meta-functions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">tools</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace for various tools used within ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Circulant matrix class.  <a href="classviennacl_1_1circulant__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">row_major_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">column_major_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">is_cpu_scalar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">is_flip_sign_scalar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">is_any_scalar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">is_row_major</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">is_any_sparse_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">is_circulant_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">is_hankel_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">is_toeplitz_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">is_vandermonde_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">is_any_dense_structured_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1vcl__static__assert_3_01true_01_4.html">vcl_static_assert&lt; true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1value__base.html">value_base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1value.html">value</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1any.html">any</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1bad__any__cast.html">bad_any_cast</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1true__pred.html">true_pred</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Hankel matrix class.  <a href="classviennacl_1_1hankel__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">identity_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">zero_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">scalar_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple enable-if variant that uses the SFINAE pattern.  <a href="structviennacl_1_1enable__if.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__addition.html">is_addition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)  <a href="structviennacl_1_1is__addition.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__subtraction.html">is_subtraction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)  <a href="structviennacl_1_1is__subtraction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__product.html">is_product</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multiplication)  <a href="structviennacl_1_1is__product.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__division.html">is_division</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is viennacl::op_div (for division)  <a href="structviennacl_1_1is__division.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__none.html">tag_none</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__stl.html">tag_stl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4.html">is_mtl4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a>.  <a href="structviennacl_1_1is__mtl4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4_3_01viennacl_1_1tag__mtl4_01_4.html">is_mtl4&lt; viennacl::tag_mtl4 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen.html">is_eigen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a>.  <a href="structviennacl_1_1is__eigen.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen_3_01viennacl_1_1tag__eigen_01_4.html">is_eigen&lt; viennacl::tag_eigen &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas.html">is_ublas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a>.  <a href="structviennacl_1_1is__ublas.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas_3_01viennacl_1_1tag__ublas_01_4.html">is_ublas&lt; viennacl::tag_ublas &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl.html">is_stl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a>.  <a href="structviennacl_1_1is__stl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl_3_01viennacl_1_1tag__stl_01_4.html">is_stl&lt; viennacl::tag_stl &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl.html">is_viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a>.  <a href="structviennacl_1_1is__viennacl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl_3_01viennacl_1_1tag__viennacl_01_4.html">is_viennacl&lt; viennacl::tag_viennacl &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the advanced Cuthill-McKee algorithm.  <a href="classviennacl_1_1advanced__cuthill__mckee__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__range.html">basic_range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A range class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products)  <a href="classviennacl_1_1scalar__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html">scalar_expression&lt; LHS, RHS, op_inner_prod &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for inner products. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_1. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_2. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_inf &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_inf. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__slice.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Toeplitz matrix class.  <a href="classviennacl_1_1toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1entry__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1const__entry__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vandermonde matrix class.  <a href="classviennacl_1_1vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1unit__vector.html">unit_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1unit__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__vector.html">zero_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__vector.html">scalar_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for dense vectors, vector ranges, and vector slices.  <a href="classviennacl_1_1vector__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector.  <a href="classviennacl_1_1vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a> { <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810">MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c">MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03">CUDA_MEMORY</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4dff4cafe5fa26631d5eba96f7bf3646">switch_memory_domain</a> (T &amp;obj, <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> new_mem_domain)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic convenience routine for migrating data of an object to a new memory domain.  <a href="#a4dff4cafe5fa26631d5eba96f7bf3646"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ace26fca8db25244dff843de4ec5dcf1d">memory_domain</a> (T &amp;obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently active memory domain for an object.  <a href="#ace26fca8db25244dff843de4ec5dcf1d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> (std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#aa6eeaec91ef48b6f60c0206f09888163"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a126f2a3b2c6751f234e10999b27f42">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a0a126f2a3b2c6751f234e10999b27f42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad91450296031c933d0131304f388bf1f">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#ad91450296031c933d0131304f388bf1f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae879503909c9b66fad49e8295726dfe5">copy</a> (MATRIXTYPE &amp;com_src, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#ae879503909c9b66fad49e8295726dfe5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1febce45965241500ed60feeaf290dec">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a1febce45965241500ed60feeaf290dec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a582c55682d79f0d548cd30f54412867b">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a582c55682d79f0d548cd30f54412867b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a237f3288335acfa845fcad2915a4def4">copy</a> (const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices.  <a href="#a237f3288335acfa845fcad2915a4def4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac594658b697570a6d4321a157d30bc0f">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#ac594658b697570a6d4321a157d30bc0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a819d66bc1da492c41811de0d4815ea28">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a819d66bc1da492c41811de0d4815ea28"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a22804a43ca1561efd03d0d09d1eb027a">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a22804a43ca1561efd03d0d09d1eb027a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae1fd3c3d02e18c4400901acfa6617a85">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#ae1fd3c3d02e18c4400901acfa6617a85"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3e537294698c05511a1dbb3693e378d6">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a3e537294698c05511a1dbb3693e378d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a381e8b0ba7c993453490de8d40090bdb">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a381e8b0ba7c993453490de8d40090bdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad703586f75e0f4ef42cf61cb1b2d9ef5">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af3332c84c557449850580f50b74d5f8c">copy</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae90a3bfb2d1d49bb356c8f2179a685b0">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ae90a3bfb2d1d49bb356c8f2179a685b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d783c95a46bcb7d01000ae479a03cfc">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a0d783c95a46bcb7d01000ae479a03cfc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a815cf9646ece6cc98ec80b3f925c482d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abfe63ce6ea6eded970702b69279c37fb">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#abfe63ce6ea6eded970702b69279c37fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a34bbc442f25c4e46ced072e438893049">any_cast</a> (<a class="el" href="classviennacl_1_1any.html">any</a> &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a03af48cea9a5fea3198f162b6b9a4eb0">copy</a> (std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#a03af48cea9a5fea3198f162b6b9a4eb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a92dcefda716d015629dbdfcbd1415681">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a92dcefda716d015629dbdfcbd1415681"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac469622b0f544532fc02adc9db80b031">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;han_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#ac469622b0f544532fc02adc9db80b031"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4c68c868aa1def45e1247b6f175ae684">copy</a> (MATRIXTYPE const &amp;com_src, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;han_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a4c68c868aa1def45e1247b6f175ae684"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a62d454e7d9e7b376258fdf34e20e538b">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac8b18ab1f522e27ba87db0da5af465e7">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a692978afc5e0f0654163509c3c519d37">copy</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#a773db2ca4b258b74a575da40fbfda49b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#aa5d425b543da3d12007eb98065137138"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#a36a774cb277f1c9588168775f56a0ebf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#ab30239ae5a61e50989e36802adb29d8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae14e093250df58e8254f94e805c6a4f5">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#ae14e093250df58e8254f94e805c6a4f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9672a2d4e157a13683bc2bbe7d315f15">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#a9672a2d4e157a13683bc2bbe7d315f15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab6e057825e16a810dd49dbb2b46e5e76">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#ab6e057825e16a810dd49dbb2b46e5e76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a934ba52bdd529f4aa5250f9db3225627">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#a934ba52bdd529f4aa5250f9db3225627"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; M1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, <br class="typebreak"/>
const M1, op_trans &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">trans</a> (const M1 &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a2ee5dd77d41040e0a937a60346475b84"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; SCALARTYPE &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a275f283800b5b7db033f94ee8768bbf4">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#a275f283800b5b7db033f94ee8768bbf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; SCALARTYPE &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae46b4c7406da1e0dc2540c43049a0797">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#ae46b4c7406da1e0dc2540c43049a0797"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab85e3912a40d5d479835e7608808f07e">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#ab85e3912a40d5d479835e7608808f07e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5309df539f189a889f45f5e25098930f">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#a5309df539f189a889f45f5e25098930f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af2b7b1aeba8d75ee073974e57d1bf385">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#af2b7b1aeba8d75ee073974e57d1bf385"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a6c1627d47e4b494526e0287de3ed8476"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, op_trans &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250af0917fd1088eb339e3550964954">trans</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a0250af0917fd1088eb339e3550964954"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3728d51018413682b2c807cb26fe0ce6">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#a3728d51018413682b2c807cb26fe0ce6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba57054849e1adf3cd627b22d8512b75">copy</a> (const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#aba57054849e1adf3cd627b22d8512b75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6fe9c1c3ea45c54d92082b1805790e80">fast_copy</a> (SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#a6fe9c1c3ea45c54d92082b1805790e80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad655c8cbb96bf07d2348309a2656799e">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#ad655c8cbb96bf07d2348309a2656799e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aab87e45b79097799bbaabeed1e240ace">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#aab87e45b79097799bbaabeed1e240ace"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a67d05f6ec18b2d7c2051eb4f6b47b5a7">fast_copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::matrix_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab0b04b8d27cc0b0b61dfb5597e584702">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#ab0b04b8d27cc0b0b61dfb5597e584702"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8992f6234065e16e9276dfff541602b6">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9fa036b3f0f44238017a31ad88c80d86">operator+</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5372fd531482dd77aac96fba60b4538f">operator+</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5372fd531482dd77aac96fba60b4538f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S3, OP &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a443dcf4c6c1a880daee9c7386f4b6fdb">operator+</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 + m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#a443dcf4c6c1a880daee9c7386f4b6fdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S2, OP &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, op_add &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5d1fff024f156a58a991d59fd465a507">operator+</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha + m2, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#a5d1fff024f156a58a991d59fd465a507"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a857040281dd174c8ac87528f047d5c0a">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha + m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a857040281dd174c8ac87528f047d5c0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a589ea656a161143b696e4e10283461f3">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a34d0383bb21e7539bd4abe967918dc0c">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a scaled matrix, i.e. m1 += m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a34d0383bb21e7539bd4abe967918dc0c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa33e6eb5ca54fc6763be5c488564eebe">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 +- m3.  <a href="#aa33e6eb5ca54fc6763be5c488564eebe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9148ebbd8fc6c6ba770c9e57ca8c302c">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a9148ebbd8fc6c6ba770c9e57ca8c302c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4da9f947cf67d8eb0ea0244c38d34059">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a4da9f947cf67d8eb0ea0244c38d34059"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aea14a59372ddd475eb821c6a589d4268">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#aea14a59372ddd475eb821c6a589d4268"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a65aa6fc53cb1fffb53cf9874db013eb0">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ade18df55cbc05cd34eef188baf75d0f4">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0c4b121a63ee355f6cf18b56949b51a4">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2c5a85799c2db6530c2f9eeabbb1ef53">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6b7ef92927cd5b04a6d7f5c4150f0512">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4f6de4f40e96f9a18fd52875e8fe8fa0">operator+=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::matrix_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ade34780cdab333f3ec7fa9891575cbb3">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#ade34780cdab333f3ec7fa9891575cbb3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3ee94920320eca8859c6c701a144eec1">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab5d56f1aa9c09f89634e90bdd081dbd5">operator-</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5bf54d540a468ff7b897e5b4d9b8b330">operator-</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5bf54d540a468ff7b897e5b4d9b8b330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S3, OP &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab3937a50a0a176a37c84929bf1cbd1ae">operator-</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 - m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#ab3937a50a0a176a37c84929bf1cbd1ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S2, OP &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, op_sub &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac723ebaf79518ca727079ff5684de9ff">operator-</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha - m2, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#ac723ebaf79518ca727079ff5684de9ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a047d1ad8f03c586d67cdfd52dfc9998a">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha - m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a047d1ad8f03c586d67cdfd52dfc9998a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4c1114da061dab23aeb89e2a3801ca2d">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0347efecac1e4749853a6067c247bfc0">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a scaled matrix, i.e. m1 -= m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a0347efecac1e4749853a6067c247bfc0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9ef187e5bc4a09bff5a3fbf1ebb9ac09">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 +- m3.  <a href="#a9ef187e5bc4a09bff5a3fbf1ebb9ac09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a05d885974dab948d3ccebd63eca79d60">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a05d885974dab948d3ccebd63eca79d60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a55b1051cab786c1642e3be9bf5d8e47a">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a55b1051cab786c1642e3be9bf5d8e47a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a><br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a79aa95be516cd60f5f8c150ca3ac5890">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a79aa95be516cd60f5f8c150ca3ac5890"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a92ebc8a66ef351841c7b7f98e07dbbd7">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a98c6ed5cc7e0ccf8e1c81c535764456c">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4e8e57c6d7a5347efa0e6856969b4fcc">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9664f3c9e1b076a7d3dff4bce7e4648">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac3146800de331cf9d37bc17b595f0c4a">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af69e2a594dbe57b26b362423c99ae15b">operator-=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56">operator*</a> (S1 const &amp;<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix.  <a href="#ac582aeec7eda410e350afb8ee607fa56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a46e86d4d82f9a538bd7c36753f93578b">operator*</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the right.  <a href="#a46e86d4d82f9a538bd7c36753f93578b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1345a355bd88a925ece2c3906f44e7b9">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the left.  <a href="#a1345a355bd88a925ece2c3906f44e7b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a622a198be6623dc648710da7ff66826f">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a GPU scalar 'alpha' and returns an expression template.  <a href="#a622a198be6623dc648710da7ff66826f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a920e8836c8304945668799c249ef35c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f">operator/</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then divided by alpha.  <a href="#ad2770a13264b6b8348e81926cdcb605f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_div &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc8e629b037b3ae3dd4dccf7fd277250">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a GPU scalar 'alpha'.  <a href="#acc8e629b037b3ae3dd4dccf7fd277250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a2949cf07f6b1bb423de3f634d4b49453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9016294abe2bb92b7c6a36110e73bb3e">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a741bc7a80ecd551f3af836b9e760c866">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a975242568e2dcb6cb6acdbfc166b4eb2">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0fd2e7e9bf7ca3ad63ffda64c7b14e2">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad45a6160851a0184c6127de22cc780e6">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a54c4d59831b38159a5cd0444ab891864">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0eb338903a662f132ae1666b962182ff">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a45f058e139f662168f5abcf5671cf450">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; const MatrixType &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">project</a> (MatrixType &amp;A, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af97f37bc5782032f5d48aa7d69e00612">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5dee37834f9f1cf2c2cb530821c5975b">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa423da9ae9241369e204bc22f3f6d4ed">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00d559e0934897588985715f2ac42eb3">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4afe2af2aa2fa3294d77cc2bfb0d6e37">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad843d07ca697041a7bb42656644c7ef9">project</a> (MatrixType &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3a7f5b8c12a1e8b2b5a278173414f330">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad17914cefb71411c1c616c8ca21c4342">project</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a136b17ef33f0f710fdcc6c030b22f497">reorder</a> (MatrixType const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm.  <a href="#a136b17ef33f0f710fdcc6c030b22f497"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a137e2a30657a09f7156fae4bde961a22">reorder</a> (MatrixType const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm.  <a href="#a137e2a30657a09f7156fae4bde961a22"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acec126e71833e0756286cbf8cd036fbd">reorder</a> (MatrixType const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm.  <a href="#acec126e71833e0756286cbf8cd036fbd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeb593bb1abab989d5396c3196ba4ff01">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly print the value of a scalar to an output stream.  <a href="#aeb593bb1abab989d5396c3196ba4ff01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad4143bdeffd1dc0aa102777fb6179747">operator&gt;&gt;</a> (std::istream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly read a value of a scalar from an input stream.  <a href="#ad4143bdeffd1dc0aa102777fb6179747"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af18e0a8b6c0a2fc42090a78158329951">copy</a> (std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#af18e0a8b6c0a2fc42090a78158329951"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa17c5bbb85bd1d93daa7d0767edbf2dd">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#aa17c5bbb85bd1d93daa7d0767edbf2dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a40eb132b8b1293854c1a8f5e9860dbdf">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;tep_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#a40eb132b8b1293854c1a8f5e9860dbdf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9bdaf347b6f7a3c1b0d74d97e103a158">copy</a> (MATRIXTYPE const &amp;com_src, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;tep_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a9bdaf347b6f7a3c1b0d74d97e103a158"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0150a5d176ba2a924ffa44b65287f460">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a0150a5d176ba2a924ffa44b65287f460"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0d83fb04dea07ec903eb82e7fbfa165">copy</a> (std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#ad0d83fb04dea07ec903eb82e7fbfa165"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a384b787fb35e74b44c5c685b7dca6de2">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a384b787fb35e74b44c5c685b7dca6de2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa3f006c00cce616394f6a412be783d24">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#aa3f006c00cce616394f6a412be783d24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a88e7916fee08d3c2f4ac2f334e925f44">copy</a> (MATRIXTYPE &amp;com_src, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a88e7916fee08d3c2f4ac2f334e925f44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af9a32a60b002b21a968695892e5e564b">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#af9a32a60b002b21a968695892e5e564b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a18efe971cc5df1ca97ca63bf7565a8ed">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a18efe971cc5df1ca97ca63bf7565a8ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a592a3a17afda2a630893f43e4a682143">copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a592a3a17afda2a630893f43e4a682143"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a247dbb2faef4f43e89a6ea3c5ebdb028">copy</a> (const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a247dbb2faef4f43e89a6ea3c5ebdb028"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a41d005b9f0d205c14417da3dbdaff0f7">copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a41d005b9f0d205c14417da3dbdaff0f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a19621895b23c45e932e4ce15d947b311">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a19621895b23c45e932e4ce15d947b311"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa38a64c6f9e5764df676c05e5aec3ff8">copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aa38a64c6f9e5764df676c05e5aec3ff8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a932444aaf1651567029ef1618f883d1b">copy</a> (<a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a932444aaf1651567029ef1618f883d1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa5623507e69891c07a96a2036105cf35">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());.  <a href="#aa5623507e69891c07a96a2036105cf35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a64c137c6e59e2a4791600a06447b3ef1">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream. Output format is ublas compatible.  <a href="#a64c137c6e59e2a4791600a06447b3ef1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a70af3a8f39277af306bf3fa8cbfa13d9">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#a49233dc20718f52e98e8b06e9711b375"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d">fast_swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.  <a href="#aa992d7af76c7c4e00d1332041581ba7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7facf74608270e673b7b6fbc189a18e8">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a vector.  <a href="#a7facf74608270e673b7b6fbc189a18e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1c2d2bc3e344790b342a15bfad0a1463">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += v2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a1c2d2bc3e344790b342a15bfad0a1463"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac6030ee2584f89d654404b4e06688786">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += v2 +- v3.  <a href="#ac6030ee2584f89d654404b4e06688786"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8d5d87e8494e2bfbae9eb703cb189ede">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a8d5d87e8494e2bfbae9eb703cb189ede"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a36070c447cb85a93a1f240237d391376">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a36070c447cb85a93a1f240237d391376"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeb202a12ab57dcaa684ff2d5042142f3">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#aeb202a12ab57dcaa684ff2d5042142f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8c70e45d9ff63187aba756147937ae7d">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace subtraction of a vector.  <a href="#a8c70e45d9ff63187aba756147937ae7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a58e7f611b043ca30e4ed1e787ab465a8">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= v2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a58e7f611b043ca30e4ed1e787ab465a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac5e929bc4d126d468c26b53c12847c8c">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= v2 +- v3.  <a href="#ac5e929bc4d126d468c26b53c12847c8c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a38c5f7890a2ec83b5c97013d18c39c04">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a38c5f7890a2ec83b5c97013d18c39c04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa41f60503f12c10a966dd8301605165e">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#aa41f60503f12c10a966dd8301605165e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0b6510c15b44f5b82032a1f85e018ae">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#ad0b6510c15b44f5b82032a1f85e018ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a447eda4887f7373cd9214f7f452aa8ca">operator*=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a447eda4887f7373cd9214f7f452aa8ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5911b2abc96a555d3c20855f645441ac">operator/=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a5911b2abc96a555d3c20855f645441ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5e9bf6c5c16a42f495bfd3d7dd17257c">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of two vector expressions.  <a href="#a5e9bf6c5c16a42f495bfd3d7dd17257c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a95221367a0d8f92d0381b6d2187aae05">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a95221367a0d8f92d0381b6d2187aae05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab76a8502af69ef1290f7ceffb9793d00">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#ab76a8502af69ef1290f7ceffb9793d00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a481ef4ef8c1ac31dd4e217fd6b96ce30">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression v1 @ alpha + v2, where @ denotes either product or division, and alpha is either a CPU or a GPU scalar.  <a href="#a481ef4ef8c1ac31dd4e217fd6b96ce30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, <br class="typebreak"/>
OP2 &gt;, op_add &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac336464bc60f71306e3744a48b09f783">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression v1 @ alpha + v2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#ac336464bc60f71306e3744a48b09f783"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2471d058da27c2588866407382060cc0">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for adding up two vectors, i.e. v1 + v2.  <a href="#a2471d058da27c2588866407382060cc0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a331fa4a57740ba8a084343f667271248">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for adding up two vectors, one being scaled, i.e. v1 + v2 * alpha, where alpha is a CPU or a GPU scalar.  <a href="#a331fa4a57740ba8a084343f667271248"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7a1e1894edebb7f8b0207bec32bfda6b">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of two vector expressions.  <a href="#a7a1e1894edebb7f8b0207bec32bfda6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a303edd7fc2f89bf156aaa1b8ff40ecae">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a303edd7fc2f89bf156aaa1b8ff40ecae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afd93f9d8286afbab1334c082413bfab6">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#afd93f9d8286afbab1334c082413bfab6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae938fcfd01a03e806c8aac20c0792fd6">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression v1 @ alpha - v2, where @ denotes either product or division, and alpha is either a CPU or a GPU scalar.  <a href="#ae938fcfd01a03e806c8aac20c0792fd6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a> <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, <br class="typebreak"/>
OP2 &gt;, op_sub &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9bf7a39a41216e00fc8ca21ebc4b4aed">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression v1 @ alpha - v2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a9bf7a39a41216e00fc8ca21ebc4b4aed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2a0eb807884794e795aec5ec78353a4">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for subtracting two vectors, i.e. v1 - v2.  <a href="#ab2a0eb807884794e795aec5ec78353a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4a1dab1b036689602adfaaa4b3d34c38">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const S2, OP2 &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for subtracting two vectors, one being scaled, i.e. v1 - v2 * alpha, where alpha is a CPU or a GPU scalar.  <a href="#a4a1dab1b036689602adfaaa4b3d34c38"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6d8d71789df177be4cedacd7917848c8">operator*</a> (S1 const &amp;<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector.  <a href="#a6d8d71789df177be4cedacd7917848c8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; RHS &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abaa72495bd583bcfda69157fe91d96d1">operator*</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right.  <a href="#abaa72495bd583bcfda69157fe91d96d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; RHS &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6b89778aa52ade99eaa79ba6cb6661e5">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left.  <a href="#a6b89778aa52ade99eaa79ba6cb6661e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a74ce674a02b729fe8b5cb3c2680540d4">operator*</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by a GPU scalar 'alpha' and returns an expression template.  <a href="#a74ce674a02b729fe8b5cb3c2680540d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; RHS &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a46676b8976492931849cedda0a8b0b7c">operator/</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha.  <a href="#a46676b8976492931849cedda0a8b0b7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, op_div &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a479f8bc932a3b68dbd4716a0766124f9">operator/</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the vector by a GPU scalar 'alpha'.  <a href="#a479f8bc932a3b68dbd4716a0766124f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a647c26aa382ff630071c39ea0f6fc057">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aff87e6c12c0c4774fb92fa88e0c44806">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aff87e6c12c0c4774fb92fa88e0c44806"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4560cc12680fc01551454fc9417fe4a7">copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_range, VectorType &amp;cpu_vector)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7f9afcfdb40091e366e2160d1e47bd2b">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a7f9afcfdb40091e366e2160d1e47bd2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa422ff6bca0f275c38493e68cfb6ab7">project</a> (VectorType &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4abd13449f84ae5f2a83d1ebd144d37f">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0209e9788d17e7af1f69b0c3ca471a4e">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abeabae9f08d37829cb88c5f57671bda7">copy</a> (<a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_slice, VectorType &amp;cpu_vector)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3f562ecf4d6f6591fd3978d857c195b2">project</a> (VectorType &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a282a337b4b56bb137484bae8ac82200a">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0cd756eaf11b7a342d350e569d20c01c">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9d4327108630e688f72f2c135a809a9">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad718fa2d632fcefa865374e0a4094d14"></a><!-- doxytag: member="viennacl::range" ref="ad718fa2d632fcefa865374e0a4094d14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a> <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0242f7747dc5e72cf3265e18287b6b5c"></a><!-- doxytag: member="viennacl::slice" ref="a0242f7747dc5e72cf3265e18287b6b5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a> <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2aeb075792a4f72abdd84b393d41869"></a><!-- doxytag: member="viennacl::vcl_ptrdiff_t" ref="aa2aeb075792a4f72abdd84b393d41869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a151281d5407af580310fed77af40f052"></a><!-- doxytag: member="viennacl::vcl_size_t" ref="a151281d5407af580310fed77af40f052" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107"></a><!-- doxytag: member="viennacl::memory_types" ref="ab1dbe08a5f6601428ce29f686d898107" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810"></a><!-- doxytag: member="MEMORY_NOT_INITIALIZED" ref="ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810" args="" -->MEMORY_NOT_INITIALIZED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c"></a><!-- doxytag: member="MAIN_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c" args="" -->MAIN_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001"></a><!-- doxytag: member="OPENCL_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001" args="" -->OPENCL_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03"></a><!-- doxytag: member="CUDA_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03" args="" -->CUDA_MEMORY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a34bbc442f25c4e46ced072e438893049"></a><!-- doxytag: member="viennacl::any_cast" ref="a34bbc442f25c4e46ced072e438893049" args="(any &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl.html#a34bbc442f25c4e46ced072e438893049">any_cast</a> </td>
          <td>(</td>
          <td class="paramtype">any &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22804a43ca1561efd03d0d09d1eb027a"></a><!-- doxytag: member="viennacl::copy" ref="a22804a43ca1561efd03d0d09d1eb027a" args="(const CPU_MATRIX &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>For the requirements on the CPU_MATRIX type, see the documentation of the function copy(CPU_MATRIX, compressed_matrix&lt;&gt;)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a975242568e2dcb6cb6acdbfc166b4eb2"></a><!-- doxytag: member="viennacl::copy" ref="a975242568e2dcb6cb6acdbfc166b4eb2" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;gpu_matrix_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a647c26aa382ff630071c39ea0f6fc057"></a><!-- doxytag: member="viennacl::copy" ref="a647c26aa382ff630071c39ea0f6fc057" args="(const VectorType &amp;cpu_vector, vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad703586f75e0f4ef42cf61cb1b2d9ef5"></a><!-- doxytag: member="viennacl::copy" ref="ad703586f75e0f4ef42cf61cb1b2d9ef5" args="(const CPU_MATRIX &amp;cpu_matrix, ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8b18ab1f522e27ba87db0da5af465e7"></a><!-- doxytag: member="viennacl::copy" ref="ac8b18ab1f522e27ba87db0da5af465e7" args="(const CPU_MATRIX &amp;cpu_matrix, hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a582c55682d79f0d548cd30f54412867b"></a><!-- doxytag: member="viennacl::copy" ref="a582c55682d79f0d548cd30f54412867b" args="(const CPU_MATRIX &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>There are some type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1()</a> returns the number of rows</li>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4560cc12680fc01551454fc9417fe4a7"></a><!-- doxytag: member="viennacl::copy" ref="a4560cc12680fc01551454fc9417fe4a7" args="(vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_range, VectorType &amp;cpu_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0fd2e7e9bf7ca3ad63ffda64c7b14e2"></a><!-- doxytag: member="viennacl::copy" ref="ad0fd2e7e9bf7ca3ad63ffda64c7b14e2" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;gpu_matrix_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae90a3bfb2d1d49bb356c8f2179a685b0"></a><!-- doxytag: member="viennacl::copy" ref="ae90a3bfb2d1d49bb356c8f2179a685b0" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1fd3c3d02e18c4400901acfa6617a85"></a><!-- doxytag: member="viennacl::copy" ref="ae1fd3c3d02e18c4400901acfa6617a85" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d783c95a46bcb7d01000ae479a03cfc"></a><!-- doxytag: member="viennacl::copy" ref="a0d783c95a46bcb7d01000ae479a03cfc" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu_dest vector must be at least as long as the gpu_src vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9139574d3d99501f0ef6c3fc322e548"></a><!-- doxytag: member="viennacl::copy" ref="ac9139574d3d99501f0ef6c3fc322e548" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e537294698c05511a1dbb3693e378d6"></a><!-- doxytag: member="viennacl::copy" ref="a3e537294698c05511a1dbb3693e378d6" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3332c84c557449850580f50b74d5f8c"></a><!-- doxytag: member="viennacl::copy" ref="af3332c84c557449850580f50b74d5f8c" args="(const ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a237f3288335acfa845fcad2915a4def4"></a><!-- doxytag: member="viennacl::copy" ref="a237f3288335acfa845fcad2915a4def4" args="(const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host using STL types </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0d83fb04dea07ec903eb82e7fbfa165"></a><!-- doxytag: member="viennacl::copy" ref="ad0d83fb04dea07ec903eb82e7fbfa165" args="(std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03af48cea9a5fea3198f162b6b9a4eb0"></a><!-- doxytag: member="viennacl::copy" ref="a03af48cea9a5fea3198f162b6b9a4eb0" args="(std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6eeaec91ef48b6f60c0206f09888163"></a><!-- doxytag: member="viennacl::copy" ref="aa6eeaec91ef48b6f60c0206f09888163" args="(std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad45a6160851a0184c6127de22cc780e6"></a><!-- doxytag: member="viennacl::copy" ref="ad45a6160851a0184c6127de22cc780e6" args="(matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af18e0a8b6c0a2fc42090a78158329951"></a><!-- doxytag: member="viennacl::copy" ref="af18e0a8b6c0a2fc42090a78158329951" args="(std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a384b787fb35e74b44c5c685b7dca6de2"></a><!-- doxytag: member="viennacl::copy" ref="a384b787fb35e74b44c5c685b7dca6de2" args="(vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92dcefda716d015629dbdfcbd1415681"></a><!-- doxytag: member="viennacl::copy" ref="a92dcefda716d015629dbdfcbd1415681" args="(hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a381e8b0ba7c993453490de8d40090bdb"></a><!-- doxytag: member="viennacl::copy" ref="a381e8b0ba7c993453490de8d40090bdb" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a126f2a3b2c6751f234e10999b27f42"></a><!-- doxytag: member="viennacl::copy" ref="a0a126f2a3b2c6751f234e10999b27f42" args="(circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3f006c00cce616394f6a412be783d24"></a><!-- doxytag: member="viennacl::copy" ref="aa3f006c00cce616394f6a412be783d24" args="(vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vander_src</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac469622b0f544532fc02adc9db80b031"></a><!-- doxytag: member="viennacl::copy" ref="ac469622b0f544532fc02adc9db80b031" args="(hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;han_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>han_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">han_src</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad91450296031c933d0131304f388bf1f"></a><!-- doxytag: member="viennacl::copy" ref="ad91450296031c933d0131304f388bf1f" args="(circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">circ_src</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa17c5bbb85bd1d93daa7d0767edbf2dd"></a><!-- doxytag: member="viennacl::copy" ref="aa17c5bbb85bd1d93daa7d0767edbf2dd" args="(toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0209e9788d17e7af1f69b0c3ca471a4e"></a><!-- doxytag: member="viennacl::copy" ref="a0209e9788d17e7af1f69b0c3ca471a4e" args="(const VectorType &amp;cpu_vector, vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a692978afc5e0f0654163509c3c519d37"></a><!-- doxytag: member="viennacl::copy" ref="a692978afc5e0f0654163509c3c519d37" args="(const hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a88e7916fee08d3c2f4ac2f334e925f44"></a><!-- doxytag: member="viennacl::copy" ref="a88e7916fee08d3c2f4ac2f334e925f44" args="(MATRIXTYPE &amp;com_src, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">vander_dst</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c68c868aa1def45e1247b6f175ae684"></a><!-- doxytag: member="viennacl::copy" ref="a4c68c868aa1def45e1247b6f175ae684" args="(MATRIXTYPE const &amp;com_src, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;han_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>han_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">han_dst</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40eb132b8b1293854c1a8f5e9860dbdf"></a><!-- doxytag: member="viennacl::copy" ref="a40eb132b8b1293854c1a8f5e9860dbdf" args="(toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;tep_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tep_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tep_src</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54c4d59831b38159a5cd0444ab891864"></a><!-- doxytag: member="viennacl::copy" ref="a54c4d59831b38159a5cd0444ab891864" args="(matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae879503909c9b66fad49e8295726dfe5"></a><!-- doxytag: member="viennacl::copy" ref="ae879503909c9b66fad49e8295726dfe5" args="(MATRIXTYPE &amp;com_src, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">circ_dst</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abeabae9f08d37829cb88c5f57671bda7"></a><!-- doxytag: member="viennacl::copy" ref="abeabae9f08d37829cb88c5f57671bda7" args="(vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_slice, VectorType &amp;cpu_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9bdaf347b6f7a3c1b0d74d97e103a158"></a><!-- doxytag: member="viennacl::copy" ref="a9bdaf347b6f7a3c1b0d74d97e103a158" args="(MATRIXTYPE const &amp;com_src, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;tep_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>tep_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">tep_dst</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac594658b697570a6d4321a157d30bc0f"></a><!-- doxytag: member="viennacl::copy" ref="ac594658b697570a6d4321a157d30bc0f" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a819d66bc1da492c41811de0d4815ea28"></a><!-- doxytag: member="viennacl::copy" ref="a819d66bc1da492c41811de0d4815ea28" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dee37834f9f1cf2c2cb530821c5975b"></a><!-- doxytag: member="viennacl::copy" ref="a5dee37834f9f1cf2c2cb530821c5975b" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;gpu_matrix_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa423da9ae9241369e204bc22f3f6d4ed"></a><!-- doxytag: member="viennacl::copy" ref="aa423da9ae9241369e204bc22f3f6d4ed" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;gpu_matrix_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a00d559e0934897588985715f2ac42eb3"></a><!-- doxytag: member="viennacl::copy" ref="a00d559e0934897588985715f2ac42eb3" args="(matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4afe2af2aa2fa3294d77cc2bfb0d6e37"></a><!-- doxytag: member="viennacl::copy" ref="a4afe2af2aa2fa3294d77cc2bfb0d6e37" args="(matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3728d51018413682b2c807cb26fe0ce6"></a><!-- doxytag: member="viennacl::copy" ref="a3728d51018413682b2c807cb26fe0ce6" args="(const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host. Type requirements: .<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1()</a> returns number of rows, .<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns number of columns. Access to entries via operator() </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba57054849e1adf3cd627b22d8512b75"></a><!-- doxytag: member="viennacl::copy" ref="aba57054849e1adf3cd627b22d8512b75" args="(const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host of type std::vector&lt; std::vector&lt;&gt; &gt;. cpu_matrix[i][j] returns the element in the i-th row and j-th columns (both starting with zero) </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad655c8cbb96bf07d2348309a2656799e"></a><!-- doxytag: member="viennacl::copy" ref="ad655c8cbb96bf07d2348309a2656799e" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host. Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab87e45b79097799bbaabeed1e240ace"></a><!-- doxytag: member="viennacl::copy" ref="aab87e45b79097799bbaabeed1e240ace" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host using STL types, typically std::vector&lt; std::vector&lt;&gt; &gt; Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a592a3a17afda2a630893f43e4a682143"></a><!-- doxytag: member="viennacl::copy" ref="a592a3a17afda2a630893f43e4a682143" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU constant iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU constant iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a247dbb2faef4f43e89a6ea3c5ebdb028"></a><!-- doxytag: member="viennacl::copy" ref="a247dbb2faef4f43e89a6ea3c5ebdb028" args="(const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41d005b9f0d205c14417da3dbdaff0f7"></a><!-- doxytag: member="viennacl::copy" ref="a41d005b9f0d205c14417da3dbdaff0f7" args="(vector_base&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa38a64c6f9e5764df676c05e5aec3ff8"></a><!-- doxytag: member="viennacl::copy" ref="aa38a64c6f9e5764df676c05e5aec3ff8" args="(const CPUVECTOR &amp;cpu_vec, vector_base&lt; T &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a932444aaf1651567029ef1618f883d1b"></a><!-- doxytag: member="viennacl::copy" ref="a932444aaf1651567029ef1618f883d1b" args="(vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5623507e69891c07a96a2036105cf35"></a><!-- doxytag: member="viennacl::copy" ref="aa5623507e69891c07a96a2036105cf35" args="(vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_dest_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">gpu_dest_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff87e6c12c0c4774fb92fa88e0c44806"></a><!-- doxytag: member="viennacl::fast_copy" ref="aff87e6c12c0c4774fb92fa88e0c44806" args="(const CPUVECTOR &amp;cpu_vec, vector_range&lt; VectorType &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f9afcfdb40091e366e2160d1e47bd2b"></a><!-- doxytag: member="viennacl::fast_copy" ref="a7f9afcfdb40091e366e2160d1e47bd2b" args="(vector_range&lt; VectorType &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector range. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a815cf9646ece6cc98ec80b3f925c482d"></a><!-- doxytag: member="viennacl::fast_copy" ref="a815cf9646ece6cc98ec80b3f925c482d" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly written to the cpu vector, starting with &amp;(*cpu.begin()) However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfe63ce6ea6eded970702b69279c37fb"></a><!-- doxytag: member="viennacl::fast_copy" ref="abfe63ce6ea6eded970702b69279c37fb" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly read from the cpu vector, starting with &amp;(*cpu.begin()). However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fe9c1c3ea45c54d92082b1805790e80"></a><!-- doxytag: member="viennacl::fast_copy" ref="a6fe9c1c3ea45c54d92082b1805790e80" args="(SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the first matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">cpu_matrix_end</td><td>Pointer past the last matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><!-- doxytag: member="viennacl::fast_copy" ref="a67d05f6ec18b2d7c2051eb4f6b47b5a7" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the output memory on the CPU. User must ensure that provided memory is large enough. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18efe971cc5df1ca97ca63bf7565a8ed"></a><!-- doxytag: member="viennacl::fast_copy" ref="a18efe971cc5df1ca97ca63bf7565a8ed" args="(vector_base&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19621895b23c45e932e4ce15d947b311"></a><!-- doxytag: member="viennacl::fast_copy" ref="a19621895b23c45e932e4ce15d947b311" args="(const CPUVECTOR &amp;cpu_vec, vector_base&lt; NumericT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa992d7af76c7c4e00d1332041581ba7d"></a><!-- doxytag: member="viennacl::fast_swap" ref="aa992d7af76c7c4e00d1332041581ba7d" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; <a class="el" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d">viennacl::fast_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace26fca8db25244dff843de4ec5dcf1d"></a><!-- doxytag: member="viennacl::memory_domain" ref="ace26fca8db25244dff843de4ec5dcf1d" args="(T &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> <a class="el" href="namespaceviennacl.html#ace26fca8db25244dff843de4ec5dcf1d">viennacl::memory_domain</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the currently active memory domain for an object. </p>

</div>
</div>
<a class="anchor" id="ac582aeec7eda410e350afb8ee607fa56"></a><!-- doxytag: member="viennacl::operator*" ref="ac582aeec7eda410e350afb8ee607fa56" args="(S1 const &amp;value, matrix_base&lt; NumericT, F &gt; const &amp;m1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, op_prod&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">m1</td><td>A ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46e86d4d82f9a538bd7c36753f93578b"></a><!-- doxytag: member="viennacl::operator*" ref="a46e86d4d82f9a538bd7c36753f93578b" args="(matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1345a355bd88a925ece2c3906f44e7b9"></a><!-- doxytag: member="viennacl::operator*" ref="a1345a355bd88a925ece2c3906f44e7b9" args="(S1 const &amp;val, matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a622a198be6623dc648710da7ff66826f"></a><!-- doxytag: member="viennacl::operator*" ref="a622a198be6623dc648710da7ff66826f" args="(matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, op_prod&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the matrix by a GPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a9016294abe2bb92b7c6a36110e73bb3e"></a><!-- doxytag: member="viennacl::operator*" ref="a9016294abe2bb92b7c6a36110e73bb3e" args="(const viennacl::matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy, const S1 &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt;, const NumericT, op_prod &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a741bc7a80ecd551f3af836b9e760c866"></a><!-- doxytag: member="viennacl::operator*" ref="a741bc7a80ecd551f3af836b9e760c866" args="(const S1 &amp;val, const viennacl::matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, op_prod &gt;, const NumericT, op_prod &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d8d71789df177be4cedacd7917848c8"></a><!-- doxytag: member="viennacl::operator*" ref="a6d8d71789df177be4cedacd7917848c8" args="(S1 const &amp;value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, op_prod&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abaa72495bd583bcfda69157fe91d96d1"></a><!-- doxytag: member="viennacl::operator*" ref="abaa72495bd583bcfda69157fe91d96d1" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;RHS&gt;::type&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b89778aa52ade99eaa79ba6cb6661e5"></a><!-- doxytag: member="viennacl::operator*" ref="a6b89778aa52ade99eaa79ba6cb6661e5" args="(S1 const &amp;val, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;RHS&gt;::type&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74ce674a02b729fe8b5cb3c2680540d4"></a><!-- doxytag: member="viennacl::operator*" ref="a74ce674a02b729fe8b5cb3c2680540d4" args="(vector_base&lt; T &gt; const &amp;v1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, op_prod&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a GPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a920e8836c8304945668799c249ef35c4"></a><!-- doxytag: member="viennacl::operator*=" ref="a920e8836c8304945668799c249ef35c4" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a447eda4887f7373cd9214f7f452aa8ca"></a><!-- doxytag: member="viennacl::operator*=" ref="a447eda4887f7373cd9214f7f452aa8ca" args="(vector_base&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp; &gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="ab85e3912a40d5d479835e7608808f07e"></a><!-- doxytag: member="viennacl::operator+" ref="ab85e3912a40d5d479835e7608808f07e" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class holding v1, A, and v2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36a774cb277f1c9588168775f56a0ebf"></a><!-- doxytag: member="viennacl::operator+" ref="a36a774cb277f1c9588168775f56a0ebf" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;NumericT&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6e057825e16a810dd49dbb2b46e5e76"></a><!-- doxytag: member="viennacl::operator+" ref="ab6e057825e16a810dd49dbb2b46e5e76" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0b04b8d27cc0b0b61dfb5597e584702"></a><!-- doxytag: member="viennacl::operator+" ref="ab0b04b8d27cc0b0b61dfb5597e584702" args="(matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1&gt;::matrix_type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep. </p>

</div>
</div>
<a class="anchor" id="a8992f6234065e16e9276dfff541602b6"></a><!-- doxytag: member="viennacl::operator+" ref="a8992f6234065e16e9276dfff541602b6" args="(matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fa036b3f0f44238017a31ad88c80d86"></a><!-- doxytag: member="viennacl::operator+" ref="a9fa036b3f0f44238017a31ad88c80d86" args="(matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5372fd531482dd77aac96fba60b4538f"></a><!-- doxytag: member="viennacl::operator+" ref="a5372fd531482dd77aac96fba60b4538f" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, op_add &gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

</div>
</div>
<a class="anchor" id="a443dcf4c6c1a880daee9c7386f4b6fdb"></a><!-- doxytag: member="viennacl::operator+" ref="a443dcf4c6c1a880daee9c7386f4b6fdb" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S3, OP&gt;, op_add &gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 + m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a5d1fff024f156a58a991d59fd465a507"></a><!-- doxytag: member="viennacl::operator+" ref="a5d1fff024f156a58a991d59fd465a507" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const matrix_base&lt; NumericT, F &gt; &amp;m3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S2, OP&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, op_add &gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 @ alpha + m2, where @ is either product or division, and beta is either a CPU or GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a857040281dd174c8ac87528f047d5c0a"></a><!-- doxytag: member="viennacl::operator+" ref="a857040281dd174c8ac87528f047d5c0a" args="(matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S2, OP2&gt;, op_add&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 @ alpha + m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e9bf6c5c16a42f495bfd3d7dd17257c"></a><!-- doxytag: member="viennacl::operator+" ref="a5e9bf6c5c16a42f495bfd3d7dd17257c" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of two vector expressions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95221367a0d8f92d0381b6d2187aae05"></a><!-- doxytag: member="viennacl::operator+" ref="a95221367a0d8f92d0381b6d2187aae05" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab76a8502af69ef1290f7ceffb9793d00"></a><!-- doxytag: member="viennacl::operator+" ref="ab76a8502af69ef1290f7ceffb9793d00" args="(vector_base&lt; T &gt; const &amp;vec, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481ef4ef8c1ac31dd4e217fd6b96ce30"></a><!-- doxytag: member="viennacl::operator+" ref="a481ef4ef8c1ac31dd4e217fd6b96ce30" args="(vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, op_add&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression v1 @ alpha + v2, where @ denotes either product or division, and alpha is either a CPU or a GPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac336464bc60f71306e3744a48b09f783"></a><!-- doxytag: member="viennacl::operator+" ref="ac336464bc60f71306e3744a48b09f783" args="(vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;lhs, vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S2, OP2&gt;, op_add&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression v1 @ alpha + v2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side addend v1 @ alpha </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side addend v2 @ beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2471d058da27c2588866407382060cc0"></a><!-- doxytag: member="viennacl::operator+" ref="a2471d058da27c2588866407382060cc0" args="(const vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, op_add&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for adding up two vectors, i.e. v1 + v2. </p>

</div>
</div>
<a class="anchor" id="a331fa4a57740ba8a084343f667271248"></a><!-- doxytag: member="viennacl::operator+" ref="a331fa4a57740ba8a084343f667271248" args="(const vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S2, OP2&gt;, op_add&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for adding up two vectors, one being scaled, i.e. v1 + v2 * alpha, where alpha is a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a275f283800b5b7db033f94ee8768bbf4"></a><!-- doxytag: member="viennacl::operator+=" ref="a275f283800b5b7db033f94ee8768bbf4" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;SCALARTYPE&gt; &amp; &gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result vector v1 </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a773db2ca4b258b74a575da40fbfda49b"></a><!-- doxytag: member="viennacl::operator+=" ref="a773db2ca4b258b74a575da40fbfda49b" args="(vector_base&lt; NumericT &gt; &amp;v1, const viennacl::vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae14e093250df58e8254f94e805c6a4f5"></a><!-- doxytag: member="viennacl::operator+=" ref="ae14e093250df58e8254f94e805c6a4f5" args="(vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a589ea656a161143b696e4e10283461f3"></a><!-- doxytag: member="viennacl::operator+=" ref="a589ea656a161143b696e4e10283461f3" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a34d0383bb21e7539bd4abe967918dc0c"></a><!-- doxytag: member="viennacl::operator+=" ref="a34d0383bb21e7539bd4abe967918dc0c" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled matrix, i.e. m1 += m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="aa33e6eb5ca54fc6763be5c488564eebe"></a><!-- doxytag: member="viennacl::operator+=" ref="aa33e6eb5ca54fc6763be5c488564eebe" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 += m2 +- m3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 +- m3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9148ebbd8fc6c6ba770c9e57ca8c302c"></a><!-- doxytag: member="viennacl::operator+=" ref="a9148ebbd8fc6c6ba770c9e57ca8c302c" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 += m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 +- m3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4da9f947cf67d8eb0ea0244c38d34059"></a><!-- doxytag: member="viennacl::operator+=" ref="a4da9f947cf67d8eb0ea0244c38d34059" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 += m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 @ alpha +- m3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea14a59372ddd475eb821c6a589d4268"></a><!-- doxytag: member="viennacl::operator+=" ref="aea14a59372ddd475eb821c6a589d4268" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 += m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 @ alpha +- m3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65aa6fc53cb1fffb53cf9874db013eb0"></a><!-- doxytag: member="viennacl::operator+=" ref="a65aa6fc53cb1fffb53cf9874db013eb0" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade18df55cbc05cd34eef188baf75d0f4"></a><!-- doxytag: member="viennacl::operator+=" ref="ade18df55cbc05cd34eef188baf75d0f4" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c4b121a63ee355f6cf18b56949b51a4"></a><!-- doxytag: member="viennacl::operator+=" ref="a0c4b121a63ee355f6cf18b56949b51a4" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c5a85799c2db6530c2f9eeabbb1ef53"></a><!-- doxytag: member="viennacl::operator+=" ref="a2c5a85799c2db6530c2f9eeabbb1ef53" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b7ef92927cd5b04a6d7f5c4150f0512"></a><!-- doxytag: member="viennacl::operator+=" ref="a6b7ef92927cd5b04a6d7f5c4150f0512" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f6de4f40e96f9a18fd52875e8fe8fa0"></a><!-- doxytag: member="viennacl::operator+=" ref="a4f6de4f40e96f9a18fd52875e8fe8fa0" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7facf74608270e673b7b6fbc189a18e8"></a><!-- doxytag: member="viennacl::operator+=" ref="a7facf74608270e673b7b6fbc189a18e8" args="(vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a vector. </p>

</div>
</div>
<a class="anchor" id="a1c2d2bc3e344790b342a15bfad0a1463"></a><!-- doxytag: member="viennacl::operator+=" ref="a1c2d2bc3e344790b342a15bfad0a1463" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += v2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="ac6030ee2584f89d654404b4e06688786"></a><!-- doxytag: member="viennacl::operator+=" ref="ac6030ee2584f89d654404b4e06688786" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += v2 +- v3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 +- v3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d5d87e8494e2bfbae9eb703cb189ede"></a><!-- doxytag: member="viennacl::operator+=" ref="a8d5d87e8494e2bfbae9eb703cb189ede" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 +- v3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36070c447cb85a93a1f240237d391376"></a><!-- doxytag: member="viennacl::operator+=" ref="a36070c447cb85a93a1f240237d391376" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 @ alpha +- v3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb202a12ab57dcaa684ff2d5042142f3"></a><!-- doxytag: member="viennacl::operator+=" ref="aeb202a12ab57dcaa684ff2d5042142f3" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 @ alpha +- v3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5309df539f189a889f45f5e25098930f"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a5309df539f189a889f45f5e25098930f" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab30239ae5a61e50989e36802adb29d8f"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab30239ae5a61e50989e36802adb29d8f" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;NumericT&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a934ba52bdd529f4aa5250f9db3225627"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a934ba52bdd529f4aa5250f9db3225627" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade34780cdab333f3ec7fa9891575cbb3"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ade34780cdab333f3ec7fa9891575cbb3" args="(matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS1, RHS1, OP1&gt;::matrix_type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep. </p>

</div>
</div>
<a class="anchor" id="a3ee94920320eca8859c6c701a144eec1"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a3ee94920320eca8859c6c701a144eec1" args="(matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5d56f1aa9c09f89634e90bdd081dbd5"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab5d56f1aa9c09f89634e90bdd081dbd5" args="(matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;NumericT, F&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bf54d540a468ff7b897e5b4d9b8b330"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a5bf54d540a468ff7b897e5b4d9b8b330" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, op_sub &gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

</div>
</div>
<a class="anchor" id="ab3937a50a0a176a37c84929bf1cbd1ae"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab3937a50a0a176a37c84929bf1cbd1ae" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S3, OP&gt;, op_sub &gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 - m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar. </p>

</div>
</div>
<a class="anchor" id="ac723ebaf79518ca727079ff5684de9ff"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ac723ebaf79518ca727079ff5684de9ff" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const matrix_base&lt; NumericT, F &gt; &amp;m3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S2, OP&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, op_sub &gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 @ alpha - m2, where @ is either product or division, and beta is either a CPU or GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a047d1ad8f03c586d67cdfd52dfc9998a"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a047d1ad8f03c586d67cdfd52dfc9998a" args="(matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S2, OP2&gt;, op_sub&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a matrix expression m1 @ alpha - m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a1e1894edebb7f8b0207bec32bfda6b"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a7a1e1894edebb7f8b0207bec32bfda6b" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of two vector expressions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a303edd7fc2f89bf156aaa1b8ff40ecae"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a303edd7fc2f89bf156aaa1b8ff40ecae" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd93f9d8286afbab1334c082413bfab6"></a><!-- doxytag: member="viennacl::operator&#45;" ref="afd93f9d8286afbab1334c082413bfab6" args="(vector_base&lt; T &gt; const &amp;vec, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;T&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae938fcfd01a03e806c8aac20c0792fd6"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ae938fcfd01a03e806c8aac20c0792fd6" args="(vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, op_sub&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression v1 @ alpha - v2, where @ denotes either product or division, and alpha is either a CPU or a GPU scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf7a39a41216e00fc8ca21ebc4b4aed"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a9bf7a39a41216e00fc8ca21ebc4b4aed" args="(vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;lhs, vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S2, OP2&gt;, op_sub&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression v1 @ alpha - v2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side addend v1 @ alpha </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side addend v2 @ beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2a0eb807884794e795aec5ec78353a4"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab2a0eb807884794e795aec5ec78353a4" args="(const vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, op_sub&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for subtracting two vectors, i.e. v1 - v2. </p>

</div>
</div>
<a class="anchor" id="a4a1dab1b036689602adfaaa4b3d34c38"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a4a1dab1b036689602adfaaa4b3d34c38" args="(const vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S2, OP2&gt;, op_sub&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for subtracting two vectors, one being scaled, i.e. v1 - v2 * alpha, where alpha is a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="ae46b4c7406da1e0dc2540c43049a0797"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="ae46b4c7406da1e0dc2540c43049a0797" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;SCALARTYPE&gt; &amp; &gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result vector v1 </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5d425b543da3d12007eb98065137138"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="aa5d425b543da3d12007eb98065137138" args="(vector_base&lt; NumericT &gt; &amp;v1, const viennacl::vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9672a2d4e157a13683bc2bbe7d315f15"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a9672a2d4e157a13683bc2bbe7d315f15" args="(vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c1114da061dab23aeb89e2a3801ca2d"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a4c1114da061dab23aeb89e2a3801ca2d" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0347efecac1e4749853a6067c247bfc0"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a0347efecac1e4749853a6067c247bfc0" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled matrix, i.e. m1 -= m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a9ef187e5bc4a09bff5a3fbf1ebb9ac09"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a9ef187e5bc4a09bff5a3fbf1ebb9ac09" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 -= m2 +- m3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 +- m3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05d885974dab948d3ccebd63eca79d60"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a05d885974dab948d3ccebd63eca79d60" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 -= m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 +- m3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55b1051cab786c1642e3be9bf5d8e47a"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a55b1051cab786c1642e3be9bf5d8e47a" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 -= m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 @ alpha +- m3 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79aa95be516cd60f5f8c150ca3ac5890"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a79aa95be516cd60f5f8c150ca3ac5890" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation m1 -= m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The result matrix where m2 @ alpha +- m3 @ beta is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92ebc8a66ef351841c7b7f98e07dbbd7"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a92ebc8a66ef351841c7b7f98e07dbbd7" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98c6ed5cc7e0ccf8e1c81c535764456c"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a98c6ed5cc7e0ccf8e1c81c535764456c" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e8e57c6d7a5347efa0e6856969b4fcc"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a4e8e57c6d7a5347efa0e6856969b4fcc" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c70e45d9ff63187aba756147937ae7d"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a8c70e45d9ff63187aba756147937ae7d" args="(vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a vector. </p>

</div>
</div>
<a class="anchor" id="ac9664f3c9e1b076a7d3dff4bce7e4648"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="ac9664f3c9e1b076a7d3dff4bce7e4648" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58e7f611b043ca30e4ed1e787ab465a8"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a58e7f611b043ca30e4ed1e787ab465a8" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= v2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="ac3146800de331cf9d37bc17b595f0c4a"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="ac3146800de331cf9d37bc17b595f0c4a" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5e929bc4d126d468c26b53c12847c8c"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="ac5e929bc4d126d468c26b53c12847c8c" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= v2 +- v3. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 +- v3 is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af69e2a594dbe57b26b362423c99ae15b"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="af69e2a594dbe57b26b362423c99ae15b" args="(matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F1&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38c5f7890a2ec83b5c97013d18c39c04"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a38c5f7890a2ec83b5c97013d18c39c04" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_base&lt; T &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_base&lt; T &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= v2 +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 +- v3 @ beta is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41f60503f12c10a966dd8301605165e"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="aa41f60503f12c10a966dd8301605165e" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_base&lt; T &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= v2 @ alpha +- v3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 @ alpha +- v3 is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0b6510c15b44f5b82032a1f85e018ae"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="ad0b6510c15b44f5b82032a1f85e018ae" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP2&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> &amp;&amp; (<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a>&lt;OP3&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>) &amp;&amp; (<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a> || <a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a>&lt;OP&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>), <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const vector_expression&lt; const vector_base&lt; T &gt;, const S2, OP2 &gt;, const vector_expression&lt; const vector_base&lt; T &gt;, const S3, OP3 &gt;, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= v2 @ alpha +- v3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector where v2 @ alpha +- v3 @ beta is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2770a13264b6b8348e81926cdcb605f"></a><!-- doxytag: member="viennacl::operator/" ref="ad2770a13264b6b8348e81926cdcb605f" args="(matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, typename <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;::matrix_type &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then divided by alpha. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8e629b037b3ae3dd4dccf7fd277250"></a><!-- doxytag: member="viennacl::operator/" ref="acc8e629b037b3ae3dd4dccf7fd277250" args="(matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, op_div&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template for scaling the matrix by a GPU scalar 'alpha'. </p>

</div>
</div>
<a class="anchor" id="a46676b8976492931849cedda0a8b0b7c"></a><!-- doxytag: member="viennacl::operator/" ref="a46676b8976492931849cedda0a8b0b7c" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;RHS&gt;::type&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a479f8bc932a3b68dbd4716a0766124f9"></a><!-- doxytag: member="viennacl::operator/" ref="a479f8bc932a3b68dbd4716a0766124f9" args="(vector_base&lt; T &gt; const &amp;v1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, op_div&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template for scaling the vector by a GPU scalar 'alpha'. </p>

</div>
</div>
<a class="anchor" id="a5911b2abc96a555d3c20855f645441ac"></a><!-- doxytag: member="viennacl::operator/=" ref="a5911b2abc96a555d3c20855f645441ac" args="(vector_base&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp; &gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a2949cf07f6b1bb423de3f634d4b49453"></a><!-- doxytag: member="viennacl::operator/=" ref="a2949cf07f6b1bb423de3f634d4b49453" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="af9a32a60b002b21a968695892e5e564b"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="af9a32a60b002b21a968695892e5e564b" args="(std::ostream &amp;s, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Vandermonde matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62d454e7d9e7b376258fdf34e20e538b"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a62d454e7d9e7b376258fdf34e20e538b" args="(std::ostream &amp;s, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1febce45965241500ed60feeaf290dec"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a1febce45965241500ed60feeaf290dec" args="(std::ostream &amp;s, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL circulant matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eb338903a662f132ae1666b962182ff"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a0eb338903a662f132ae1666b962182ff" args="(std::ostream &amp;s, matrix_range&lt; MatrixType &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45f058e139f662168f5abcf5671cf450"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a45f058e139f662168f5abcf5671cf450" args="(std::ostream &amp;s, matrix_range&lt; const MatrixType &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; const MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0150a5d176ba2a924ffa44b65287f460"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a0150a5d176ba2a924ffa44b65287f460" args="(std::ostream &amp;s, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Toeplitz matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb593bb1abab989d5396c3196ba4ff01"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="aeb593bb1abab989d5396c3196ba4ff01" args="(std::ostream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly print the value of a scalar to an output stream. </p>

</div>
</div>
<a class="anchor" id="af2b7b1aeba8d75ee073974e57d1bf385"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="af2b7b1aeba8d75ee073974e57d1bf385" args="(std::ostream &amp;s, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c1627d47e4b494526e0287de3ed8476"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a6c1627d47e4b494526e0287de3ed8476" args="(std::ostream &amp;s, const matrix_expression&lt; LHS, RHS, OP &gt; &amp;expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; LHS, RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">expr</td><td>A matrix expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64c137c6e59e2a4791600a06447b3ef1"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a64c137c6e59e2a4791600a06447b3ef1" args="(std::ostream &amp;s, vector_base&lt; T &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream. Output format is ublas compatible. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">val</td><td>The vector that should be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70af3a8f39277af306bf3fa8cbfa13d9"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a70af3a8f39277af306bf3fa8cbfa13d9" args="(std::ostream &amp;s, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4143bdeffd1dc0aa102777fb6179747"></a><!-- doxytag: member="viennacl::operator&gt;&gt;" ref="ad4143bdeffd1dc0aa102777fb6179747" args="(std::istream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; viennacl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly read a value of a scalar from an input stream. </p>

</div>
</div>
<a class="anchor" id="aaa422ff6bca0f275c38493e68cfb6ab7"></a><!-- doxytag: member="viennacl::project" ref="aaa422ff6bca0f275c38493e68cfb6ab7" args="(VectorType &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4abd13449f84ae5f2a83d1ebd144d37f"></a><!-- doxytag: member="viennacl::project" ref="a4abd13449f84ae5f2a83d1ebd144d37f" args="(viennacl::vector_range&lt; VectorType &gt; &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f562ecf4d6f6591fd3978d857c195b2"></a><!-- doxytag: member="viennacl::project" ref="a3f562ecf4d6f6591fd3978d857c195b2" args="(VectorType &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a282a337b4b56bb137484bae8ac82200a"></a><!-- doxytag: member="viennacl::project" ref="a282a337b4b56bb137484bae8ac82200a" args="(viennacl::vector_slice&lt; VectorType &gt; &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cd756eaf11b7a342d350e569d20c01c"></a><!-- doxytag: member="viennacl::project" ref="a0cd756eaf11b7a342d350e569d20c01c" args="(viennacl::vector_slice&lt; VectorType &gt; &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9d4327108630e688f72f2c135a809a9"></a><!-- doxytag: member="viennacl::project" ref="ac9d4327108630e688f72f2c135a809a9" args="(viennacl::vector_range&lt; VectorType &gt; &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba33e920e51c7697bb559ff3eade9019"></a><!-- doxytag: member="viennacl::project" ref="aba33e920e51c7697bb559ff3eade9019" args="(MatrixType &amp;A, viennacl::range const &amp;r1, viennacl::range const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af97f37bc5782032f5d48aa7d69e00612"></a><!-- doxytag: member="viennacl::project" ref="af97f37bc5782032f5d48aa7d69e00612" args="(matrix_range&lt; MatrixType &gt; &amp;A, viennacl::range const &amp;r1, viennacl::range const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad843d07ca697041a7bb42656644c7ef9"></a><!-- doxytag: member="viennacl::project" ref="ad843d07ca697041a7bb42656644c7ef9" args="(MatrixType &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a7f5b8c12a1e8b2b5a278173414f330"></a><!-- doxytag: member="viennacl::project" ref="a3a7f5b8c12a1e8b2b5a278173414f330" args="(matrix_range&lt; MatrixType &gt; &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad17914cefb71411c1c616c8ca21c4342"></a><!-- doxytag: member="viennacl::project" ref="ad17914cefb71411c1c616c8ca21c4342" args="(matrix_slice&lt; MatrixType &gt; &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acec126e71833e0756286cbf8cd036fbd"></a><!-- doxytag: member="viennacl::reorder" ref="acec126e71833e0756286cbf8cd036fbd" args="(MatrixType const &amp;matrix, gibbs_poole_stockmeyer_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="namespaceviennacl.html#a136b17ef33f0f710fdcc6c030b22f497">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gibbs_poole_stockmeyer_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm. </p>
<p>references: Werner Neudorf: "Bandbreitenreduktion - Teil 3. Algorithmus von 
   Gibbs-Poole-Stockmeyer. Testbeispiele mit CM und GPS", Preprint No. M 08/02, September 2002. Technische Universitt Ilmenau, Fakultt fr Mathematik und Naturwissenschaften, Institut fr Mathematik. <a href="http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf">http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf</a> (URL taken on June 14, 2011)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>

</div>
</div>
<a class="anchor" id="a136b17ef33f0f710fdcc6c030b22f497"></a><!-- doxytag: member="viennacl::reorder" ref="a136b17ef33f0f710fdcc6c030b22f497" args="(MatrixType const &amp;matrix, cuthill_mckee_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="namespaceviennacl.html#a136b17ef33f0f710fdcc6c030b22f497">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cuthill_mckee_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm. </p>
<p>references: Algorithm was implemented similary as described in "Tutorial: Bandwidth Reduction - The CutHill-
      McKee Algorithm" posted by Ciprian Zavoianu as weblog at <a href="http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html">http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html</a> on January 15, 2009 (URL taken on June 14, 2011)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>

</div>
</div>
<a class="anchor" id="a137e2a30657a09f7156fae4bde961a22"></a><!-- doxytag: member="viennacl::reorder" ref="a137e2a30657a09f7156fae4bde961a22" args="(MatrixType const &amp;matrix, advanced_cuthill_mckee_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="namespaceviennacl.html#a136b17ef33f0f710fdcc6c030b22f497">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">advanced_cuthill_mckee_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm. </p>
<p>references: see description of original Cuthill McKee implementation, and E. Cuthill and J. McKee: "Reducing the Bandwidth of sparse symmetric Matrices". Naval Ship Research and Development Center, Washington, D. C., 20007 </p>

</div>
</div>
<a class="anchor" id="a49233dc20718f52e98e8b06e9711b375"></a><!-- doxytag: member="viennacl::swap" ref="a49233dc20718f52e98e8b06e9711b375" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">viennacl::swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dff4cafe5fa26631d5eba96f7bf3646"></a><!-- doxytag: member="viennacl::switch_memory_domain" ref="a4dff4cafe5fa26631d5eba96f7bf3646" args="(T &amp;obj, viennacl::memory_types new_mem_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a4dff4cafe5fa26631d5eba96f7bf3646">viennacl::switch_memory_domain</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a>&#160;</td>
          <td class="paramname"><em>new_mem_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic convenience routine for migrating data of an object to a new memory domain. </p>

</div>
</div>
<a class="anchor" id="a2ee5dd77d41040e0a937a60346475b84"></a><!-- doxytag: member="viennacl::trans" ref="a2ee5dd77d41040e0a937a60346475b84" args="(const M1 &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt;<a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;M1&gt;::<a class="el" href="classviennacl_1_1value.html">value</a>, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, const M1, op_trans&gt; &gt;::type <a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">viennacl::trans</a> </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
<a class="anchor" id="a0250af0917fd1088eb339e3550964954"></a><!-- doxytag: member="viennacl::trans" ref="a0250af0917fd1088eb339e3550964954" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, op_trans&gt; <a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">viennacl::trans</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
