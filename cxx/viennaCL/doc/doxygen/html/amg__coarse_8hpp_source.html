<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/linalg/detail/amg/amg_coarse.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/linalg/detail/amg/amg_coarse.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="amg__coarse_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_LINALG_DETAIL_AMG_AMG_COARSE_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_LINALG_DETAIL_AMG_AMG_COARSE_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2013, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment">               </span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="amg_8hpp.html" title="Main include file for algebraic multigrid (AMG) preconditioners. Experimental.">viennacl/linalg/amg.hpp</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;omp.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="amg__debug_8hpp.html" title="Debug functionality for AMG. To be removed.">amg_debug.hpp</a>&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>viennacl
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <span class="keyword">namespace </span>linalg
<a name="l00038"></a>00038   {    
<a name="l00039"></a>00039     <span class="keyword">namespace </span>detail
<a name="l00040"></a>00040     {
<a name="l00041"></a>00041       <span class="keyword">namespace </span>amg
<a name="l00042"></a>00042       {
<a name="l00043"></a>00043     
<a name="l00051"></a>00051     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2, <span class="keyword">typename</span> InternalType3&gt;
<a name="l00052"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aaa22393247286cb21368d367e9b78462">00052</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aaa22393247286cb21368d367e9b78462" title="Calls the right coarsening procedure.">amg_coarse</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, InternalType3 &amp; Slicing, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054       <span class="keywordflow">switch</span> (tag.<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html#a63b394fe6c69226d5ea568cbb482f9fe">get_coarse</a>())
<a name="l00055"></a>00055       {
<a name="l00056"></a>00056         <span class="keywordflow">case</span> <a class="code" href="amg__base_8hpp.html#a90fe5b950aed138b5206d8435598ce65">VIENNACL_AMG_COARSE_RS</a>: <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a06a50a73603579155fe79e13520a6114" title="Classical (RS) two-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC)">amg_coarse_classic</a> (level, A, Pointvector, tag); <span class="keywordflow">break</span>;
<a name="l00057"></a>00057         <span class="keywordflow">case</span> <a class="code" href="amg__base_8hpp.html#a7c1f879fb7a41a75883bc85c144edb9b">VIENNACL_AMG_COARSE_ONEPASS</a>: <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a58b7b11bc74b8af7f813349b77cc64ba" title="Classical (RS) one-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC_ONEPASS)">amg_coarse_classic_onepass</a> (level, A, Pointvector, tag); <span class="keywordflow">break</span>;
<a name="l00058"></a>00058         <span class="keywordflow">case</span> <a class="code" href="amg__base_8hpp.html#aa18626553487873cb4112892551e4ccb">VIENNACL_AMG_COARSE_RS0</a>: <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a5eb0ea630fcc275f383b4fce3db1722e" title="Parallel classical RS0 coarsening. Multi-Threaded! (VIENNACL_AMG_COARSE_RS0 || VIENNACL_AMG_COARSE_RS...">amg_coarse_rs0</a> (level, A, Pointvector, Slicing, tag); <span class="keywordflow">break</span>;
<a name="l00059"></a>00059         <span class="keywordflow">case</span> <a class="code" href="amg__base_8hpp.html#a7e50599d5719af8a79cbc325ac1716e0">VIENNACL_AMG_COARSE_RS3</a>: <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a338c6a66b6509e585d07ee5c3cf2acd5" title="RS3 coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_RS3)">amg_coarse_rs3</a> (level, A, Pointvector, Slicing, tag); <span class="keywordflow">break</span>;
<a name="l00060"></a>00060         <span class="keywordflow">case</span> <a class="code" href="amg__base_8hpp.html#a539c69875e7eaeed3c6443c4cca47b7f">VIENNACL_AMG_COARSE_AG</a>:   <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa9d72afeb989cdeb75c24ae7a9619e03" title="AG (aggregation based) coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_SA)">amg_coarse_ag</a> (level, A, Pointvector, tag); <span class="keywordflow">break</span>;
<a name="l00061"></a>00061       }
<a name="l00062"></a>00062     } 
<a name="l00063"></a>00063     
<a name="l00070"></a>00070     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2&gt;
<a name="l00071"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a9fa576f455789e55dda7b2aa12c8275b">00071</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a9fa576f455789e55dda7b2aa12c8275b" title="Determines strong influences in system matrix, classical approach (RS). Multithreaded!">amg_influence</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 <span class="keyword">const</span> &amp; A, InternalType2 &amp; Pointvector, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00072"></a>00072     {
<a name="l00073"></a>00073       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00074"></a>00074       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00075"></a>00075       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00076"></a>00076       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00077"></a>00077       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::const_iterator1 ConstRowIterator;
<a name="l00078"></a>00078       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::const_iterator2 ConstColIterator;
<a name="l00079"></a>00079       
<a name="l00080"></a>00080       ScalarType max;
<a name="l00081"></a>00081       <span class="keywordtype">int</span> diag_sign;
<a name="l00082"></a>00082       <span class="comment">//unsigned int i;</span>
<a name="l00083"></a>00083         
<a name="l00084"></a>00084 <span class="preprocessor">#ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">      #pragma omp parallel for private (max,diag_sign) shared (A,Pointvector)</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#endif      </span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;A[level].size1(); ++i)
<a name="l00088"></a>00088       {  
<a name="l00089"></a>00089         diag_sign = 1;
<a name="l00090"></a>00090         <span class="keywordflow">if</span> (A[level](i,i) &lt; 0)
<a name="l00091"></a>00091           diag_sign = -1;
<a name="l00092"></a>00092         
<a name="l00093"></a>00093         ConstRowIterator row_iter = A[level].begin1();
<a name="l00094"></a>00094         row_iter += i;
<a name="l00095"></a>00095         <span class="comment">// Find greatest non-diagonal negative value (positive if diagonal is negative) in row</span>
<a name="l00096"></a>00096         max = 0;
<a name="l00097"></a>00097         <span class="keywordflow">for</span> (ConstColIterator col_iter = row_iter.begin(); col_iter != row_iter.end(); ++col_iter)
<a name="l00098"></a>00098         {
<a name="l00099"></a>00099             <span class="keywordflow">if</span> (i == (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) col_iter.index2()) <span class="keywordflow">continue</span>;
<a name="l00100"></a>00100             <span class="keywordflow">if</span> (diag_sign == 1)
<a name="l00101"></a>00101               <span class="keywordflow">if</span> (max &gt; *col_iter)  max = *col_iter;
<a name="l00102"></a>00102             <span class="keywordflow">if</span> (diag_sign == -1)
<a name="l00103"></a>00103               <span class="keywordflow">if</span> (max &lt; *col_iter)  max = *col_iter;
<a name="l00104"></a>00104         }
<a name="l00105"></a>00105         
<a name="l00106"></a>00106         <span class="comment">// If maximum is 0 then the row is independent of the others</span>
<a name="l00107"></a>00107         <span class="keywordflow">if</span> (max == 0)
<a name="l00108"></a>00108           <span class="keywordflow">continue</span>;
<a name="l00109"></a>00109         
<a name="l00110"></a>00110         <span class="comment">// Find all points that strongly influence current point (Yang, p.5)</span>
<a name="l00111"></a>00111         <span class="keywordflow">for</span> (ConstColIterator col_iter = row_iter.begin(); col_iter != row_iter.end(); ++col_iter)
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = col_iter.index2();  
<a name="l00114"></a>00114           <span class="keywordflow">if</span> (i == j) <span class="keywordflow">continue</span>;
<a name="l00115"></a>00115           <span class="keywordflow">if</span> (diag_sign * (-*col_iter) &gt;= tag.<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html#aa19b55ecbae8cbdf77617f1e848d1e17">get_threshold</a>() * (diag_sign * (-max)))
<a name="l00116"></a>00116           {
<a name="l00117"></a>00117             <span class="comment">// Strong influence from j to i found, save information</span>
<a name="l00118"></a>00118             Pointvector[level][i]-&gt;add_influencing_point(Pointvector[level][j]);
<a name="l00119"></a>00119           }
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121       }
<a name="l00122"></a>00122       
<a name="l00123"></a>00123 <span class="preprocessor">      #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Influence Matrix: &quot;</span> &lt;&lt; std::endl;
<a name="l00125"></a>00125       boost::numeric::ublas::matrix&lt;bool&gt; mat;
<a name="l00126"></a>00126       Pointvector[level].get_influence_matrix(mat);
<a name="l00127"></a>00127       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a013c1755b089bee9aedeafeb36fe22cd">printmatrix</a> (mat);
<a name="l00128"></a>00128 <span class="preprocessor">      #endif</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>      
<a name="l00130"></a>00130       <span class="comment">// Save influenced points</span>
<a name="l00131"></a>00131       <span class="keywordflow">for</span> (<span class="keyword">typename</span> PointVectorType::iterator iter = Pointvector[level].begin(); iter != Pointvector[level].end(); ++iter)
<a name="l00132"></a>00132       {
<a name="l00133"></a>00133         <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter2 = (*iter)-&gt;begin_influencing(); iter2 != (*iter)-&gt;end_influencing(); ++iter2)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135           (*iter2)-&gt;add_influenced_point(*iter);
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137       }
<a name="l00138"></a>00138         
<a name="l00139"></a>00139 <span class="preprocessor">      #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Influence Measures: &quot;</span> &lt;&lt; std::endl;
<a name="l00141"></a>00141       boost::numeric::ublas::vector&lt;unsigned int&gt; temp;
<a name="l00142"></a>00142       Pointvector[level].get_influence(temp);
<a name="l00143"></a>00143       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (temp);
<a name="l00144"></a>00144       std::cout &lt;&lt; <span class="stringliteral">&quot;Point Sorting: &quot;</span> &lt;&lt; std::endl;
<a name="l00145"></a>00145       Pointvector[level].get_sorting(temp);
<a name="l00146"></a>00146       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (temp);
<a name="l00147"></a>00147 <span class="preprocessor">      #endif </span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>    }
<a name="l00149"></a>00149         
<a name="l00156"></a>00156     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2&gt;
<a name="l00157"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a58b7b11bc74b8af7f813349b77cc64ba">00157</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a58b7b11bc74b8af7f813349b77cc64ba" title="Classical (RS) one-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC_ONEPASS)">amg_coarse_classic_onepass</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00160"></a>00160       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00161"></a>00161       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00162"></a>00162       
<a name="l00163"></a>00163       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator1 InternalRowIterator;
<a name="l00164"></a>00164       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator2 InternalColIterator;
<a name="l00165"></a>00165       
<a name="l00166"></a>00166       <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html" title="A class for the AMG points. Saves point index and influence measure Holds information whether point i...">amg_point</a>* c_point, *point1, *point2;
<a name="l00167"></a>00167       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00168"></a>00168         
<a name="l00169"></a>00169       <span class="comment">// Check and save all strong influences</span>
<a name="l00170"></a>00170       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a9fa576f455789e55dda7b2aa12c8275b" title="Determines strong influences in system matrix, classical approach (RS). Multithreaded!">amg_influence</a> (level, A, Pointvector, tag);    
<a name="l00171"></a>00171       
<a name="l00172"></a>00172       <span class="comment">// Traverse through points and calculate initial influence measure</span>
<a name="l00173"></a>00173 <span class="preprocessor">#ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">      #pragma omp parallel for private (i) shared (Pointvector)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#endif      </span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (i=0; i&lt;Pointvector[level].size(); ++i)
<a name="l00177"></a>00177   Pointvector[level][i]-&gt;calc_influence();
<a name="l00178"></a>00178       
<a name="l00179"></a>00179        <span class="comment">// Do initial sorting</span>
<a name="l00180"></a>00180       Pointvector[level].sort();
<a name="l00181"></a>00181       
<a name="l00182"></a>00182       <span class="comment">// Get undecided point with highest influence measure</span>
<a name="l00183"></a>00183       <span class="keywordflow">while</span> ((c_point = Pointvector[level].get_nextpoint()) != NULL)
<a name="l00184"></a>00184       {    
<a name="l00185"></a>00185         <span class="comment">// Make this point C point</span>
<a name="l00186"></a>00186         Pointvector[level].make_cpoint(c_point);
<a name="l00187"></a>00187         
<a name="l00188"></a>00188         <span class="comment">// All strongly influenced points become F points</span>
<a name="l00189"></a>00189         <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter = c_point-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1caef7c5df0eddc84f569b14966b1248">begin_influenced</a>(); iter != c_point-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1d96491d304ff59a1b0e055b8898fbd5">end_influenced</a>(); ++iter)
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191           point1 = *iter;
<a name="l00192"></a>00192           <span class="comment">// Found strong influence from C point (c_point influences point1), check whether point is still undecided, otherwise skip</span>
<a name="l00193"></a>00193           <span class="keywordflow">if</span> (!point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abc3a2fec25dd3d1b2edc0905b052693f">is_undecided</a>()) <span class="keywordflow">continue</span>;
<a name="l00194"></a>00194           <span class="comment">// Make this point F point if it is still undecided point</span>
<a name="l00195"></a>00195           Pointvector[level].<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aee1f29235fb3db27c8ef06db9b51e128">make_fpoint</a>(point1);
<a name="l00196"></a>00196           
<a name="l00197"></a>00197           <span class="comment">// Add +1 to influence measure for all undecided points that strongly influence new F point</span>
<a name="l00198"></a>00198           <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter2 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>(); iter2 != point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>(); ++iter2)
<a name="l00199"></a>00199           {
<a name="l00200"></a>00200             point2 = *iter2;
<a name="l00201"></a>00201             <span class="comment">// Found strong influence to F point (point2 influences point1)</span>
<a name="l00202"></a>00202             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abc3a2fec25dd3d1b2edc0905b052693f">is_undecided</a>())
<a name="l00203"></a>00203               Pointvector[level].add_influence(point2,1);
<a name="l00204"></a>00204           }
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206       }
<a name="l00207"></a>00207       
<a name="l00208"></a>00208       <span class="comment">// If a point is neither C nor F point but is nevertheless influenced by other points make it F point</span>
<a name="l00209"></a>00209       <span class="comment">// (this situation can happen when this point does not influence other points and the points that influence this point became F points already)</span>
<a name="l00210"></a>00210       <span class="comment">/*#pragma omp parallel for private (i,point1)</span>
<a name="l00211"></a>00211 <span class="comment">      for (i=0; i&lt;Pointvector[level].size(); ++i)</span>
<a name="l00212"></a>00212 <span class="comment">      {</span>
<a name="l00213"></a>00213 <span class="comment">        point1 = Pointvector[level][i];</span>
<a name="l00214"></a>00214 <span class="comment">        if (point1-&gt;is_undecided())</span>
<a name="l00215"></a>00215 <span class="comment">        {</span>
<a name="l00216"></a>00216 <span class="comment">          // Undecided point found. Check whether it is influenced by other point and if so: Make it F point.</span>
<a name="l00217"></a>00217 <span class="comment">          if (point1-&gt;number_influencing() &gt; 0)</span>
<a name="l00218"></a>00218 <span class="comment">          {</span>
<a name="l00219"></a>00219 <span class="comment">            #pragma omp critical</span>
<a name="l00220"></a>00220 <span class="comment">            Pointvector[level].make_fpoint(point1);</span>
<a name="l00221"></a>00221 <span class="comment">          }</span>
<a name="l00222"></a>00222 <span class="comment">        }</span>
<a name="l00223"></a>00223 <span class="comment">      }*/</span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="preprocessor">      #if defined (VIENNACL_AMG_DEBUG)//  or defined (VIENNACL_AMG_DEBUGBENCH)</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_points = Pointvector[level].get_cpoints();
<a name="l00227"></a>00227       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_points = Pointvector[level].get_fpoints();
<a name="l00228"></a>00228       std::cout &lt;&lt; <span class="stringliteral">&quot;1st pass: Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
<a name="l00229"></a>00229       std::cout &lt;&lt; <span class="stringliteral">&quot;No of C points = &quot;</span> &lt;&lt; c_points &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00230"></a>00230       std::cout &lt;&lt; <span class="stringliteral">&quot;No of F points = &quot;</span> &lt;&lt; f_points &lt;&lt; std::endl;
<a name="l00231"></a>00231 <span class="preprocessor">      #endif</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>
<a name="l00233"></a>00233 <span class="preprocessor">      #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Coarse Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00235"></a>00235       boost::numeric::ublas::vector&lt;bool&gt; C;
<a name="l00236"></a>00236       Pointvector[level].get_C(C);
<a name="l00237"></a>00237       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (C);
<a name="l00238"></a>00238       std::cout &lt;&lt; <span class="stringliteral">&quot;Fine Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00239"></a>00239       boost::numeric::ublas::vector&lt;bool&gt; F;
<a name="l00240"></a>00240       Pointvector[level].get_F(F);
<a name="l00241"></a>00241       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (F);
<a name="l00242"></a>00242 <span class="preprocessor">      #endif</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span>    }    
<a name="l00244"></a>00244         
<a name="l00251"></a>00251     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2&gt;
<a name="l00252"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a06a50a73603579155fe79e13520a6114">00252</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a06a50a73603579155fe79e13520a6114" title="Classical (RS) two-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC)">amg_coarse_classic</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00255"></a>00255       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00256"></a>00256       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00257"></a>00257       
<a name="l00258"></a>00258       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator1 InternalRowIterator;
<a name="l00259"></a>00259       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator2 InternalColIterator;
<a name="l00260"></a>00260       
<a name="l00261"></a>00261       <span class="keywordtype">bool</span> add_C;
<a name="l00262"></a>00262       <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html" title="A class for the AMG points. Saves point index and influence measure Holds information whether point i...">amg_point</a> *c_point, *point1, *point2;     
<a name="l00263"></a>00263       
<a name="l00264"></a>00264       <span class="comment">// Use one-pass-coarsening as first pass.</span>
<a name="l00265"></a>00265       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a58b7b11bc74b8af7f813349b77cc64ba" title="Classical (RS) one-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC_ONEPASS)">amg_coarse_classic_onepass</a>(level, A, Pointvector, tag);
<a name="l00266"></a>00266     
<a name="l00267"></a>00267       <span class="comment">// 2nd pass: Add more C points if F-F connection does not have a common C point.</span>
<a name="l00268"></a>00268       <span class="keywordflow">for</span> (<span class="keyword">typename</span> PointVectorType::iterator iter = Pointvector[level].begin(); iter != Pointvector[level].end(); ++iter)
<a name="l00269"></a>00269       {
<a name="l00270"></a>00270         point1 = *iter;
<a name="l00271"></a>00271         <span class="comment">// If point is F point, check for strong connections.</span>
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a2832fa0daf9486f11a94eae78880cb30">is_fpoint</a>())
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274           <span class="comment">// Check for strong connections from influencing and influenced points.</span>
<a name="l00275"></a>00275           <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter2 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>();
<a name="l00276"></a>00276           <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter3 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1caef7c5df0eddc84f569b14966b1248">begin_influenced</a>();
<a name="l00277"></a>00277           
<a name="l00278"></a>00278           <span class="comment">// Iterate over both lists at once. This makes sure that points are no checked twice when influence relation is symmetric (which is often the case).</span>
<a name="l00279"></a>00279           <span class="comment">// Note: Only works because influencing and influenced lists are sorted by point-index.</span>
<a name="l00280"></a>00280           <span class="keywordflow">while</span>(iter2 != point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>() || iter3 != point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1d96491d304ff59a1b0e055b8898fbd5">end_influenced</a>())
<a name="l00281"></a>00281           {     
<a name="l00282"></a>00282             <span class="keywordflow">if</span> (iter2 == point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>())
<a name="l00283"></a>00283             {
<a name="l00284"></a>00284               point2 = *iter3;
<a name="l00285"></a>00285               ++iter3;
<a name="l00286"></a>00286             }
<a name="l00287"></a>00287             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iter3 == point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1d96491d304ff59a1b0e055b8898fbd5">end_influenced</a>())
<a name="l00288"></a>00288             {
<a name="l00289"></a>00289               point2 = *iter2;
<a name="l00290"></a>00290               ++iter2;
<a name="l00291"></a>00291             }
<a name="l00292"></a>00292             <span class="keywordflow">else</span>
<a name="l00293"></a>00293             {      
<a name="l00294"></a>00294               <span class="keywordflow">if</span> ((*iter2)-&gt;get_index() == (*iter3)-&gt;get_index())   
<a name="l00295"></a>00295               {
<a name="l00296"></a>00296                 point2 = *iter2;
<a name="l00297"></a>00297                 ++iter2;
<a name="l00298"></a>00298                 ++iter3;
<a name="l00299"></a>00299               }
<a name="l00300"></a>00300               <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*iter2)-&gt;get_index() &lt; (*iter3)-&gt;get_index())
<a name="l00301"></a>00301               {
<a name="l00302"></a>00302                 point2 = *iter2;
<a name="l00303"></a>00303                 ++iter2;
<a name="l00304"></a>00304               }
<a name="l00305"></a>00305               <span class="keywordflow">else</span>
<a name="l00306"></a>00306               {
<a name="l00307"></a>00307                 point2 = *iter3;
<a name="l00308"></a>00308                 ++iter3;
<a name="l00309"></a>00309               }
<a name="l00310"></a>00310             }
<a name="l00311"></a>00311             <span class="comment">// Only check points with higher index as points with lower index have been checked already.</span>
<a name="l00312"></a>00312             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>() &lt; point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>())
<a name="l00313"></a>00313               <span class="keywordflow">continue</span>;
<a name="l00314"></a>00314             
<a name="l00315"></a>00315             <span class="comment">// If there is a strong connection then it has to either be a C point or a F point with common C point.</span>
<a name="l00316"></a>00316             <span class="comment">// C point? Then skip as everything is ok.</span>
<a name="l00317"></a>00317             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aecfd6ba5e6e77df96981acde9409829c">is_cpoint</a>())
<a name="l00318"></a>00318               <span class="keywordflow">continue</span>;
<a name="l00319"></a>00319             <span class="comment">// F point? Then check whether F points point1 and point2 have a common C point.</span>
<a name="l00320"></a>00320             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a2832fa0daf9486f11a94eae78880cb30">is_fpoint</a>())
<a name="l00321"></a>00321             {
<a name="l00322"></a>00322               add_C = <span class="keyword">true</span>;
<a name="l00323"></a>00323               <span class="comment">// C point is common for two F points if they are both strongly influenced by that C point.</span>
<a name="l00324"></a>00324               <span class="comment">// Compare strong influences for point1 and point2.</span>
<a name="l00325"></a>00325               <span class="keywordflow">for</span> (<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter3 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>(); iter3 != point1 -&gt; end_influencing(); ++iter3)
<a name="l00326"></a>00326               {
<a name="l00327"></a>00327                 c_point = *iter3;
<a name="l00328"></a>00328                 <span class="comment">// Stop search when strong common influence is found via c_point.</span>
<a name="l00329"></a>00329                 <span class="keywordflow">if</span> (c_point-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aecfd6ba5e6e77df96981acde9409829c">is_cpoint</a>())
<a name="l00330"></a>00330                 {
<a name="l00331"></a>00331                   <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a5ee3af0a15b61d842ce9dfa919ef0513">is_influencing</a>(c_point))
<a name="l00332"></a>00332                   {
<a name="l00333"></a>00333                     add_C = <span class="keyword">false</span>;
<a name="l00334"></a>00334                     <span class="keywordflow">break</span>;            
<a name="l00335"></a>00335                   }
<a name="l00336"></a>00336                 }
<a name="l00337"></a>00337               }
<a name="l00338"></a>00338               <span class="comment">// No common C point found? Then make second F point to C point.</span>
<a name="l00339"></a>00339               <span class="keywordflow">if</span> (add_C == <span class="keyword">true</span>)
<a name="l00340"></a>00340                 Pointvector[level].switch_ftoc(point2);
<a name="l00341"></a>00341             }
<a name="l00342"></a>00342           }
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345       
<a name="l00346"></a>00346 <span class="preprocessor">      #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;After 2nd pass:&quot;</span> &lt;&lt; std::endl;
<a name="l00348"></a>00348       std::cout &lt;&lt; <span class="stringliteral">&quot;Coarse Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00349"></a>00349       boost::numeric::ublas::vector&lt;bool&gt; C;
<a name="l00350"></a>00350       Pointvector[level].get_C(C);
<a name="l00351"></a>00351       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (C);
<a name="l00352"></a>00352       std::cout &lt;&lt; <span class="stringliteral">&quot;Fine Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00353"></a>00353       boost::numeric::ublas::vector&lt;bool&gt; F;
<a name="l00354"></a>00354       Pointvector[level].get_F(F);
<a name="l00355"></a>00355       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (F);
<a name="l00356"></a>00356 <span class="preprocessor">      #endif</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>
<a name="l00358"></a>00358 <span class="preprocessor">      #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span><span class="preprocessor">#ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="preprocessor">      #pragma omp critical</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span><span class="preprocessor">#endif      </span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>      {
<a name="l00363"></a>00363       std::cout &lt;&lt; <span class="stringliteral">&quot;No C and no F point: &quot;</span>;
<a name="l00364"></a>00364       <span class="keywordflow">for</span> (<span class="keyword">typename</span> PointVectorType::iterator iter = Pointvector[level].begin(); iter != Pointvector[level].end(); ++iter)
<a name="l00365"></a>00365   <span class="keywordflow">if</span> ((*iter)-&gt;is_undecided())
<a name="l00366"></a>00366     std::cout &lt;&lt; (*iter)-&gt;get_index() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00367"></a>00367       std::cout &lt;&lt; std::endl;
<a name="l00368"></a>00368       }
<a name="l00369"></a>00369 <span class="preprocessor">      #endif</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>    }
<a name="l00371"></a>00371 
<a name="l00379"></a>00379     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2, <span class="keyword">typename</span> InternalType3&gt;
<a name="l00380"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a5eb0ea630fcc275f383b4fce3db1722e">00380</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a5eb0ea630fcc275f383b4fce3db1722e" title="Parallel classical RS0 coarsening. Multi-Threaded! (VIENNACL_AMG_COARSE_RS0 || VIENNACL_AMG_COARSE_RS...">amg_coarse_rs0</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, InternalType3 &amp; Slicing, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00383"></a>00383       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00384"></a>00384       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00385"></a>00385       
<a name="l00386"></a>00386       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator1 InternalRowIterator;
<a name="l00387"></a>00387       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator2 InternalColIterator;
<a name="l00388"></a>00388       
<a name="l00389"></a>00389       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_points;
<a name="l00390"></a>00390       
<a name="l00391"></a>00391       <span class="comment">// Slice matrix into parts such that points are distributed among threads</span>
<a name="l00392"></a>00392       Slicing.slice(level, A, Pointvector);     
<a name="l00393"></a>00393       
<a name="l00394"></a>00394       <span class="comment">// Run classical coarsening in parallel</span>
<a name="l00395"></a>00395       total_points = 0;
<a name="l00396"></a>00396 <span class="preprocessor">#ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span><span class="preprocessor">      #pragma omp parallel for shared (total_points,Slicing,level)</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span><span class="preprocessor">#endif      </span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;Slicing.threads_; ++i)
<a name="l00400"></a>00400       {
<a name="l00401"></a>00401         <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a06a50a73603579155fe79e13520a6114" title="Classical (RS) two-pass coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_CLASSIC)">amg_coarse_classic</a>(level,Slicing.A_slice[i],Slicing.Pointvector_slice[i],tag);
<a name="l00402"></a>00402         
<a name="l00403"></a>00403         <span class="comment">// Save C points (using Slicing.Offset on the next level as temporary memory)</span>
<a name="l00404"></a>00404         <span class="comment">// Note: Number of C points for point i is saved in i+1!! (makes it easier later to compute offset)</span>
<a name="l00405"></a>00405         Slicing.Offset[i+1][level+1] = Slicing.Pointvector_slice[i][level].get_cpoints();
<a name="l00406"></a>00406 <span class="preprocessor">      #ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span><span class="preprocessor">        #pragma omp critical</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="preprocessor">      #endif  </span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>        total_points += Slicing.Pointvector_slice[i][level].get_cpoints();
<a name="l00410"></a>00410       }      
<a name="l00411"></a>00411       
<a name="l00412"></a>00412       <span class="comment">// If no coarser level can be found on any level then resume and coarsening will stop in amg_coarse()</span>
<a name="l00413"></a>00413       <span class="keywordflow">if</span> (total_points != 0)
<a name="l00414"></a>00414       {    
<a name="l00415"></a>00415 <span class="preprocessor">      #ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span><span class="preprocessor">        #pragma omp parallel for shared (Slicing)</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span><span class="preprocessor">      #endif  </span>
<a name="l00418"></a>00418 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;Slicing.threads_; ++i)
<a name="l00419"></a>00419         {
<a name="l00420"></a>00420           <span class="comment">// If no higher coarse level can be found on slice i (saved in Slicing.Offset[i+1][level+1]) then pull C point(s) to the next level</span>
<a name="l00421"></a>00421           <span class="keywordflow">if</span> (Slicing.Offset[i+1][level+1] == 0)
<a name="l00422"></a>00422           {
<a name="l00423"></a>00423             <span class="comment">// All points become C points</span>
<a name="l00424"></a>00424             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;Slicing.A_slice[i][level].size1(); ++j)
<a name="l00425"></a>00425               Slicing.Pointvector_slice[i][level].make_cpoint(Slicing.Pointvector_slice[i][level][j]);
<a name="l00426"></a>00426             Slicing.Offset[i+1][level+1] = Slicing.A_slice[i][level].size1();
<a name="l00427"></a>00427           }
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429           
<a name="l00430"></a>00430         <span class="comment">// Build slicing offset from number of C points (offset = total sum of C points on threads with lower number)</span>
<a name="l00431"></a>00431         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=2; i&lt;=Slicing.threads_; ++i)
<a name="l00432"></a>00432           Slicing.Offset[i][level+1] += Slicing.Offset[i-1][level+1];
<a name="l00433"></a>00433             
<a name="l00434"></a>00434         <span class="comment">// Join C and F points</span>
<a name="l00435"></a>00435         Slicing.join(level, Pointvector);
<a name="l00436"></a>00436       }
<a name="l00437"></a>00437       
<a name="l00438"></a>00438       <span class="comment">// Calculate global influence measures for interpolation and/or RS3.</span>
<a name="l00439"></a>00439       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a9fa576f455789e55dda7b2aa12c8275b" title="Determines strong influences in system matrix, classical approach (RS). Multithreaded!">amg_influence</a>(level, A, Pointvector, tag); 
<a name="l00440"></a>00440       
<a name="l00441"></a>00441 <span class="preprocessor">      #if defined(VIENNACL_AMG_DEBUG)// or defined (VIENNACL_AMG_DEBUGBENCH)</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;Slicing._threads; ++i)
<a name="l00443"></a>00443       {
<a name="l00444"></a>00444         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_points = Slicing.Pointvector_slice[i][level].get_cpoints();
<a name="l00445"></a>00445         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_points = Slicing.Pointvector_slice[i][level].get_fpoints();
<a name="l00446"></a>00446         std::cout &lt;&lt; <span class="stringliteral">&quot;Thread &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
<a name="l00447"></a>00447         std::cout &lt;&lt; <span class="stringliteral">&quot;No of C points = &quot;</span> &lt;&lt; c_points &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00448"></a>00448         std::cout &lt;&lt; <span class="stringliteral">&quot;No of F points = &quot;</span> &lt;&lt; f_points &lt;&lt; std::endl;
<a name="l00449"></a>00449       }
<a name="l00450"></a>00450 <span class="preprocessor">      #endif</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>    }
<a name="l00452"></a>00452     
<a name="l00460"></a>00460     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2, <span class="keyword">typename</span> InternalType3&gt;
<a name="l00461"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a338c6a66b6509e585d07ee5c3cf2acd5">00461</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a338c6a66b6509e585d07ee5c3cf2acd5" title="RS3 coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_RS3)">amg_coarse_rs3</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, InternalType3 &amp; Slicing, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00464"></a>00464       <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00465"></a>00465       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00466"></a>00466       
<a name="l00467"></a>00467       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator1 InternalRowIterator;
<a name="l00468"></a>00468       <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator2 InternalColIterator;
<a name="l00469"></a>00469       
<a name="l00470"></a>00470       <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html" title="A class for the AMG points. Saves point index and influence measure Holds information whether point i...">amg_point</a> *c_point, *point1, *point2;
<a name="l00471"></a>00471       <span class="keywordtype">bool</span> add_C;
<a name="l00472"></a>00472       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00473"></a>00473             
<a name="l00474"></a>00474       <span class="comment">// Run RS0 first (parallel).</span>
<a name="l00475"></a>00475       <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a5eb0ea630fcc275f383b4fce3db1722e" title="Parallel classical RS0 coarsening. Multi-Threaded! (VIENNACL_AMG_COARSE_RS0 || VIENNACL_AMG_COARSE_RS...">amg_coarse_rs0</a>(level, A, Pointvector, Slicing, tag);
<a name="l00476"></a>00476       
<a name="l00477"></a>00477       <span class="comment">// Save slicing offset</span>
<a name="l00478"></a>00478       boost::numeric::ublas::vector&lt;unsigned int&gt; Offset = boost::numeric::ublas::vector&lt;unsigned int&gt; (Slicing.Offset.size());
<a name="l00479"></a>00479       <span class="keywordflow">for</span> (i=0; i&lt;Slicing.Offset.size(); ++i)
<a name="l00480"></a>00480         Offset[i] = Slicing.Offset[i][level];
<a name="l00481"></a>00481       
<a name="l00482"></a>00482       <span class="comment">// Correct the coarsening with a third pass: Don&#39;t allow strong F-F connections without common C point</span>
<a name="l00483"></a>00483       for (i=0; i&lt;Slicing.threads_; ++i)
<a name="l00484"></a>00484       {
<a name="l00485"></a>00485       <span class="comment">//for (j=Slicing.Offset[i][level]; j&lt;Slicing.Offset[i+1][level]; ++j)</span>
<a name="l00486"></a>00486       <span class="keywordflow">for</span> (j=Offset[i]; j&lt;Offset[i+1]; ++j)
<a name="l00487"></a>00487       {
<a name="l00488"></a>00488         point1 = Pointvector[level][j];
<a name="l00489"></a>00489         <span class="comment">// If point is F point, check for strong connections.</span>
<a name="l00490"></a>00490         <span class="keywordflow">if</span> (point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a2832fa0daf9486f11a94eae78880cb30">is_fpoint</a>())
<a name="l00491"></a>00491         {
<a name="l00492"></a>00492           <span class="comment">// Check for strong connections from influencing and influenced points.</span>
<a name="l00493"></a>00493           <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter2 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>();
<a name="l00494"></a>00494           <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter3 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1caef7c5df0eddc84f569b14966b1248">begin_influenced</a>();
<a name="l00495"></a>00495           
<a name="l00496"></a>00496           <span class="comment">// Iterate over both lists at once. This makes sure that points are no checked twice when influence relation is symmetric (which is often the case).</span>
<a name="l00497"></a>00497           <span class="comment">// Note: Only works because influencing and influenced lists are sorted by point-index.</span>
<a name="l00498"></a>00498           <span class="keywordflow">while</span>(iter2 != point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>() || iter3 != point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1d96491d304ff59a1b0e055b8898fbd5">end_influenced</a>())
<a name="l00499"></a>00499           {     
<a name="l00500"></a>00500             <span class="keywordflow">if</span> (iter2 == point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>())
<a name="l00501"></a>00501             {
<a name="l00502"></a>00502               point2 = *iter3;
<a name="l00503"></a>00503               ++iter3;
<a name="l00504"></a>00504             }
<a name="l00505"></a>00505             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iter3 == point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a1d96491d304ff59a1b0e055b8898fbd5">end_influenced</a>())
<a name="l00506"></a>00506             {
<a name="l00507"></a>00507               point2 = *iter2;
<a name="l00508"></a>00508               ++iter2;
<a name="l00509"></a>00509             }
<a name="l00510"></a>00510             <span class="keywordflow">else</span>
<a name="l00511"></a>00511             {      
<a name="l00512"></a>00512               <span class="keywordflow">if</span> ((*iter2)-&gt;get_index() == (*iter3)-&gt;get_index())   
<a name="l00513"></a>00513               {
<a name="l00514"></a>00514                 point2 = *iter2;
<a name="l00515"></a>00515                 ++iter2;
<a name="l00516"></a>00516                 ++iter3;
<a name="l00517"></a>00517               }
<a name="l00518"></a>00518               <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*iter2)-&gt;get_index() &lt; (*iter3)-&gt;get_index())
<a name="l00519"></a>00519               {
<a name="l00520"></a>00520                 point2 = *iter2;
<a name="l00521"></a>00521                 ++iter2;
<a name="l00522"></a>00522               }
<a name="l00523"></a>00523               <span class="keywordflow">else</span>
<a name="l00524"></a>00524               {
<a name="l00525"></a>00525                 point2 = *iter3;
<a name="l00526"></a>00526                 ++iter3;
<a name="l00527"></a>00527               }
<a name="l00528"></a>00528             }
<a name="l00529"></a>00529                   
<a name="l00530"></a>00530             <span class="comment">// Only check points with higher index as points with lower index have been checked already.</span>
<a name="l00531"></a>00531             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>() &lt; point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>())
<a name="l00532"></a>00532               <span class="keywordflow">continue</span>;
<a name="l00533"></a>00533                     
<a name="l00534"></a>00534             <span class="comment">// Only check points that are outside the slicing boundaries (interior F-F connections have already been checked in second pass)</span>
<a name="l00535"></a>00535             <span class="comment">//if (point2-&gt;get_index() &gt;= Slicing.Offset[i][level] || point2-&gt;get_index() &lt; Slicing.Offset[i+1][level])</span>
<a name="l00536"></a>00536             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>() &gt;= Offset[i] &amp;&amp; point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>() &lt; Offset[i+1])
<a name="l00537"></a>00537               <span class="keywordflow">continue</span>;
<a name="l00538"></a>00538             
<a name="l00539"></a>00539             <span class="comment">// If there is a strong connection then it has to either be a C point or a F point with common C point.</span>
<a name="l00540"></a>00540             <span class="comment">// C point? Then skip as everything is ok.</span>
<a name="l00541"></a>00541             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aecfd6ba5e6e77df96981acde9409829c">is_cpoint</a>())
<a name="l00542"></a>00542               <span class="keywordflow">continue</span>;
<a name="l00543"></a>00543             <span class="comment">// F point? Then check whether F points point1 and point2 have a common C point.</span>
<a name="l00544"></a>00544             <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a2832fa0daf9486f11a94eae78880cb30">is_fpoint</a>())
<a name="l00545"></a>00545             {
<a name="l00546"></a>00546               add_C = <span class="keyword">true</span>;
<a name="l00547"></a>00547               <span class="comment">// C point is common for two F points if they are both strongly influenced by that C point.</span>
<a name="l00548"></a>00548               <span class="comment">// Compare strong influences for point1 and point2.</span>
<a name="l00549"></a>00549               <span class="keywordflow">for</span> (<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter3 = point1-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>(); iter3 != point1 -&gt; end_influencing(); ++iter3)
<a name="l00550"></a>00550               {
<a name="l00551"></a>00551                 c_point = *iter3;
<a name="l00552"></a>00552                 <span class="comment">// Stop search when strong common influence is found via c_point.</span>
<a name="l00553"></a>00553                 <span class="keywordflow">if</span> (c_point-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aecfd6ba5e6e77df96981acde9409829c">is_cpoint</a>())
<a name="l00554"></a>00554                 {
<a name="l00555"></a>00555                   <span class="keywordflow">if</span> (point2-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a5ee3af0a15b61d842ce9dfa919ef0513">is_influencing</a>(c_point))
<a name="l00556"></a>00556                   {
<a name="l00557"></a>00557                     add_C = <span class="keyword">false</span>;
<a name="l00558"></a>00558                     <span class="keywordflow">break</span>;            
<a name="l00559"></a>00559                   }
<a name="l00560"></a>00560                 }
<a name="l00561"></a>00561               }
<a name="l00562"></a>00562               <span class="comment">// No common C point found? Then make second F point to C point.</span>
<a name="l00563"></a>00563               <span class="keywordflow">if</span> (add_C == <span class="keyword">true</span>)
<a name="l00564"></a>00564               {
<a name="l00565"></a>00565                 Pointvector[level].switch_ftoc(point2);
<a name="l00566"></a>00566                 <span class="comment">// Add +1 to offsets as one C point has been added.</span>
<a name="l00567"></a>00567                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;=Slicing.threads_; ++j)
<a name="l00568"></a>00568                   Slicing.Offset[j][level+1]++;
<a name="l00569"></a>00569               }
<a name="l00570"></a>00570                   }
<a name="l00571"></a>00571                 }
<a name="l00572"></a>00572               }
<a name="l00573"></a>00573             }
<a name="l00574"></a>00574           }
<a name="l00575"></a>00575           
<a name="l00576"></a>00576 <span class="preprocessor">          #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;After 3rd pass:&quot;</span> &lt;&lt; std::endl;
<a name="l00578"></a>00578           std::cout &lt;&lt; <span class="stringliteral">&quot;Coarse Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00579"></a>00579           boost::numeric::ublas::vector&lt;bool&gt; C;
<a name="l00580"></a>00580           Pointvector[level].get_C(C);
<a name="l00581"></a>00581           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (C);
<a name="l00582"></a>00582           std::cout &lt;&lt; <span class="stringliteral">&quot;Fine Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00583"></a>00583           boost::numeric::ublas::vector&lt;bool&gt; F;
<a name="l00584"></a>00584           Pointvector[level].get_F(F);
<a name="l00585"></a>00585           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (F);
<a name="l00586"></a>00586 <span class="preprocessor">          #endif</span>
<a name="l00587"></a>00587 <span class="preprocessor"></span>
<a name="l00588"></a>00588 <span class="preprocessor">          #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00589"></a>00589 <span class="preprocessor"></span>          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00590"></a>00590 <span class="preprocessor">    #ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span><span class="preprocessor">          #pragma omp critical</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span><span class="preprocessor">    #endif      </span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>          {
<a name="l00594"></a>00594             std::cout &lt;&lt; <span class="stringliteral">&quot;No C and no F point: &quot;</span>;
<a name="l00595"></a>00595             <span class="keywordflow">for</span> (<span class="keyword">typename</span> PointVectorType::iterator iter = Pointvector[level].begin(); iter != Pointvector[level].end(); ++iter)
<a name="l00596"></a>00596               <span class="keywordflow">if</span> ((*iter)-&gt;is_undecided())
<a name="l00597"></a>00597                 std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00598"></a>00598             std::cout &lt;&lt; std::endl;
<a name="l00599"></a>00599           }
<a name="l00600"></a>00600 <span class="preprocessor">          #endif</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>        }
<a name="l00602"></a>00602         
<a name="l00610"></a>00610         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InternalType1, <span class="keyword">typename</span> InternalType2&gt;
<a name="l00611"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa9d72afeb989cdeb75c24ae7a9619e03">00611</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa9d72afeb989cdeb75c24ae7a9619e03" title="AG (aggregation based) coarsening. Single-Threaded! (VIENNACL_AMG_COARSE_SA)">amg_coarse_ag</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, InternalType1 &amp; A, InternalType2 &amp; Pointvector, <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html" title="A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementatio...">amg_tag</a> &amp; tag)
<a name="l00612"></a>00612         {
<a name="l00613"></a>00613           <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType1::value_type SparseMatrixType;
<a name="l00614"></a>00614           <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalType2::value_type PointVectorType;
<a name="l00615"></a>00615           <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::value_type ScalarType;
<a name="l00616"></a>00616           
<a name="l00617"></a>00617           <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator1 InternalRowIterator;
<a name="l00618"></a>00618           <span class="keyword">typedef</span> <span class="keyword">typename</span> SparseMatrixType::iterator2 InternalColIterator;
<a name="l00619"></a>00619           
<a name="l00620"></a>00620           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x,y;
<a name="l00621"></a>00621           ScalarType diag;
<a name="l00622"></a>00622           <a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html" title="A class for the AMG points. Saves point index and influence measure Holds information whether point i...">amg_point</a> *pointx, *pointy;
<a name="l00623"></a>00623         
<a name="l00624"></a>00624           <span class="comment">// Cannot determine aggregates if size == 1 as then a new aggregate would always consist of this point (infinite loop)</span>
<a name="l00625"></a>00625           <span class="keywordflow">if</span> (A[level].<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1</a>() == 1) <span class="keywordflow">return</span>;
<a name="l00626"></a>00626           
<a name="l00627"></a>00627           <span class="comment">// SA algorithm (Vanek et al. p.6)     </span>
<a name="l00628"></a>00628           <span class="comment">// Build neighborhoods</span>
<a name="l00629"></a>00629 <span class="preprocessor">    #ifdef VIENNACL_WITH_OPENMP</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span><span class="preprocessor">          #pragma omp parallel for private (x,y,diag) shared (A)</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span><span class="preprocessor">    #endif      </span>
<a name="l00632"></a>00632 <span class="preprocessor"></span>          <span class="keywordflow">for</span> (x=0; x&lt;A[level].size1(); ++x)
<a name="l00633"></a>00633           {
<a name="l00634"></a>00634             InternalRowIterator row_iter = A[level].begin1();
<a name="l00635"></a>00635             row_iter += x;
<a name="l00636"></a>00636             diag = A[level](x,x);
<a name="l00637"></a>00637             <span class="keywordflow">for</span> (InternalColIterator col_iter = row_iter.begin(); col_iter != row_iter.end(); ++col_iter)
<a name="l00638"></a>00638             {
<a name="l00639"></a>00639               y = col_iter.index2();
<a name="l00640"></a>00640               <span class="keywordflow">if</span> (y == x || (std::fabs(*col_iter) &gt;= tag.<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__tag.html#aa19b55ecbae8cbdf77617f1e848d1e17">get_threshold</a>()*pow(0.5, static_cast&lt;double&gt;(level-1)) * std::sqrt(std::fabs(diag*A[level](y,y)))))
<a name="l00641"></a>00641               {
<a name="l00642"></a>00642                 <span class="comment">// Neighborhood x includes point y</span>
<a name="l00643"></a>00643                 Pointvector[level][x]-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a349b7977866345cdd0863864f78b5d09">add_influencing_point</a>(Pointvector[level][y]);
<a name="l00644"></a>00644               }
<a name="l00645"></a>00645             }
<a name="l00646"></a>00646           }
<a name="l00647"></a>00647           
<a name="l00648"></a>00648 <span class="preprocessor">          #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00649"></a>00649 <span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;Neighborhoods:&quot;</span> &lt;&lt; std::endl;
<a name="l00650"></a>00650           boost::numeric::ublas::matrix&lt;bool&gt; mat;
<a name="l00651"></a>00651           Pointvector[level].get_influence_matrix(mat);
<a name="l00652"></a>00652           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#a013c1755b089bee9aedeafeb36fe22cd">printmatrix</a> (mat);
<a name="l00653"></a>00653 <span class="preprocessor">          #endif</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span>
<a name="l00655"></a>00655           <span class="comment">// Build aggregates from neighborhoods  </span>
<a name="l00656"></a>00656           <span class="keywordflow">for</span> (<span class="keyword">typename</span> PointVectorType::iterator iter = Pointvector[level].begin(); iter != Pointvector[level].end(); ++iter)
<a name="l00657"></a>00657           {
<a name="l00658"></a>00658             pointx = (*iter);
<a name="l00659"></a>00659             
<a name="l00660"></a>00660             <span class="keywordflow">if</span> (pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abc3a2fec25dd3d1b2edc0905b052693f">is_undecided</a>())
<a name="l00661"></a>00661             {
<a name="l00662"></a>00662               <span class="comment">// Make center of aggregate to C point and include it to aggregate x.</span>
<a name="l00663"></a>00663               Pointvector[level].<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#afaeedf7fc19133932efad72827ec4c31">make_cpoint</a>(pointx);
<a name="l00664"></a>00664               pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a494f13faad7a86eaeca59ac39ef1f7fc">set_aggregate</a> (pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>());
<a name="l00665"></a>00665               <span class="keywordflow">for</span> (<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__sparsevector__iterator.html" title="Defines an iterator for the sparse vector type.">amg_point::iterator</a> iter2 = pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abf74c8100f4835805274f78378ae0cfe">begin_influencing</a>(); iter2 != pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af098836066b25844985799dcaed57d4a">end_influencing</a>(); ++iter2)
<a name="l00666"></a>00666               {
<a name="l00667"></a>00667               pointy = (*iter2);
<a name="l00668"></a>00668                 
<a name="l00669"></a>00669                 <span class="keywordflow">if</span> (pointy-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#abc3a2fec25dd3d1b2edc0905b052693f">is_undecided</a>())
<a name="l00670"></a>00670                 {
<a name="l00671"></a>00671                   <span class="comment">// Make neighbor y to F point and include it to aggregate x.</span>
<a name="l00672"></a>00672                   Pointvector[level].<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#aee1f29235fb3db27c8ef06db9b51e128">make_fpoint</a>(pointy);
<a name="l00673"></a>00673                   pointy-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#a494f13faad7a86eaeca59ac39ef1f7fc">set_aggregate</a> (pointx-&gt;<a class="code" href="classviennacl_1_1linalg_1_1detail_1_1amg_1_1amg__point.html#af189f3a18d5861a6df3c1cc44911d8c5">get_index</a>());
<a name="l00674"></a>00674                 }
<a name="l00675"></a>00675               }
<a name="l00676"></a>00676             }
<a name="l00677"></a>00677           }
<a name="l00678"></a>00678           
<a name="l00679"></a>00679 <span class="preprocessor">          #ifdef VIENNACL_AMG_DEBUG</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;After aggregation:&quot;</span> &lt;&lt; std::endl;
<a name="l00681"></a>00681           std::cout &lt;&lt; <span class="stringliteral">&quot;Coarse Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00682"></a>00682           boost::numeric::ublas::vector&lt;bool&gt; C;
<a name="l00683"></a>00683           Pointvector[level].get_C(C);
<a name="l00684"></a>00684           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (C);
<a name="l00685"></a>00685           std::cout &lt;&lt; <span class="stringliteral">&quot;Fine Points:&quot;</span> &lt;&lt; std::endl;
<a name="l00686"></a>00686           boost::numeric::ublas::vector&lt;bool&gt; F;
<a name="l00687"></a>00687           Pointvector[level].get_F(F);
<a name="l00688"></a>00688           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (F);
<a name="l00689"></a>00689           std::cout &lt;&lt; <span class="stringliteral">&quot;Aggregates:&quot;</span> &lt;&lt; std::endl;
<a name="l00690"></a>00690           <a class="code" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html#aa1dcca884316297370f137f3a4cec87a">printvector</a> (Aggregates[level]);          
<a name="l00691"></a>00691 <span class="preprocessor">          #endif</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span>        }
<a name="l00693"></a>00693       } <span class="comment">//namespace amg</span>
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695   }
<a name="l00696"></a>00696 }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:53 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
