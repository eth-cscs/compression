<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/matrix.hpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl/matrix.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the dense matrix class.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="forwards_8h_source.html">viennacl/forwards.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="scalar_8hpp_source.html">viennacl/scalar.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="vector_8hpp_source.html">viennacl/vector.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="matrix__operations_8hpp_source.html">viennacl/linalg/matrix_operations.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tools_8hpp_source.html">viennacl/tools/tools.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="matrix__size__deducer_8hpp_source.html">viennacl/tools/matrix_size_deducer.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="meta_2result__of_8hpp_source.html">viennacl/meta/result_of.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="enable__if_8hpp_source.html">viennacl/meta/enable_if.hpp</a>&quot;</code><br/>
</div>
<p><a href="matrix_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">identity_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">zero_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">scalar_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base&lt; SCALARTYPE, F, SizeType, DistanceType &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af2b7b1aeba8d75ee073974e57d1bf385">operator&lt;&lt;</a> (std::ostream &amp;s, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#af2b7b1aeba8d75ee073974e57d1bf385"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">operator&lt;&lt;</a> (std::ostream &amp;s, const matrix_expression&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a6c1627d47e4b494526e0287de3ed8476"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_trans &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250af0917fd1088eb339e3550964954">trans</a> (const matrix_base&lt; NumericT, F &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a0250af0917fd1088eb339e3550964954"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3728d51018413682b2c807cb26fe0ce6">copy</a> (const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#a3728d51018413682b2c807cb26fe0ce6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba57054849e1adf3cd627b22d8512b75">copy</a> (const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#aba57054849e1adf3cd627b22d8512b75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6fe9c1c3ea45c54d92082b1805790e80">fast_copy</a> (SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#a6fe9c1c3ea45c54d92082b1805790e80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad655c8cbb96bf07d2348309a2656799e">copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#ad655c8cbb96bf07d2348309a2656799e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aab87e45b79097799bbaabeed1e240ace">copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#aab87e45b79097799bbaabeed1e240ace"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a67d05f6ec18b2d7c2051eb4f6b47b5a7">fast_copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::matrix_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab0b04b8d27cc0b0b61dfb5597e584702">operator+</a> (matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#ab0b04b8d27cc0b0b61dfb5597e584702"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8992f6234065e16e9276dfff541602b6">operator+</a> (matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9fa036b3f0f44238017a31ad88c80d86">operator+</a> (matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5372fd531482dd77aac96fba60b4538f">operator+</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5372fd531482dd77aac96fba60b4538f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S3, OP &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a443dcf4c6c1a880daee9c7386f4b6fdb">operator+</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 + m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#a443dcf4c6c1a880daee9c7386f4b6fdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S2, OP &gt;, const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, op_add &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5d1fff024f156a58a991d59fd465a507">operator+</a> (const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const matrix_base&lt; NumericT, F &gt; &amp;m3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha + m2, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#a5d1fff024f156a58a991d59fd465a507"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, OP1 &gt;, const <br class="typebreak"/>
matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_add &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a857040281dd174c8ac87528f047d5c0a">operator+</a> (matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha + m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a857040281dd174c8ac87528f047d5c0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a589ea656a161143b696e4e10283461f3">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a34d0383bb21e7539bd4abe967918dc0c">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a scaled matrix, i.e. m1 += m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a34d0383bb21e7539bd4abe967918dc0c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value, matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa33e6eb5ca54fc6763be5c488564eebe">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 +- m3.  <a href="#aa33e6eb5ca54fc6763be5c488564eebe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9148ebbd8fc6c6ba770c9e57ca8c302c">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a9148ebbd8fc6c6ba770c9e57ca8c302c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4da9f947cf67d8eb0ea0244c38d34059">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a4da9f947cf67d8eb0ea0244c38d34059"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::value)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aea14a59372ddd475eb821c6a589d4268">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 += m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#aea14a59372ddd475eb821c6a589d4268"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a65aa6fc53cb1fffb53cf9874db013eb0">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ade18df55cbc05cd34eef188baf75d0f4">operator+=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0c4b121a63ee355f6cf18b56949b51a4">operator+=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2c5a85799c2db6530c2f9eeabbb1ef53">operator+=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6b7ef92927cd5b04a6d7f5c4150f0512">operator+=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4f6de4f40e96f9a18fd52875e8fe8fa0">operator+=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::matrix_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ade34780cdab333f3ec7fa9891575cbb3">operator-</a> (matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#ade34780cdab333f3ec7fa9891575cbb3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3ee94920320eca8859c6c701a144eec1">operator-</a> (matrix_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; NumericT, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab5d56f1aa9c09f89634e90bdd081dbd5">operator-</a> (matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5bf54d540a468ff7b897e5b4d9b8b330">operator-</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5bf54d540a468ff7b897e5b4d9b8b330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S3, OP &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab3937a50a0a176a37c84929bf1cbd1ae">operator-</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 - m2 @ beta, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#ab3937a50a0a176a37c84929bf1cbd1ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S2, OP &gt;, const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, op_sub &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac723ebaf79518ca727079ff5684de9ff">operator-</a> (const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy, const matrix_base&lt; NumericT, F &gt; &amp;m3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha - m2, where @ is either product or division, and beta is either a CPU or GPU scalar.  <a href="#ac723ebaf79518ca727079ff5684de9ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 , typename OP1 , typename S2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, OP1 &gt;, const <br class="typebreak"/>
matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const S2, OP2 &gt;, op_sub &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a047d1ad8f03c586d67cdfd52dfc9998a">operator-</a> (matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S1, OP1 &gt; const &amp;lhs, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a matrix expression m1 @ alpha - m2 @ beta, where @ denotes either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a047d1ad8f03c586d67cdfd52dfc9998a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4c1114da061dab23aeb89e2a3801ca2d">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0347efecac1e4749853a6067c247bfc0">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition of a scaled matrix, i.e. m1 -= m2 @ alpha, where @ is either product or division and alpha is either a CPU or a GPU scalar.  <a href="#a0347efecac1e4749853a6067c247bfc0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a>&lt; OP &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value, matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9ef187e5bc4a09bff5a3fbf1ebb9ac09">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 +- m3.  <a href="#a9ef187e5bc4a09bff5a3fbf1ebb9ac09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a05d885974dab948d3ccebd63eca79d60">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a05d885974dab948d3ccebd63eca79d60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a55b1051cab786c1642e3be9bf5d8e47a">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_base&lt; NumericT, F &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 @ alpha +- m3, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a55b1051cab786c1642e3be9bf5d8e47a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S2 , typename OP2 , typename S3 , typename OP3 , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S2 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP2 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP2 &gt;::value)&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; S3 &gt;::value <br class="typebreak"/>
&amp;&amp;(<a class="el" href="structviennacl_1_1is__product.html">viennacl::is_product</a>&lt; OP3 &gt;<br class="typebreak"/>
::value||<a class="el" href="structviennacl_1_1is__division.html">viennacl::is_division</a><br class="typebreak"/>
&lt; OP3 &gt;::value)&amp;&amp;(<a class="el" href="structviennacl_1_1is__addition.html">viennacl::is_addition</a><br class="typebreak"/>
&lt; OP &gt;::value||<a class="el" href="structviennacl_1_1is__subtraction.html">viennacl::is_subtraction</a><br class="typebreak"/>
&lt; OP &gt;::value), matrix_base<br class="typebreak"/>
&lt; NumericT, F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a79aa95be516cd60f5f8c150ca3ac5890">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S2, OP2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const S3, OP3 &gt;, OP &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation m1 -= m2 @ alpha +- m3 @ beta, where @ is either product or division, and alpha, beta are either CPU or GPU scalars.  <a href="#a79aa95be516cd60f5f8c150ca3ac5890"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a92ebc8a66ef351841c7b7f98e07dbbd7">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a98c6ed5cc7e0ccf8e1c81c535764456c">operator-=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt;, const S1, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4e8e57c6d7a5347efa0e6856969b4fcc">operator-=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9664f3c9e1b076a7d3dff4bce7e4648">operator-=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac3146800de331cf9d37bc17b595f0c4a">operator-=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af69e2a594dbe57b26b362423c99ae15b">operator-=</a> (matrix_base&lt; NumericT, F1 &gt; &amp;m1, const matrix_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;, const matrix_expression&lt; const matrix_base&lt; NumericT, F3 &gt;, const matrix_base&lt; NumericT, F3 &gt;, op_trans &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56">operator*</a> (S1 const &amp;value, matrix_base&lt; NumericT, F &gt; const &amp;m1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix.  <a href="#ac582aeec7eda410e350afb8ee607fa56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, typename <br class="typebreak"/>
matrix_expression&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a46e86d4d82f9a538bd7c36753f93578b">operator*</a> (matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the right.  <a href="#a46e86d4d82f9a538bd7c36753f93578b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, typename <br class="typebreak"/>
matrix_expression&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1345a355bd88a925ece2c3906f44e7b9">operator*</a> (S1 const &amp;val, matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then multiplied with alpha from the left.  <a href="#a1345a355bd88a925ece2c3906f44e7b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a622a198be6623dc648710da7ff66826f">operator*</a> (matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a GPU scalar 'alpha' and returns an expression template.  <a href="#a622a198be6623dc648710da7ff66826f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4">operator*=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a920e8836c8304945668799c249ef35c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, typename <br class="typebreak"/>
matrix_expression&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;::matrix_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f">operator/</a> (matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a> and then divided by alpha.  <a href="#ad2770a13264b6b8348e81926cdcb605f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_div &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc8e629b037b3ae3dd4dccf7fd277250">operator/</a> (matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a GPU scalar 'alpha'.  <a href="#acc8e629b037b3ae3dd4dccf7fd277250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453">operator/=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a2949cf07f6b1bb423de3f634d4b49453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9016294abe2bb92b7c6a36110e73bb3e">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_prod &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a741bc7a80ecd551f3af836b9e760c866">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of the dense matrix class. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
