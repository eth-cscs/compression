<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg::detail::spai Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">detail</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html">spai</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg::detail::spai Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation namespace for sparse approximate inverse preconditioner.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a contigious matrices on GPU.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a contigious vector on GPU.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">fspai_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for FSPAI. Experimental. Contains values for the algorithm. Must be passed to <a class="el" href="classviennacl_1_1linalg_1_1spai__precond.html" title="Implementation of the SParse Approximate Inverse Algorithm.">spai_precond</a> constructor.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1detail_1_1spai_1_1_compare_second.html">CompareSecond</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for SPAI Contains values for the algorithm. Must be passed to <a class="el" href="classviennacl_1_1linalg_1_1spai__precond.html" title="Implementation of the SParse Approximate Inverse Algorithm.">spai_precond</a> constructor.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1sparse__vector.html">sparse_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents sparse vector based on std::map&lt;unsigned int, ScalarType&gt;  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1sparse__vector.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; unsigned <br class="typebreak"/>
int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a06d3ee122975028c980ac38567f46e2b">PairT</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa2ced59584b0590da05723563ab7197d">sym_sparse_matrix_to_stl</a> (MatrixType const &amp;A, std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;STL_A)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac7f16347918f6934172f9098df498356">generateJ</a> (MatrixType const &amp;A, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;J)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a90e73a387cd0349efb76518fdc640745">fill_blocks</a> (std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;A, std::vector&lt; MatrixType &gt; &amp;blocks, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; const &amp;J, std::vector&lt; VectorType &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aead86b3cb81402f5209574d96916f783">cholesky_decompose</a> (MatrixType &amp;A)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0f63bc9c84f29dd35239eff8812f6351">cholesky_solve</a> (MatrixType const &amp;L, VectorType &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afb004c968fad1a6f20255c0a261beaef">computeL</a> (MatrixType const &amp;A, MatrixType &amp;L, MatrixType &amp;L_trans, std::vector&lt; VectorType1 &gt; &amp;Y, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;J)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a923baab8fab478d2e109bbc3644c88a9">computeFSPAI</a> (MatrixType const &amp;A, MatrixType const &amp;PatternA, MatrixType &amp;L, MatrixType &amp;L_trans, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">fspai_tag</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a205ef64d3ccd71ff19a017f59085c541">Print</a> (std::ostream &amp;ostr, InputIterator it_begin, InputIterator it_end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0725fc50d711ff8a32784c3c21e17d8c">write_to_block</a> (VectorType &amp;con_A_I_J, unsigned int start_ind, const std::vector&lt; unsigned int &gt; &amp;I, const std::vector&lt; unsigned int &gt; &amp;J, MatrixType &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa1c7a7fb972c5c7b737a3af2b969f325">print_continious_matrix</a> (VectorType &amp;con_A_I_J, std::vector&lt; cl_uint &gt; &amp;blocks_ind, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad339f698808becbd14551bdcfe1ab77f">print_continious_vector</a> (VectorType &amp;con_v, std::vector&lt; cl_uint &gt; &amp;block_ind, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa41087040735233ad64495329a2556bb">compute_blocks_size</a> (const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, unsigned int &amp;sz, std::vector&lt; cl_uint &gt; &amp;blocks_ind, std::vector&lt; cl_uint &gt; &amp;matrix_dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">**************************************** BLOCK FUNCTIONS ************************************//  <a href="#aa41087040735233ad64495329a2556bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac010c2e64b6e9561322f06d3802bcfca">get_size</a> (const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, SizeType &amp;size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size of particular container of index set.  <a href="#ac010c2e64b6e9561322f06d3802bcfca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2c114b401705a55ae53fe3daa90fa3c9">init_start_inds</a> (const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, std::vector&lt; cl_uint &gt; &amp;start_inds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes start indices of particular index set.  <a href="#a2c114b401705a55ae53fe3daa90fa3c9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a32030f7946d55ad509c37179d284a4d4">dot_prod</a> (const MatrixType &amp;A, unsigned int beg_ind, ScalarType &amp;res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot prod of particular column of martix A with it's self starting at a certain index beg_ind.  <a href="#a32030f7946d55ad509c37179d284a4d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa3e1f2f04f3931e957e3337e7833724b">custom_inner_prod</a> (const MatrixType &amp;A, const VectorType &amp;v, unsigned int col_ind, unsigned int start_ind, ScalarType &amp;res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot prod of particular matrix column with arbitrary vector: A(:, col_ind)  <a href="#aa3e1f2f04f3931e957e3337e7833724b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5d9d13d976580bc859386e2e9bb7d4cc">copy_vector</a> (const MatrixType &amp;A, VectorType &amp;v, const unsigned int beg_ind)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying part of matrix column.  <a href="#a5d9d13d976580bc859386e2e9bb7d4cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a7922f1a62d67535b2477b5cc9fd2eace">householder_vector</a> (const MatrixType &amp;A, unsigned int j, VectorType &amp;v, ScalarType &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Coputation of Householder vector, householder reflection c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.210.  <a href="#a7922f1a62d67535b2477b5cc9fd2eace"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afe04f6451b2a0e30b51847578fe27ce9">apply_householder_reflection</a> (MatrixType &amp;A, unsigned int iter_cnt, VectorType &amp;v, ScalarType b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace application of Householder vector to a matrix A.  <a href="#afe04f6451b2a0e30b51847578fe27ce9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0b957b9a9bae76c548e744f1f8cdfe1c">store_householder_vector</a> (MatrixType &amp;A, unsigned int ind, VectorType &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of vector v in column(A, ind), starting from ind-1 index of a column.  <a href="#a0b957b9a9bae76c548e744f1f8cdfe1c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#abfc5ded9046274cebe96334a9e4ffb1e">single_qr</a> (MatrixType &amp;R, VectorType &amp;b_v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224.  <a href="#abfc5ded9046274cebe96334a9e4ffb1e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aee8018554cb3d6a9d956854b8eed747c">get_max_block_size</a> (const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, SizeType max_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting max size of rows/columns from container of index set.  <a href="#aee8018554cb3d6a9d956854b8eed747c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#adadb3bd7a009090e5bb5242993135700">custom_dot_prod</a> (const MatrixType &amp;A, const VectorType &amp;v, unsigned int ind, ScalarType &amp;res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot_prod(column(A, ind), v) starting from index ind+1.  <a href="#adadb3bd7a009090e5bb5242993135700"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6c38eda65822bdede0673c4f52877b8d">apply_q_trans_vec</a> (const MatrixType &amp;R, const VectorType &amp;b_v, VectorType &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery Q from matrix R and vector of betas b_v.  <a href="#a6c38eda65822bdede0673c4f52877b8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a8abf163c4ab4868b0507997de1292bae">apply_q_trans_mat</a> (const MatrixType &amp;R, const VectorType &amp;b_v, MatrixType &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of Q'*A, where Q is in implicit for lower part of R and vector of betas - b_v.  <a href="#a8abf163c4ab4868b0507997de1292bae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a660f3c99ed64904efc18bedd76c58210">block_qr</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224 performed on GPU.  <a href="#a660f3c99ed64904efc18bedd76c58210"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a90f785f551eb1c8d4f2e89ffcf438b9d">make_rotation_matrix</a> (MatrixType &amp;mat, std::size_t new_size, std::size_t off_diagonal_distance=4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af20412963cd669e1fe798c45e07bdf74">determinant</a> (boost::numeric::ublas::matrix_expression&lt; MatrixType &gt; const &amp;mat_r)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aeeb2e996d9f6fb5e5c2debafff9fbf34">composeNewR</a> (const MatrixType &amp;A, const MatrixType &amp;R_n, MatrixType &amp;R)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new matrix R, that is going to be used in Least Square problem solving.  <a href="#aeeb2e996d9f6fb5e5c2debafff9fbf34"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6a9ca126e971642dafd363cb11fa110c">composeNewVector</a> (const VectorType &amp;v_n, VectorType &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new vector of coefficients beta from QR factorizations(necessary for Q recovery)  <a href="#a6a9ca126e971642dafd363cb11fa110c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a075a99ab429e570b61f20fb90bdccaf4">sparse_norm_2</a> (const SparseVectorType &amp;v, ScalarType &amp;norm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of Euclidean norm for sparse vector.  <a href="#a075a99ab429e570b61f20fb90bdccaf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af6948abaee761e8ffda64c7635a7889b">sparse_inner_prod</a> (const SparseVectorType &amp;v1, const SparseVectorType &amp;v2, ScalarType &amp;res_v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of two sparse vectors.  <a href="#af6948abaee761e8ffda64c7635a7889b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae9c715b109c2347c3239498e35a563a9">buildAugmentedIndexSet</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;res, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;J_u, const <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Building a new set of column indices J_u, cf. Kallischko dissertation p.31.  <a href="#ae9c715b109c2347c3239498e35a563a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a138190b493ecd9c8f9074a67bf565fc6">buildNewRowSet</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; unsigned int &gt; &amp;I, const std::vector&lt; unsigned int &gt; &amp;J_n, std::vector&lt; unsigned int &gt; &amp;I_n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Building a new indices to current set of row indices I_n, cf. Kallischko dissertation p.32.  <a href="#a138190b493ecd9c8f9074a67bf565fc6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a376de42fc42309d290f10555e23e9d81">QRBlockComposition</a> (const MatrixType &amp;A_I_J, const MatrixType &amp;A_I_J_u, MatrixType &amp;A_I_u_J_u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new block for QR factorization cf. Kallischko dissertation p.82, figure 4.7.  <a href="#a376de42fc42309d290f10555e23e9d81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SparseVectorType , typename DenseMatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfa51116864ecf58e66fc7bfe03d80ea">block_update</a> (const SparseMatrixType &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; VectorType &gt; &amp;g_b_v, std::vector&lt; DenseMatrixType &gt; &amp;g_A_I_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU-based dynamic update for SPAI preconditioner.  <a href="#acfa51116864ecf58e66fc7bfe03d80ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa04be1672c95a46a1d9b4106643c5fdb">block_q_multiplication</a> (const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J_u, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multiplication Q'*A(I, \tilde J) on GPU.  <a href="#aa04be1672c95a46a1d9b4106643c5fdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acd830cded5250d6523f484870703fbad">assemble_qr_row_inds</a> (const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; SizeType &gt; &gt; g_J, const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I_u, std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I_q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of container of index row sets: I_q, row indices for new "QR block".  <a href="#acd830cded5250d6523f484870703fbad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac5fe371f666bc091b5da923522aeed3d">assemble_qr_block</a> (const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J_u, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I_u, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I_q, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, <a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a>&lt; cl_mem &gt; &amp;matrix_dimensions, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_u_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, const bool is_empty_block)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs assembly for new QR block.  <a href="#ac5fe371f666bc091b5da923522aeed3d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a9fe130496352d6067ab8ce9477776562">assemble_r</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_u_J_u_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl_u, std::vector&lt; cl_uint &gt; &amp;g_is_update)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs assembly for new R matrix on GPU.  <a href="#a9fe130496352d6067ab8ce9477776562"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT, typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aeb076e549b31874fcca5fb2e162a64fa">block_update</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; cl_uint &gt; &amp;g_is_update, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU-based block update.  <a href="#aeb076e549b31874fcca5fb2e162a64fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2ec636a59e7b248a763dc6dde59c7e07">isInIndexSet</a> (const std::vector&lt; SizeType &gt; &amp;J, SizeType ind)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if element ind is in set {J}.  <a href="#a2ec636a59e7b248a763dc6dde59c7e07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa03f652c4c869756c9c3c37b71f71402">fanOutVector</a> (const VectorType &amp;m_in, const std::vector&lt; unsigned int &gt; &amp;J, SparseVectorType &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects solution of LS problem onto original column m.  <a href="#aa03f652c4c869756c9c3c37b71f71402"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac153d290fedda8cc8e86e5f5a7ac6e3e">backwardSolve</a> (const MatrixType &amp;R, const VectorType &amp;y, VectorType &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of linear:R*x=y system by backward substitution.  <a href="#ac153d290fedda8cc8e86e5f5a7ac6e3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab4b81831eeeac471b483c3740af637bb">projectI</a> (const std::vector&lt; unsigned int &gt; &amp;I, VectorType &amp;y, unsigned int ind)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform projection of set I on the unit-vector.  <a href="#ab4b81831eeeac471b483c3740af637bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a93a93380dfb35e96b351d5cf8fe02d24">buildColumnIndexSet</a> (const SparseVectorType &amp;v, std::vector&lt; unsigned int &gt; &amp;J)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds index set of projected columns for current column of preconditioner.  <a href="#a93a93380dfb35e96b351d5cf8fe02d24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af2ee40cec855188f921aab00d6c38dca">initPreconditioner</a> (const SparseMatrixType &amp;A, SparseMatrixType &amp;M)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize preconditioner with sparcity pattern = p(A)  <a href="#af2ee40cec855188f921aab00d6c38dca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2e7b713019425fe974c5ee04aa023d72">projectRows</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Row projection for matrix A(:,J) -&gt; A(I,J), building index set of non-zero rows.  <a href="#a2e7b713019425fe974c5ee04aa023d72"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa86fb32e08299d4229632a369ae90424">print_sparse_vector</a> (const SparseVectorType &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DenseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a37ad35e75e5e5f8e6930a154bb2598bd">print_matrix</a> (DenseMatrixType &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa82527983ddd936b654bd142c29cfaa7">add_sparse_vectors</a> (const SparseVectorType &amp;v, const ScalarType b, SparseVectorType &amp;res_v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sparse vectors res_v = b*v.  <a href="#aa82527983ddd936b654bd142c29cfaa7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4c2ecbe87833ee4a1095d1288b6e23ea">compute_spai_residual</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;v, const unsigned int ind, SparseVectorType &amp;res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of residual res = A*v - e.  <a href="#a4c2ecbe87833ee4a1095d1288b6e23ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#add3a259ffe30284ba2b64af830014946">build_index_set</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;v, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up index set of columns and rows for certain column.  <a href="#add3a259ffe30284ba2b64af830014946"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename DenseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6ff5ba3d888731cbc42c06ceb968fd0f">initProjectSubMatrix</a> (const SparseMatrixType &amp;A_in, const std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I, DenseMatrixType &amp;A_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a dense matrix from a sparse one.  <a href="#a6ff5ba3d888731cbc42c06ceb968fd0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename DenseMatrixType , typename SparseVectorType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae174d76538897748f7f77dca13ca2dc5">block_set_up</a> (const SparseMatrixType &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; DenseMatrixType &gt; &amp;g_A_I_J, std::vector&lt; VectorType &gt; &amp;g_b_v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up blocks and QR factorizing them on CPU.  <a href="#ae174d76538897748f7f77dca13ca2dc5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab013846575b245ce2071c46ea0e32ac7">index_set_up</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up index set of columns and rows for all columns.  <a href="#ab013846575b245ce2071c46ea0e32ac7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT, typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad702796db7c802a77391a98f0328d48f">block_set_up</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; cl_uint &gt; g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up blocks and QR factorizing them on GPU.  <a href="#ad702796db7c802a77391a98f0328d48f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afd886f8812c2cbb0b6477df76c19867a">custom_fan_out</a> (const std::vector&lt; ScalarType &gt; &amp;m_in, unsigned int start_m_ind, const std::vector&lt; unsigned int &gt; &amp;J, SparseVectorType &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elicitation of sparse vector m for particular column from m_in - contigious vector for all columns.  <a href="#afd886f8812c2cbb0b6477df76c19867a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5bb32d6e12d240de6fc66405ca934935">least_square_solve</a> (std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; cl_uint &gt; &amp;g_is_update, const <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on GPU.  <a href="#a5bb32d6e12d240de6fc66405ca934935"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorType , typename DenseMatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af215e182f221b29e89f23c3439412ec0">least_square_solve</a> (const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; DenseMatrixType &gt; &amp;g_R, std::vector&lt; VectorType &gt; &amp;g_b_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; SparseVectorType &gt; &amp;M_v, const <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on CPU.  <a href="#af215e182f221b29e89f23c3439412ec0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aea8b96ecccca6f209e810669f0d13e36">is_all_update</a> (VectorType &amp;parallel_is_update)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad9dfaad8c5bcfe650993902d8312f56d">vectorize_column_matrix</a> (const SparseMatrixType &amp;M_in, std::vector&lt; SparseVectorType &gt; &amp;M_v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on CPU.  <a href="#ad9dfaad8c5bcfe650993902d8312f56d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab438581d4a972367d59ef0e227b2c34b">vectorize_row_matrix</a> (const SparseMatrixType &amp;M_in, std::vector&lt; SparseVectorType &gt; &amp;M_v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a30c75416ab36d5d8ab07b0b1e1105e13">write_set_to_array</a> (const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;ind_set, std::vector&lt; cl_uint &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#adc4e8c2caaa9c8d755ee2e5501189d7f">block_assembly</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, bool &amp;is_empty_block)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of blocks on GPU by a gived set of row indices: g_I and column indices: g_J.  <a href="#adc4e8c2caaa9c8d755ee2e5501189d7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SparseVectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a836d6077f28fa0dd414ee263f9890856">insert_sparse_columns</a> (const std::vector&lt; SparseVectorType &gt; &amp;M_v, SparseMatrixType &amp;M, bool is_right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of vectorized matrix column into original sparse matrix.  <a href="#a836d6077f28fa0dd414ee263f9890856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a12be2f8612b5d22bfa59f372c14d299f">sparse_transpose</a> (const MatrixType &amp;A_in, MatrixType &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposition of sparse matrix.  <a href="#a12be2f8612b5d22bfa59f372c14d299f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfc30764d316e99f4fdd41bb09a95688">computeSPAI</a> (const MatrixType &amp;A, MatrixType &amp;M, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of SPAI preconditioner on CPU.  <a href="#acfc30764d316e99f4fdd41bb09a95688"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5a619422bbb86af44e2520d18ad7944b">computeSPAI</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;cpu_A, boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;cpu_M, <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;M, const <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of SPAI preconditioner on GPU.  <a href="#a5a619422bbb86af44e2520d18ad7944b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation namespace for sparse approximate inverse preconditioner. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a06d3ee122975028c980ac38567f46e2b"></a><!-- doxytag: member="viennacl::linalg::detail::spai::PairT" ref="a06d3ee122975028c980ac38567f46e2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;unsigned int, double&gt; <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a06d3ee122975028c980ac38567f46e2b">PairT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa82527983ddd936b654bd142c29cfaa7"></a><!-- doxytag: member="viennacl::linalg::detail::spai::add_sparse_vectors" ref="aa82527983ddd936b654bd142c29cfaa7" args="(const SparseVectorType &amp;v, const ScalarType b, SparseVectorType &amp;res_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa82527983ddd936b654bd142c29cfaa7">viennacl::linalg::detail::spai::add_sparse_vectors</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>res_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two sparse vectors res_v = b*v. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">b</td><td>scalar </td></tr>
    <tr><td class="paramname">res_v</td><td>output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe04f6451b2a0e30b51847578fe27ce9"></a><!-- doxytag: member="viennacl::linalg::detail::spai::apply_householder_reflection" ref="afe04f6451b2a0e30b51847578fe27ce9" args="(MatrixType &amp;A, unsigned int iter_cnt, VectorType &amp;v, ScalarType b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afe04f6451b2a0e30b51847578fe27ce9">viennacl::linalg::detail::spai::apply_householder_reflection</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iter_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace application of Householder vector to a matrix A. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">iter_cnt</td><td>current iteration </td></tr>
    <tr><td class="paramname">v</td><td>Householder vector </td></tr>
    <tr><td class="paramname">b</td><td>beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8abf163c4ab4868b0507997de1292bae"></a><!-- doxytag: member="viennacl::linalg::detail::spai::apply_q_trans_mat" ref="a8abf163c4ab4868b0507997de1292bae" args="(const MatrixType &amp;R, const VectorType &amp;b_v, MatrixType &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a8abf163c4ab4868b0507997de1292bae">viennacl::linalg::detail::spai::apply_q_trans_mat</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplication of Q'*A, where Q is in implicit for lower part of R and vector of betas - b_v. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
    <tr><td class="paramname">A</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c38eda65822bdede0673c4f52877b8d"></a><!-- doxytag: member="viennacl::linalg::detail::spai::apply_q_trans_vec" ref="a6c38eda65822bdede0673c4f52877b8d" args="(const MatrixType &amp;R, const VectorType &amp;b_v, VectorType &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6c38eda65822bdede0673c4f52877b8d">viennacl::linalg::detail::spai::apply_q_trans_vec</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recovery Q from matrix R and vector of betas b_v. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
    <tr><td class="paramname">y</td><td>output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5fe371f666bc091b5da923522aeed3d"></a><!-- doxytag: member="viennacl::linalg::detail::spai::assemble_qr_block" ref="ac5fe371f666bc091b5da923522aeed3d" args="(const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J_u, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I_u, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I_q, block_matrix &amp;g_A_I_J_u_vcl, viennacl::ocl::handle&lt; cl_mem &gt; &amp;matrix_dimensions, block_matrix &amp;g_A_I_u_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, const bool is_empty_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac5fe371f666bc091b5da923522aeed3d">viennacl::linalg::detail::spai::assemble_qr_block</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a>&lt; cl_mem &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_u_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_empty_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs assembly for new QR block. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J_u</td><td>container of new column indices </td></tr>
    <tr><td class="paramname">g_I_u</td><td>container of new row indices </td></tr>
    <tr><td class="paramname">g_I_q</td><td>container of row indices for new QR blocks </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>blocks of Q'*A(I, \tilde J) </td></tr>
    <tr><td class="paramname">matrix_dimensions</td><td>array with matrix dimensions for all blocks </td></tr>
    <tr><td class="paramname">g_A_I_u_J_u_vcl</td><td>blocks A(\tilde I, \tilde J) </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with update indicators </td></tr>
    <tr><td class="paramname">is_empty_block</td><td>indicator if all previous blocks A(\tilde I, \tilde J) - are empty, in case if they are empty kernel with smaller number of arguments is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd830cded5250d6523f484870703fbad"></a><!-- doxytag: member="viennacl::linalg::detail::spai::assemble_qr_row_inds" ref="acd830cded5250d6523f484870703fbad" args="(const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; SizeType &gt; &gt; g_J, const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I_u, std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;g_I_q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acd830cded5250d6523f484870703fbad">viennacl::linalg::detail::spai::assemble_qr_row_inds</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assembly of container of index row sets: I_q, row indices for new "QR block". </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I_u</td><td>container of new row indices </td></tr>
    <tr><td class="paramname">g_I_q</td><td>container of row indices for new QR blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fe130496352d6067ab8ce9477776562"></a><!-- doxytag: member="viennacl::linalg::detail::spai::assemble_r" ref="a9fe130496352d6067ab8ce9477776562" args="(std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, block_matrix &amp;g_A_I_J_vcl, block_matrix &amp;g_A_I_J_u_vcl, block_matrix &amp;g_A_I_u_J_u_vcl, block_vector &amp;g_bv_vcl, block_vector &amp;g_bv_vcl_u, std::vector&lt; cl_uint &gt; &amp;g_is_update)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a9fe130496352d6067ab8ce9477776562">viennacl::linalg::detail::spai::assemble_r</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_u_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs assembly for new R matrix on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>container of block matrices Q'*A(I, \tilde J) </td></tr>
    <tr><td class="paramname">g_A_I_u_J_u_vcl</td><td>container of block matrices QR factored on current iteration </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors from previous iteration </td></tr>
    <tr><td class="paramname">g_bv_vcl_u</td><td>block of updated beta vectors got after recent QR factorization </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac153d290fedda8cc8e86e5f5a7ac6e3e"></a><!-- doxytag: member="viennacl::linalg::detail::spai::backwardSolve" ref="ac153d290fedda8cc8e86e5f5a7ac6e3e" args="(const MatrixType &amp;R, const VectorType &amp;y, VectorType &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac153d290fedda8cc8e86e5f5a7ac6e3e">viennacl::linalg::detail::spai::backwardSolve</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solution of linear:R*x=y system by backward substitution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>uppertriangular matrix </td></tr>
    <tr><td class="paramname">y</td><td>right handside vector </td></tr>
    <tr><td class="paramname">x</td><td>solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc4e8c2caaa9c8d755ee2e5501189d7f"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_assembly" ref="adc4e8c2caaa9c8d755ee2e5501189d7f" args="(const viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, block_matrix &amp;g_A_I_J_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, bool &amp;is_empty_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#adc4e8c2caaa9c8d755ee2e5501189d7f">viennacl::linalg::detail::spai::block_assembly</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_empty_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assembly of blocks on GPU by a gived set of row indices: g_I and column indices: g_J. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>intial sparse matrix </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index set </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index set </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious blocks A(I, J) using GPU memory </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">is_empty_block</td><td>parameter that indicates if no block were assembled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa04be1672c95a46a1d9b4106643c5fdb"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_q_multiplication" ref="aa04be1672c95a46a1d9b4106643c5fdb" args="(const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J_u, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, block_matrix &amp;g_A_I_J_vcl, block_vector &amp;g_bv_vcl, block_matrix &amp;g_A_I_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa04be1672c95a46a1d9b4106643c5fdb">viennacl::linalg::detail::spai::block_q_multiplication</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs multiplication Q'*A(I, \tilde J) on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_J_u</td><td>container of sets of new column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>block matrix composed from previous blocks, they are blocks of R </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>block of matrices A(I, \tilde J) </td></tr>
    <tr><td class="paramname">g_is_update</td><td>indicators, that show if a certain block should be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a660f3c99ed64904efc18bedd76c58210"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_qr" ref="a660f3c99ed64904efc18bedd76c58210" args="(std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, block_matrix &amp;g_A_I_J_vcl, block_vector &amp;g_bv_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a660f3c99ed64904efc18bedd76c58210">viennacl::linalg::detail::spai::block_qr</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224 performed on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious matrices, GPU memory is used </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>contigios vectors beta, GPU memory is used </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container of indicators that show active blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae174d76538897748f7f77dca13ca2dc5"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_set_up" ref="ae174d76538897748f7f77dca13ca2dc5" args="(const SparseMatrixType &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; DenseMatrixType &gt; &amp;g_A_I_J, std::vector&lt; VectorType &gt; &amp;g_b_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae174d76538897748f7f77dca13ca2dc5">viennacl::linalg::detail::spai::block_set_up</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting up blocks and QR factorizing them on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of dense matrices -&gt; R matrices after QR factorization </td></tr>
    <tr><td class="paramname">g_b_v</td><td>container of vectors beta, necessary for Q recovery </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad702796db7c802a77391a98f0328d48f"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_set_up" ref="ad702796db7c802a77391a98f0328d48f" args="(const viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; cl_uint &gt; g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, block_matrix &amp;g_A_I_J, block_vector &amp;g_bv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae174d76538897748f7f77dca13ca2dc5">viennacl::linalg::detail::spai::block_set_up</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting up blocks and QR factorizing them on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container that indicates which blocks are active </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of dense matrices -&gt; R matrices after QR factorization </td></tr>
    <tr><td class="paramname">g_bv</td><td>container of vectors beta, necessary for Q recovery </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfa51116864ecf58e66fc7bfe03d80ea"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_update" ref="acfa51116864ecf58e66fc7bfe03d80ea" args="(const SparseMatrixType &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; VectorType &gt; &amp;g_b_v, std::vector&lt; DenseMatrixType &gt; &amp;g_A_I_J, spai_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfa51116864ecf58e66fc7bfe03d80ea">viennacl::linalg::detail::spai::block_update</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CPU-based dynamic update for SPAI preconditioner. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals for all columns </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index sets for all columns </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index sets for all columns </td></tr>
    <tr><td class="paramname">g_b_v</td><td>container of vectors of beta for Q recovery(cf. Golub Van Loan "Matrix Computations", 3rd edition p.211) </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI configuration tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb076e549b31874fcca5fb2e162a64fa"></a><!-- doxytag: member="viennacl::linalg::detail::spai::block_update" ref="aeb076e549b31874fcca5fb2e162a64fa" args="(const viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; cl_uint &gt; &amp;g_is_update, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, block_matrix &amp;g_A_I_J_vcl, block_vector &amp;g_bv_vcl, spai_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfa51116864ecf58e66fc7bfe03d80ea">viennacl::linalg::detail::spai::block_update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GPU-based block update. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals for all columns </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index sets for all columns </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index sets for all columns </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors from previous iteration </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI configuration tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add3a259ffe30284ba2b64af830014946"></a><!-- doxytag: member="viennacl::linalg::detail::spai::build_index_set" ref="add3a259ffe30284ba2b64af830014946" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;v, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#add3a259ffe30284ba2b64af830014946">viennacl::linalg::detail::spai::build_index_set</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting up index set of columns and rows for certain column. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">v</td><td>current column of preconditioner matrix </td></tr>
    <tr><td class="paramname">J</td><td>set of column indices </td></tr>
    <tr><td class="paramname">I</td><td>set of row indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9c715b109c2347c3239498e35a563a9"></a><!-- doxytag: member="viennacl::linalg::detail::spai::buildAugmentedIndexSet" ref="ae9c715b109c2347c3239498e35a563a9" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;res, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;J_u, const spai_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae9c715b109c2347c3239498e35a563a9">viennacl::linalg::detail::spai::buildAugmentedIndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Building a new set of column indices J_u, cf. Kallischko dissertation p.31. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">res</td><td>residual vector </td></tr>
    <tr><td class="paramname">J</td><td>set of column indices </td></tr>
    <tr><td class="paramname">J_u</td><td>set of new column indices </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI tag with parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93a93380dfb35e96b351d5cf8fe02d24"></a><!-- doxytag: member="viennacl::linalg::detail::spai::buildColumnIndexSet" ref="a93a93380dfb35e96b351d5cf8fe02d24" args="(const SparseVectorType &amp;v, std::vector&lt; unsigned int &gt; &amp;J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a93a93380dfb35e96b351d5cf8fe02d24">viennacl::linalg::detail::spai::buildColumnIndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds index set of projected columns for current column of preconditioner. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>current column of preconditioner </td></tr>
    <tr><td class="paramname">J</td><td>output - index set of non-zero columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a138190b493ecd9c8f9074a67bf565fc6"></a><!-- doxytag: member="viennacl::linalg::detail::spai::buildNewRowSet" ref="a138190b493ecd9c8f9074a67bf565fc6" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; unsigned int &gt; &amp;I, const std::vector&lt; unsigned int &gt; &amp;J_n, std::vector&lt; unsigned int &gt; &amp;I_n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a138190b493ecd9c8f9074a67bf565fc6">viennacl::linalg::detail::spai::buildNewRowSet</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Building a new indices to current set of row indices I_n, cf. Kallischko dissertation p.32. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">I</td><td>set of previous determined row indices </td></tr>
    <tr><td class="paramname">J_n</td><td>set of new column indices </td></tr>
    <tr><td class="paramname">I_n</td><td>set of new indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aead86b3cb81402f5209574d96916f783"></a><!-- doxytag: member="viennacl::linalg::detail::spai::cholesky_decompose" ref="aead86b3cb81402f5209574d96916f783" args="(MatrixType &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aead86b3cb81402f5209574d96916f783">viennacl::linalg::detail::spai::cholesky_decompose</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f63bc9c84f29dd35239eff8812f6351"></a><!-- doxytag: member="viennacl::linalg::detail::spai::cholesky_solve" ref="a0f63bc9c84f29dd35239eff8812f6351" args="(MatrixType const &amp;L, VectorType &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0f63bc9c84f29dd35239eff8812f6351">viennacl::linalg::detail::spai::cholesky_solve</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeeb2e996d9f6fb5e5c2debafff9fbf34"></a><!-- doxytag: member="viennacl::linalg::detail::spai::composeNewR" ref="aeeb2e996d9f6fb5e5c2debafff9fbf34" args="(const MatrixType &amp;A, const MatrixType &amp;R_n, MatrixType &amp;R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aeeb2e996d9f6fb5e5c2debafff9fbf34">viennacl::linalg::detail::spai::composeNewR</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composition of new matrix R, that is going to be used in Least Square problem solving. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix Q'*A(I, \tilde J), where \tilde J - set of new column indices </td></tr>
    <tr><td class="paramname">R_n</td><td>matrix A_Iu_J_u after QR factorization </td></tr>
    <tr><td class="paramname">R</td><td>previously composed matrix R </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a9ca126e971642dafd363cb11fa110c"></a><!-- doxytag: member="viennacl::linalg::detail::spai::composeNewVector" ref="a6a9ca126e971642dafd363cb11fa110c" args="(const VectorType &amp;v_n, VectorType &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6a9ca126e971642dafd363cb11fa110c">viennacl::linalg::detail::spai::composeNewVector</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composition of new vector of coefficients beta from QR factorizations(necessary for Q recovery) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v_n</td><td>new vector from last QR factorization </td></tr>
    <tr><td class="paramname">v</td><td>composition of previous vectors from QR factorizations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41087040735233ad64495329a2556bb"></a><!-- doxytag: member="viennacl::linalg::detail::spai::compute_blocks_size" ref="aa41087040735233ad64495329a2556bb" args="(const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, unsigned int &amp;sz, std::vector&lt; cl_uint &gt; &amp;blocks_ind, std::vector&lt; cl_uint &gt; &amp;matrix_dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa41087040735233ad64495329a2556bb">viennacl::linalg::detail::spai::compute_blocks_size</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>**************************************** BLOCK FUNCTIONS ************************************// </p>
<p>Computes size of elements, start indices and matrix dimensions for a certain block </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">sz</td><td>general size for all elements in a certain block </td></tr>
    <tr><td class="paramname">blocks_ind</td><td>start indices in a certain </td></tr>
    <tr><td class="paramname">matrix_dims</td><td>matrix dimensions for each block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c2ecbe87833ee4a1095d1288b6e23ea"></a><!-- doxytag: member="viennacl::linalg::detail::spai::compute_spai_residual" ref="a4c2ecbe87833ee4a1095d1288b6e23ea" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const SparseVectorType &amp;v, const unsigned int ind, SparseVectorType &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4c2ecbe87833ee4a1095d1288b6e23ea">viennacl::linalg::detail::spai::compute_spai_residual</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computation of residual res = A*v - e. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized input sparse matrix </td></tr>
    <tr><td class="paramname">v</td><td>sparse vector, in this case new column of preconditioner matrix </td></tr>
    <tr><td class="paramname">ind</td><td>index for current column </td></tr>
    <tr><td class="paramname">res</td><td>residual </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a923baab8fab478d2e109bbc3644c88a9"></a><!-- doxytag: member="viennacl::linalg::detail::spai::computeFSPAI" ref="a923baab8fab478d2e109bbc3644c88a9" args="(MatrixType const &amp;A, MatrixType const &amp;PatternA, MatrixType &amp;L, MatrixType &amp;L_trans, fspai_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a923baab8fab478d2e109bbc3644c88a9">viennacl::linalg::detail::spai::computeFSPAI</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>PatternA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>L_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fspai_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb004c968fad1a6f20255c0a261beaef"></a><!-- doxytag: member="viennacl::linalg::detail::spai::computeL" ref="afb004c968fad1a6f20255c0a261beaef" args="(MatrixType const &amp;A, MatrixType &amp;L, MatrixType &amp;L_trans, std::vector&lt; VectorType1 &gt; &amp;Y, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afb004c968fad1a6f20255c0a261beaef">viennacl::linalg::detail::spai::computeL</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>L_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acfc30764d316e99f4fdd41bb09a95688"></a><!-- doxytag: member="viennacl::linalg::detail::spai::computeSPAI" ref="acfc30764d316e99f4fdd41bb09a95688" args="(const MatrixType &amp;A, MatrixType &amp;M, spai_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfc30764d316e99f4fdd41bb09a95688">viennacl::linalg::detail::spai::computeSPAI</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction of SPAI preconditioner on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">M</td><td>output preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a619422bbb86af44e2520d18ad7944b"></a><!-- doxytag: member="viennacl::linalg::detail::spai::computeSPAI" ref="a5a619422bbb86af44e2520d18ad7944b" args="(const viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;A, const boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;cpu_A, boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;cpu_M, viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;M, const spai_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acfc30764d316e99f4fdd41bb09a95688">viennacl::linalg::detail::spai::computeSPAI</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::compressed_matrix&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction of SPAI preconditioner on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">cpu_A</td><td>copy of initial matrix on CPU </td></tr>
    <tr><td class="paramname">cpu_M</td><td>output preconditioner on CPU </td></tr>
    <tr><td class="paramname">M</td><td>output preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI tag class with parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d9d13d976580bc859386e2e9bb7d4cc"></a><!-- doxytag: member="viennacl::linalg::detail::spai::copy_vector" ref="a5d9d13d976580bc859386e2e9bb7d4cc" args="(const MatrixType &amp;A, VectorType &amp;v, const unsigned int beg_ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5d9d13d976580bc859386e2e9bb7d4cc">viennacl::linalg::detail::spai::copy_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>beg_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copying part of matrix column. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">v</td><td>output vector </td></tr>
    <tr><td class="paramname">beg_ind</td><td>start index for copying </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adadb3bd7a009090e5bb5242993135700"></a><!-- doxytag: member="viennacl::linalg::detail::spai::custom_dot_prod" ref="adadb3bd7a009090e5bb5242993135700" args="(const MatrixType &amp;A, const VectorType &amp;v, unsigned int ind, ScalarType &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#adadb3bd7a009090e5bb5242993135700">viennacl::linalg::detail::spai::custom_dot_prod</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dot_prod(column(A, ind), v) starting from index ind+1. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramname">ind</td><td>index </td></tr>
    <tr><td class="paramname">res</td><td>result value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd886f8812c2cbb0b6477df76c19867a"></a><!-- doxytag: member="viennacl::linalg::detail::spai::custom_fan_out" ref="afd886f8812c2cbb0b6477df76c19867a" args="(const std::vector&lt; ScalarType &gt; &amp;m_in, unsigned int start_m_ind, const std::vector&lt; unsigned int &gt; &amp;J, SparseVectorType &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afd886f8812c2cbb0b6477df76c19867a">viennacl::linalg::detail::spai::custom_fan_out</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_m_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elicitation of sparse vector m for particular column from m_in - contigious vector for all columns. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m_in</td><td>contigious sparse vector for all columns </td></tr>
    <tr><td class="paramname">start_m_ind</td><td>start index of particular vector </td></tr>
    <tr><td class="paramname">J</td><td>column index set </td></tr>
    <tr><td class="paramname">m</td><td>sparse vector for particular column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3e1f2f04f3931e957e3337e7833724b"></a><!-- doxytag: member="viennacl::linalg::detail::spai::custom_inner_prod" ref="aa3e1f2f04f3931e957e3337e7833724b" args="(const MatrixType &amp;A, const VectorType &amp;v, unsigned int col_ind, unsigned int start_ind, ScalarType &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa3e1f2f04f3931e957e3337e7833724b">viennacl::linalg::detail::spai::custom_inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dot prod of particular matrix column with arbitrary vector: A(:, col_ind) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramname">col_ind</td><td>starting column index </td></tr>
    <tr><td class="paramname">start_ind</td><td>starting index inside column </td></tr>
    <tr><td class="paramname">res</td><td>result of dot product </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af20412963cd669e1fe798c45e07bdf74"></a><!-- doxytag: member="viennacl::linalg::detail::spai::determinant" ref="af20412963cd669e1fe798c45e07bdf74" args="(boost::numeric::ublas::matrix_expression&lt; MatrixType &gt; const &amp;mat_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af20412963cd669e1fe798c45e07bdf74">viennacl::linalg::detail::spai::determinant</a> </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix_expression&lt; MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a32030f7946d55ad509c37179d284a4d4"></a><!-- doxytag: member="viennacl::linalg::detail::spai::dot_prod" ref="a32030f7946d55ad509c37179d284a4d4" args="(const MatrixType &amp;A, unsigned int beg_ind, ScalarType &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a32030f7946d55ad509c37179d284a4d4">viennacl::linalg::detail::spai::dot_prod</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>beg_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dot prod of particular column of martix A with it's self starting at a certain index beg_ind. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">beg_ind</td><td>starting index </td></tr>
    <tr><td class="paramname">res</td><td>result of dot product </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa03f652c4c869756c9c3c37b71f71402"></a><!-- doxytag: member="viennacl::linalg::detail::spai::fanOutVector" ref="aa03f652c4c869756c9c3c37b71f71402" args="(const VectorType &amp;m_in, const std::vector&lt; unsigned int &gt; &amp;J, SparseVectorType &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa03f652c4c869756c9c3c37b71f71402">viennacl::linalg::detail::spai::fanOutVector</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>m_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects solution of LS problem onto original column m. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m_in</td><td>solution of LS </td></tr>
    <tr><td class="paramname">J</td><td>set of non-zero columns </td></tr>
    <tr><td class="paramname">m</td><td>original column of M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90e73a387cd0349efb76518fdc640745"></a><!-- doxytag: member="viennacl::linalg::detail::spai::fill_blocks" ref="a90e73a387cd0349efb76518fdc640745" args="(std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;A, std::vector&lt; MatrixType &gt; &amp;blocks, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; const &amp;J, std::vector&lt; VectorType &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a90e73a387cd0349efb76518fdc640745">viennacl::linalg::detail::spai::fill_blocks</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7f16347918f6934172f9098df498356"></a><!-- doxytag: member="viennacl::linalg::detail::spai::generateJ" ref="ac7f16347918f6934172f9098df498356" args="(MatrixType const &amp;A, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac7f16347918f6934172f9098df498356">viennacl::linalg::detail::spai::generateJ</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee8018554cb3d6a9d956854b8eed747c"></a><!-- doxytag: member="viennacl::linalg::detail::spai::get_max_block_size" ref="aee8018554cb3d6a9d956854b8eed747c" args="(const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, SizeType max_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aee8018554cb3d6a9d956854b8eed747c">viennacl::linalg::detail::spai::get_max_block_size</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Getting max size of rows/columns from container of index set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index set </td></tr>
    <tr><td class="paramname">max_size</td><td>max size that corresponds to that container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac010c2e64b6e9561322f06d3802bcfca"></a><!-- doxytag: member="viennacl::linalg::detail::spai::get_size" ref="ac010c2e64b6e9561322f06d3802bcfca" args="(const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, SizeType &amp;size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac010c2e64b6e9561322f06d3802bcfca">viennacl::linalg::detail::spai::get_size</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes size of particular container of index set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index sets </td></tr>
    <tr><td class="paramname">size</td><td>output size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7922f1a62d67535b2477b5cc9fd2eace"></a><!-- doxytag: member="viennacl::linalg::detail::spai::householder_vector" ref="a7922f1a62d67535b2477b5cc9fd2eace" args="(const MatrixType &amp;A, unsigned int j, VectorType &amp;v, ScalarType &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a7922f1a62d67535b2477b5cc9fd2eace">viennacl::linalg::detail::spai::householder_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coputation of Householder vector, householder reflection c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.210. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">j</td><td>start index for computations </td></tr>
    <tr><td class="paramname">v</td><td>output Householder vector </td></tr>
    <tr><td class="paramname">b</td><td>beta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab013846575b245ce2071c46ea0e32ac7"></a><!-- doxytag: member="viennacl::linalg::detail::spai::index_set_up" ref="ab013846575b245ce2071c46ea0e32ac7" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab013846575b245ce2071c46ea0e32ac7">viennacl::linalg::detail::spai::index_set_up</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting up index set of columns and rows for all columns. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c114b401705a55ae53fe3daa90fa3c9"></a><!-- doxytag: member="viennacl::linalg::detail::spai::init_start_inds" ref="a2c114b401705a55ae53fe3daa90fa3c9" args="(const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;inds, std::vector&lt; cl_uint &gt; &amp;start_inds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2c114b401705a55ae53fe3daa90fa3c9">viennacl::linalg::detail::spai::init_start_inds</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_inds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes start indices of particular index set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index sets </td></tr>
    <tr><td class="paramname">start_inds</td><td>output index set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2ee40cec855188f921aab00d6c38dca"></a><!-- doxytag: member="viennacl::linalg::detail::spai::initPreconditioner" ref="af2ee40cec855188f921aab00d6c38dca" args="(const SparseMatrixType &amp;A, SparseMatrixType &amp;M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af2ee40cec855188f921aab00d6c38dca">viennacl::linalg::detail::spai::initPreconditioner</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize preconditioner with sparcity pattern = p(A) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">M</td><td>output matrix - initialized preconditioner </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ff5ba3d888731cbc42c06ceb968fd0f"></a><!-- doxytag: member="viennacl::linalg::detail::spai::initProjectSubMatrix" ref="a6ff5ba3d888731cbc42c06ceb968fd0f" args="(const SparseMatrixType &amp;A_in, const std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I, DenseMatrixType &amp;A_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6ff5ba3d888731cbc42c06ceb968fd0f">viennacl::linalg::detail::spai::initProjectSubMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a dense matrix from a sparse one. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>Riginal sparse matrix </td></tr>
    <tr><td class="paramname">J</td><td>Set of column indices </td></tr>
    <tr><td class="paramname">I</td><td>Set of row indices </td></tr>
    <tr><td class="paramname">A_out</td><td>dense matrix output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a836d6077f28fa0dd414ee263f9890856"></a><!-- doxytag: member="viennacl::linalg::detail::spai::insert_sparse_columns" ref="a836d6077f28fa0dd414ee263f9890856" args="(const std::vector&lt; SparseVectorType &gt; &amp;M_v, SparseMatrixType &amp;M, bool is_right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a836d6077f28fa0dd414ee263f9890856">viennacl::linalg::detail::spai::insert_sparse_columns</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insertion of vectorized matrix column into original sparse matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M_v</td><td>column-major vectorized matrix </td></tr>
    <tr><td class="paramname">M</td><td>original sparse matrix </td></tr>
    <tr><td class="paramname">is_right</td><td>indicates if matrix should be transposed in the output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea8b96ecccca6f209e810669f0d13e36"></a><!-- doxytag: member="viennacl::linalg::detail::spai::is_all_update" ref="aea8b96ecccca6f209e810669f0d13e36" args="(VectorType &amp;parallel_is_update)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aea8b96ecccca6f209e810669f0d13e36">viennacl::linalg::detail::spai::is_all_update</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>parallel_is_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ec636a59e7b248a763dc6dde59c7e07"></a><!-- doxytag: member="viennacl::linalg::detail::spai::isInIndexSet" ref="a2ec636a59e7b248a763dc6dde59c7e07" args="(const std::vector&lt; SizeType &gt; &amp;J, SizeType ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2ec636a59e7b248a763dc6dde59c7e07">viennacl::linalg::detail::spai::isInIndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SizeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if element ind is in set {J}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">J</td><td>current set </td></tr>
    <tr><td class="paramname">ind</td><td>current element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bb32d6e12d240de6fc66405ca934935"></a><!-- doxytag: member="viennacl::linalg::detail::spai::least_square_solve" ref="a5bb32d6e12d240de6fc66405ca934935" args="(std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; SparseVectorType &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, block_matrix &amp;g_A_I_J_vcl, block_vector &amp;g_bv_vcl, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; cl_uint &gt; &amp;g_is_update, const spai_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5bb32d6e12d240de6fc66405ca934935">viennacl::linalg::detail::spai::least_square_solve</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solution of Least square problem on GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column-major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>column-major vectorized sparse preconditioner matrix </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row set indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column set indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious matrix that consists of blocks A(I_k, J_k) </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>contigious vector that consists of betas, necessary for Q recovery </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af215e182f221b29e89f23c3439412ec0"></a><!-- doxytag: member="viennacl::linalg::detail::spai::least_square_solve" ref="af215e182f221b29e89f23c3439412ec0" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, std::vector&lt; DenseMatrixType &gt; &amp;g_R, std::vector&lt; VectorType &gt; &amp;g_b_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; SparseVectorType &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; SparseVectorType &gt; &amp;M_v, const spai_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5bb32d6e12d240de6fc66405ca934935">viennacl::linalg::detail::spai::least_square_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solution of Least square problem on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column-major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">g_R</td><td>blocks for least square solution </td></tr>
    <tr><td class="paramname">g_b_v</td><td>vectors beta, necessary for Q recovery </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index set for all columns of matrix M </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index set for all columns of matrix M </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">M_v</td><td>column-major vectorized sparse matrix, final preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90f785f551eb1c8d4f2e89ffcf438b9d"></a><!-- doxytag: member="viennacl::linalg::detail::spai::make_rotation_matrix" ref="a90f785f551eb1c8d4f2e89ffcf438b9d" args="(MatrixType &amp;mat, std::size_t new_size, std::size_t off_diagonal_distance=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a90f785f551eb1c8d4f2e89ffcf438b9d">viennacl::linalg::detail::spai::make_rotation_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off_diagonal_distance</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a205ef64d3ccd71ff19a017f59085c541"></a><!-- doxytag: member="viennacl::linalg::detail::spai::Print" ref="a205ef64d3ccd71ff19a017f59085c541" args="(std::ostream &amp;ostr, InputIterator it_begin, InputIterator it_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a205ef64d3ccd71ff19a017f59085c541">viennacl::linalg::detail::spai::Print</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1c7a7fb972c5c7b737a3af2b969f325"></a><!-- doxytag: member="viennacl::linalg::detail::spai::print_continious_matrix" ref="aa1c7a7fb972c5c7b737a3af2b969f325" args="(VectorType &amp;con_A_I_J, std::vector&lt; cl_uint &gt; &amp;blocks_ind, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa1c7a7fb972c5c7b737a3af2b969f325">viennacl::linalg::detail::spai::print_continious_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>con_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad339f698808becbd14551bdcfe1ab77f"></a><!-- doxytag: member="viennacl::linalg::detail::spai::print_continious_vector" ref="ad339f698808becbd14551bdcfe1ab77f" args="(VectorType &amp;con_v, std::vector&lt; cl_uint &gt; &amp;block_ind, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad339f698808becbd14551bdcfe1ab77f">viennacl::linalg::detail::spai::print_continious_vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>con_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a37ad35e75e5e5f8e6930a154bb2598bd"></a><!-- doxytag: member="viennacl::linalg::detail::spai::print_matrix" ref="a37ad35e75e5e5f8e6930a154bb2598bd" args="(DenseMatrixType &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a37ad35e75e5e5f8e6930a154bb2598bd">viennacl::linalg::detail::spai::print_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">DenseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa86fb32e08299d4229632a369ae90424"></a><!-- doxytag: member="viennacl::linalg::detail::spai::print_sparse_vector" ref="aa86fb32e08299d4229632a369ae90424" args="(const SparseVectorType &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa86fb32e08299d4229632a369ae90424">viennacl::linalg::detail::spai::print_sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4b81831eeeac471b483c3740af637bb"></a><!-- doxytag: member="viennacl::linalg::detail::spai::projectI" ref="ab4b81831eeeac471b483c3740af637bb" args="(const std::vector&lt; unsigned int &gt; &amp;I, VectorType &amp;y, unsigned int ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab4b81831eeeac471b483c3740af637bb">viennacl::linalg::detail::spai::projectI</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform projection of set I on the unit-vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>set of non-zero rows </td></tr>
    <tr><td class="paramname">y</td><td>result vector </td></tr>
    <tr><td class="paramname">ind</td><td>index of unit vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e7b713019425fe974c5ee04aa023d72"></a><!-- doxytag: member="viennacl::linalg::detail::spai::projectRows" ref="a2e7b713019425fe974c5ee04aa023d72" args="(const std::vector&lt; SparseVectorType &gt; &amp;A_v_c, const std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2e7b713019425fe974c5ee04aa023d72">viennacl::linalg::detail::spai::projectRows</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Row projection for matrix A(:,J) -&gt; A(I,J), building index set of non-zero rows. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>input matrix </td></tr>
    <tr><td class="paramname">J</td><td>set of non-zero rows </td></tr>
    <tr><td class="paramname">I</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a376de42fc42309d290f10555e23e9d81"></a><!-- doxytag: member="viennacl::linalg::detail::spai::QRBlockComposition" ref="a376de42fc42309d290f10555e23e9d81" args="(const MatrixType &amp;A_I_J, const MatrixType &amp;A_I_J_u, MatrixType &amp;A_I_u_J_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a376de42fc42309d290f10555e23e9d81">viennacl::linalg::detail::spai::QRBlockComposition</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_I_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_I_u_J_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composition of new block for QR factorization cf. Kallischko dissertation p.82, figure 4.7. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_I_J</td><td>previously composed block </td></tr>
    <tr><td class="paramname">A_I_J_u</td><td>matrix Q'*A(I, \tilde J), where \tilde J - set of new column indices </td></tr>
    <tr><td class="paramname">A_I_u_J_u</td><td>is composition of lower part A(I, \tilde J) and A(\tilde I, \tilde J) - new block for QR decomposition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfc5ded9046274cebe96334a9e4ffb1e"></a><!-- doxytag: member="viennacl::linalg::detail::spai::single_qr" ref="abfc5ded9046274cebe96334a9e4ffb1e" args="(MatrixType &amp;R, VectorType &amp;b_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#abfc5ded9046274cebe96334a9e4ffb1e">viennacl::linalg::detail::spai::single_qr</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6948abaee761e8ffda64c7635a7889b"></a><!-- doxytag: member="viennacl::linalg::detail::spai::sparse_inner_prod" ref="af6948abaee761e8ffda64c7635a7889b" args="(const SparseVectorType &amp;v1, const SparseVectorType &amp;v2, ScalarType &amp;res_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af6948abaee761e8ffda64c7635a7889b">viennacl::linalg::detail::spai::sparse_inner_prod</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>res_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dot product of two sparse vectors. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">v2</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">res_v</td><td>scalar that represents dot product result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a075a99ab429e570b61f20fb90bdccaf4"></a><!-- doxytag: member="viennacl::linalg::detail::spai::sparse_norm_2" ref="a075a99ab429e570b61f20fb90bdccaf4" args="(const SparseVectorType &amp;v, ScalarType &amp;norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a075a99ab429e570b61f20fb90bdccaf4">viennacl::linalg::detail::spai::sparse_norm_2</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computation of Euclidean norm for sparse vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">norm</td><td>scalar that represents Euclidean norm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12be2f8612b5d22bfa59f372c14d299f"></a><!-- doxytag: member="viennacl::linalg::detail::spai::sparse_transpose" ref="a12be2f8612b5d22bfa59f372c14d299f" args="(const MatrixType &amp;A_in, MatrixType &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a12be2f8612b5d22bfa59f372c14d299f">viennacl::linalg::detail::spai::sparse_transpose</a> </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transposition of sparse matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>intial sparse matrix </td></tr>
    <tr><td class="paramname">A</td><td>output transposed matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b957b9a9bae76c548e744f1f8cdfe1c"></a><!-- doxytag: member="viennacl::linalg::detail::spai::store_householder_vector" ref="a0b957b9a9bae76c548e744f1f8cdfe1c" args="(MatrixType &amp;A, unsigned int ind, VectorType &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0b957b9a9bae76c548e744f1f8cdfe1c">viennacl::linalg::detail::spai::store_householder_vector</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Storage of vector v in column(A, ind), starting from ind-1 index of a column. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">ind</td><td>index of a column </td></tr>
    <tr><td class="paramname">v</td><td>vector that should be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2ced59584b0590da05723563ab7197d"></a><!-- doxytag: member="viennacl::linalg::detail::spai::sym_sparse_matrix_to_stl" ref="aa2ced59584b0590da05723563ab7197d" args="(MatrixType const &amp;A, std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;STL_A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa2ced59584b0590da05723563ab7197d">viennacl::linalg::detail::spai::sym_sparse_matrix_to_stl</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, ScalarType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>STL_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad9dfaad8c5bcfe650993902d8312f56d"></a><!-- doxytag: member="viennacl::linalg::detail::spai::vectorize_column_matrix" ref="ad9dfaad8c5bcfe650993902d8312f56d" args="(const SparseMatrixType &amp;M_in, std::vector&lt; SparseVectorType &gt; &amp;M_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad9dfaad8c5bcfe650993902d8312f56d">viennacl::linalg::detail::spai::vectorize_column_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solution of Least square problem on CPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M_in</td><td>input sparse, boost::numeric::ublas::compressed_matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>array of sparse vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab438581d4a972367d59ef0e227b2c34b"></a><!-- doxytag: member="viennacl::linalg::detail::spai::vectorize_row_matrix" ref="ab438581d4a972367d59ef0e227b2c34b" args="(const SparseMatrixType &amp;M_in, std::vector&lt; SparseVectorType &gt; &amp;M_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab438581d4a972367d59ef0e227b2c34b">viennacl::linalg::detail::spai::vectorize_row_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30c75416ab36d5d8ab07b0b1e1105e13"></a><!-- doxytag: member="viennacl::linalg::detail::spai::write_set_to_array" ref="a30c75416ab36d5d8ab07b0b1e1105e13" args="(const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;ind_set, std::vector&lt; cl_uint &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a30c75416ab36d5d8ab07b0b1e1105e13">viennacl::linalg::detail::spai::write_set_to_array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SizeType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0725fc50d711ff8a32784c3c21e17d8c"></a><!-- doxytag: member="viennacl::linalg::detail::spai::write_to_block" ref="a0725fc50d711ff8a32784c3c21e17d8c" args="(VectorType &amp;con_A_I_J, unsigned int start_ind, const std::vector&lt; unsigned int &gt; &amp;I, const std::vector&lt; unsigned int &gt; &amp;J, MatrixType &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0725fc50d711ff8a32784c3c21e17d8c">viennacl::linalg::detail::spai::write_to_block</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>con_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:56 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
