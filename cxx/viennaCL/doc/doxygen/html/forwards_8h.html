<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/forwards.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl/forwards.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides the forward declarations for the main types used within ViennaCL.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br/>
<code>#include &lt;cassert&gt;</code><br/>
<code>#include &quot;<a class="el" href="enable__if_8hpp_source.html">viennacl/meta/enable_if.hpp</a>&quot;</code><br/>
</div>
<p><a href="forwards_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">row_major_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">column_major_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">is_cpu_scalar&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">is_scalar&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">is_flip_sign_scalar&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">is_any_scalar&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">is_row_major&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">is_any_sparse_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">is_circulant_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">is_hankel_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">is_toeplitz_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">is_vandermonde_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">is_any_dense_structured_matrix&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html">MATRIX_ITERATOR_INCREMENTER&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">viennacl::tools</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace for various tools used within ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">viennacl::linalg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">viennacl::linalg::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding implementation details for linear algebra routines. Usually not of interest for a library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">viennacl::backend</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing routines for handling the different memory domains. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram.html">viennacl::backend::cpu_ram</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling memory buffers in CPU RAM. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram_1_1detail.html">viennacl::backend::cpu_ram::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling memory buffers in CPU RAM. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda.html">viennacl::backend::cuda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling CUDA memory buffers. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda_1_1detail.html">viennacl::backend::cuda::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling CUDA memory buffers. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1detail.html">viennacl::backend::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for the generic memory backend interface. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl.html">viennacl::backend::opencl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling OpenCL memory buffers. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl_1_1detail.html">viennacl::backend::opencl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling OpenCL memory buffers. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">viennacl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft.html">viennacl::detail::fft</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper namespace for fast Fourier transforms. Not to be used directly by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html">viennacl::detail::fft::FFT_DATA_ORDER</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper namespace for fast-Fourier transformation. Deprecated. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator.html">viennacl::generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides an OpenCL kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1math.html">viennacl::generator::math</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding unary math functions for use within the kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1result__of.html">viennacl::generator::result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains all the meta-functions used within the OpenCL kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1tree__utils.html">viennacl::generator::tree_utils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains helper routines for manipulating expression trees. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1typelist__utils.html">viennacl::generator::typelist_utils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains helper routines for manipulating typelists. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">viennacl::io</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides basic input-output functionality. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1detail.html">viennacl::io::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for IO functionality. Usually not of interest for a library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1tag.html">viennacl::io::tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding the various XML tag definitions for the kernel parameter tuning facility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1val.html">viennacl::io::val</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding the various XML strings for the kernel parameter tuning facility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda.html">viennacl::linalg::cuda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all CUDA compute kernels used by ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda_1_1detail.html">viennacl::linalg::cuda::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the CUDA linear algebra backend. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html">viennacl::linalg::detail::amg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation namespace for algebraic multigrid preconditioner. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html">viennacl::linalg::detail::spai</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation namespace for sparse approximate inverse preconditioner. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">viennacl::linalg::host_based</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html">viennacl::linalg::host_based::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the host-based linear algebra backend. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">viennacl::linalg::kernels</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing the OpenCL kernels. Deprecated, will be moved to <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html" title="Holds all routines providing OpenCL linear algebra operations.">viennacl::linalg::opencl</a> in future releases. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">viennacl::linalg::opencl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all routines providing OpenCL linear algebra operations. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html">viennacl::linalg::opencl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for OpenCL-accelerated linear algebra operations. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">viennacl::ocl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">viennacl::result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing many meta-functions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools_1_1detail.html">viennacl::tools::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains implementation details for the tools. Usually not of interest for the library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">viennacl::traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_slice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a> { <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810">MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c">MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03">CUDA_MEMORY</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201">row_info_types</a> { <a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a23743f734a7f75006483fa93e9d4425a">SPARSE_ROW_NORM_INF</a> =  0, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a85db5d72f0c0ea9096cf53fcb1a330e5">SPARSE_ROW_NORM_1</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a4d11d9bc162777d4b24e8e5c776af5d3">SPARSE_ROW_NORM_2</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a44733b01d16bdf2e70b99fbdf197ac66">SPARSE_ROW_DIAGONAL</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae90a3bfb2d1d49bb356c8f2179a685b0">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ae90a3bfb2d1d49bb356c8f2179a685b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d783c95a46bcb7d01000ae479a03cfc">copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a0d783c95a46bcb7d01000ae479a03cfc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> (const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a815cf9646ece6cc98ec80b3f925c482d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abfe63ce6ea6eded970702b69279c37fb">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#abfe63ce6ea6eded970702b69279c37fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">convolve_i</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_prod &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a98122c5cd298059fc499f7ce8b278f79">element_prod</a> (vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_div &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaef3363b890dafbea83846825ea3d730">element_div</a> (vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - dispatcher interface.  <a href="#ab7cbb9fc8635e8ceb18dd181c0aa2324"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a84c0f006e2e4f840e0bebfd9a9fed0e8">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5006ea75a0379d56e1dd8dbf6d817a41">inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64080f662904aa976e0767a4693211ea">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface.  <a href="#abce7fb4d0ee0a5f82313eff5b07d03cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab92256482cf6a71434a0501847dd70fe">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abd75024e6302d26cd8f26559e9b6a31c">inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9c68566e658fd80448dabb02bfbf018c">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">norm_1_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - dispatcher interface.  <a href="#a546e0f416d08c99d21344dda5398859c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2487c579ee752a9fcc31c12d0bddf604">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acddd2a99867a55480dde2b4dba0a588c">norm_1_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU.  <a href="#acddd2a99867a55480dde2b4dba0a588c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1d55e0e715a14ef4b336c06018c38db7">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a1d55e0e715a14ef4b336c06018c38db7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abeaca00d5581387446ab0948dde72f44">norm_2_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - dispatcher interface.  <a href="#abeaca00d5581387446ab0948dde72f44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9d1a04d42e467eb9e0cd4b3a17cfc317">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a9d1a04d42e467eb9e0cd4b3a17cfc317"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a063fa23bfd77e19e93046d256027f438">norm_2_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface.  <a href="#a063fa23bfd77e19e93046d256027f438"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a609941700fc79f0978daf50acaa93656">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a609941700fc79f0978daf50acaa93656"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5f7158a5f1fb8b67e2e6849b202a86a9">norm_inf_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a5f7158a5f1fb8b67e2e6849b202a86a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac8921e7938a67173daaf6c9a0e40e3e0">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#ac8921e7938a67173daaf6c9a0e40e3e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57092218bb316cdd6e7a9e8a758f3e99">norm_inf_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector with final reduction on the CPU.  <a href="#a57092218bb316cdd6e7a9e8a758f3e99"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad0fb517b1788ab9c44ee93021c32ba3f">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad0fb517b1788ab9c44ee93021c32ba3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7d991b4fc1435b34ddf9940911009e82">index_norm_inf</a> (vector_base&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a7d991b4fc1435b34ddf9940911009e82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a43e399b80730abedb939a3d08e326a8f">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a43e399b80730abedb939a3d08e326a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">prod_impl</a> (const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#aaa45f913d8815ef5ca24d70443d31bd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a49db0fe7daf624d43003ec4a08f3a8a3">prod_impl</a> (const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a49db0fe7daf624d43003ec4a08f3a8a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
vector_expression&lt; const <br class="typebreak"/>
SparseMatrixType, const vector<br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae7a946e478e53f6464d1dedeb3a46c89">prod_impl</a> (const SparseMatrixType &amp;mat, const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file provides the forward declarations for the main types used within ViennaCL. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
