<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/vector.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/vector.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="vector_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_VECTOR_HPP_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_VECTOR_HPP_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2013, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment">               </span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL.">viennacl/forwards.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="memory_8hpp.html" title="Main interface routines for memory management.">viennacl/backend/memory.hpp</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html" title="Implementation of the ViennaCL scalar class.">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="entry__proxy_8hpp.html" title="A proxy class for entries in a vector.">viennacl/tools/entry_proxy.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="vector__operations_8hpp.html" title="Implementations of vector operations.">viennacl/linalg/vector_operations.hpp</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="meta_2result__of_8hpp.html" title="A collection of compile time type deductions.">viennacl/meta/result_of.hpp</a>&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">namespace </span>viennacl
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038   <span class="comment">//</span>
<a name="l00039"></a>00039   <span class="comment">// Initializer types</span>
<a name="l00040"></a>00040   <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00043"></a><a class="code" href="classviennacl_1_1unit__vector.html">00043</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1unit__vector.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">unit_vector</a>
<a name="l00044"></a>00044   {
<a name="l00045"></a>00045     <span class="keyword">public</span>:
<a name="l00046"></a><a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">00046</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>        <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00047"></a>00047       
<a name="l00048"></a><a class="code" href="classviennacl_1_1unit__vector.html#a712f4d9348c5c59b5a2f4877828c214e">00048</a>       <a class="code" href="classviennacl_1_1unit__vector.html#a712f4d9348c5c59b5a2f4877828c214e">unit_vector</a>(<a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s, <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> ind) : size_(s), index_(ind) 
<a name="l00049"></a>00049       {
<a name="l00050"></a>00050         assert( (ind &lt; s) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Provided index out of range!&quot;</span>) );
<a name="l00051"></a>00051       }
<a name="l00052"></a>00052       
<a name="l00053"></a><a class="code" href="classviennacl_1_1unit__vector.html#a503ab01f6c0142145d3434f6924714e7">00053</a>       <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1unit__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00054"></a><a class="code" href="classviennacl_1_1unit__vector.html#ac60d57afcb61ce5035df36b8a3002c45">00054</a>       <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1unit__vector.html#ac60d57afcb61ce5035df36b8a3002c45">index</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> index_; }
<a name="l00055"></a>00055       
<a name="l00056"></a>00056     <span class="keyword">private</span>:
<a name="l00057"></a>00057       <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size_;
<a name="l00058"></a>00058       <a class="code" href="classviennacl_1_1unit__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index_;
<a name="l00059"></a>00059   };
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   
<a name="l00063"></a>00063   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00064"></a><a class="code" href="classviennacl_1_1zero__vector.html">00064</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1zero__vector.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_vector</a>
<a name="l00065"></a>00065   {
<a name="l00066"></a>00066     <span class="keyword">public</span>:
<a name="l00067"></a><a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">00067</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>        <a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00068"></a><a class="code" href="classviennacl_1_1zero__vector.html#afbbd5197bb31960473989a82cbda6e1b">00068</a>       <span class="keyword">typedef</span> SCALARTYPE        <a class="code" href="classviennacl_1_1zero__vector.html#afbbd5197bb31960473989a82cbda6e1b">const_reference</a>;
<a name="l00069"></a>00069       
<a name="l00070"></a><a class="code" href="classviennacl_1_1zero__vector.html#adb0b967ac71741932a5e31ff95a1037a">00070</a>       <a class="code" href="classviennacl_1_1zero__vector.html#adb0b967ac71741932a5e31ff95a1037a">zero_vector</a>(<a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s) : size_(s) {}
<a name="l00071"></a>00071       
<a name="l00072"></a><a class="code" href="classviennacl_1_1zero__vector.html#a503ab01f6c0142145d3434f6924714e7">00072</a>       <a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1zero__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00073"></a><a class="code" href="classviennacl_1_1zero__vector.html#a2c9376e75099d0b962938cf200afab7c">00073</a>       <a class="code" href="classviennacl_1_1zero__vector.html#afbbd5197bb31960473989a82cbda6e1b">const_reference</a> <a class="code" href="classviennacl_1_1zero__vector.html#a2c9376e75099d0b962938cf200afab7c">operator()</a>(<a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00074"></a><a class="code" href="classviennacl_1_1zero__vector.html#aa96a2c03f68c1a8ffa376eeac7fc3e5f">00074</a>       <a class="code" href="classviennacl_1_1zero__vector.html#afbbd5197bb31960473989a82cbda6e1b">const_reference</a> <a class="code" href="classviennacl_1_1zero__vector.html#aa96a2c03f68c1a8ffa376eeac7fc3e5f">operator[]</a>(<a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00075"></a>00075       
<a name="l00076"></a>00076     <span class="keyword">private</span>:
<a name="l00077"></a>00077       <a class="code" href="classviennacl_1_1zero__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size_;
<a name="l00078"></a>00078   };
<a name="l00079"></a>00079   
<a name="l00080"></a>00080   
<a name="l00082"></a>00082   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE&gt;
<a name="l00083"></a><a class="code" href="classviennacl_1_1scalar__vector.html">00083</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1scalar__vector.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_vector</a>
<a name="l00084"></a>00084   {
<a name="l00085"></a>00085     <span class="keyword">public</span>:
<a name="l00086"></a><a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">00086</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>         <a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00087"></a><a class="code" href="classviennacl_1_1scalar__vector.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">00087</a>       <span class="keyword">typedef</span> SCALARTYPE <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1scalar__vector.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a>;
<a name="l00088"></a>00088       
<a name="l00089"></a><a class="code" href="classviennacl_1_1scalar__vector.html#a07ea8591ca95528f5e0327770b9c1c12">00089</a>       <a class="code" href="classviennacl_1_1scalar__vector.html#a07ea8591ca95528f5e0327770b9c1c12">scalar_vector</a>(<a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> s, SCALARTYPE val) : size_(s), value_(val) {}
<a name="l00090"></a>00090       
<a name="l00091"></a><a class="code" href="classviennacl_1_1scalar__vector.html#a503ab01f6c0142145d3434f6924714e7">00091</a>       <a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1scalar__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00092"></a><a class="code" href="classviennacl_1_1scalar__vector.html#a2c9376e75099d0b962938cf200afab7c">00092</a>       <a class="code" href="classviennacl_1_1scalar__vector.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> <a class="code" href="classviennacl_1_1scalar__vector.html#a2c9376e75099d0b962938cf200afab7c">operator()</a>(<a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value_; }
<a name="l00093"></a><a class="code" href="classviennacl_1_1scalar__vector.html#aa96a2c03f68c1a8ffa376eeac7fc3e5f">00093</a>       <a class="code" href="classviennacl_1_1scalar__vector.html#acd1bcfe7b52f5fee2cdba7a4a97714bf">const_reference</a> <a class="code" href="classviennacl_1_1scalar__vector.html#aa96a2c03f68c1a8ffa376eeac7fc3e5f">operator[]</a>(<a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <span class="comment">/*i*/</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value_; }
<a name="l00094"></a>00094       
<a name="l00095"></a>00095     <span class="keyword">private</span>:
<a name="l00096"></a>00096       <a class="code" href="classviennacl_1_1scalar__vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size_;
<a name="l00097"></a>00097       SCALARTYPE value_;
<a name="l00098"></a>00098   };
<a name="l00099"></a>00099   
<a name="l00100"></a>00100   
<a name="l00101"></a>00101   <span class="comment">//</span>
<a name="l00102"></a>00102   <span class="comment">// Vector expression</span>
<a name="l00103"></a>00103   <span class="comment">//</span>
<a name="l00104"></a>00104     
<a name="l00117"></a>00117   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00118"></a><a class="code" href="classviennacl_1_1vector__expression.html">00118</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>
<a name="l00119"></a>00119   {
<a name="l00120"></a>00120       <span class="keyword">typedef</span> <span class="keyword">typename</span> result_of::reference_if_nonscalar&lt;LHS&gt;::type     lhs_reference_type;
<a name="l00121"></a>00121       <span class="keyword">typedef</span> <span class="keyword">typename</span> result_of::reference_if_nonscalar&lt;RHS&gt;::type     rhs_reference_type;
<a name="l00122"></a>00122     
<a name="l00123"></a>00123     <span class="keyword">public</span>:
<a name="l00124"></a><a class="code" href="classviennacl_1_1vector__expression.html#a7ada2556f3c386db5f31969fb6d4d002aebf7e56a11a89977107d2c8ce440acc8">00124</a>       <span class="keyword">enum</span> { <a class="code" href="classviennacl_1_1vector__expression.html#a7ada2556f3c386db5f31969fb6d4d002aebf7e56a11a89977107d2c8ce440acc8">alignment</a> = 1 };
<a name="l00125"></a>00125       
<a name="l00128"></a><a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067">00128</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r.html#a9e7f3539ef2e71a6b4d199d882a40da0">viennacl::tools::VECTOR_EXTRACTOR&lt;LHS, RHS&gt;::ResultType</a>    <a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067" title="Extracts the vector type from the two operands.">VectorType</a>;
<a name="l00129"></a><a class="code" href="classviennacl_1_1vector__expression.html#a8e2cc70e5cd203262fe8270613f303ec">00129</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>       <a class="code" href="classviennacl_1_1vector__expression.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>;
<a name="l00130"></a>00130       
<a name="l00131"></a><a class="code" href="classviennacl_1_1vector__expression.html#aad18795661c3c23b4de8e48b8a8304ff">00131</a>       <a class="code" href="classviennacl_1_1vector__expression.html#aad18795661c3c23b4de8e48b8a8304ff">vector_expression</a>(LHS &amp; l, RHS &amp; r) : lhs_(l), rhs_(r) {}
<a name="l00132"></a>00132       
<a name="l00135"></a><a class="code" href="classviennacl_1_1vector__expression.html#a809c22e695674c7798db5cf554fce819">00135</a>       lhs_reference_type <a class="code" href="classviennacl_1_1vector__expression.html#a809c22e695674c7798db5cf554fce819" title="Get left hand side operand.">lhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> lhs_; }
<a name="l00138"></a><a class="code" href="classviennacl_1_1vector__expression.html#a70bbc188e97d30dc0c8008138ffccf97">00138</a>       rhs_reference_type <a class="code" href="classviennacl_1_1vector__expression.html#a70bbc188e97d30dc0c8008138ffccf97" title="Get right hand side operand.">rhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rhs_; }
<a name="l00139"></a>00139       
<a name="l00141"></a><a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7">00141</a>       <a class="code" href="classviennacl_1_1vector__expression.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">viennacl::traits::size</a>(*<span class="keyword">this</span>); }
<a name="l00142"></a>00142       
<a name="l00143"></a>00143     <span class="keyword">private</span>:
<a name="l00145"></a>00145       lhs_reference_type lhs_;
<a name="l00147"></a>00147       rhs_reference_type rhs_;
<a name="l00148"></a>00148   };
<a name="l00149"></a>00149   
<a name="l00168"></a>00168   <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00169"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html">00169</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator</a>
<a name="l00170"></a>00170   {
<a name="l00171"></a>00171       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>    <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>;
<a name="l00172"></a>00172     <span class="keyword">public</span>:
<a name="l00173"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">00173</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>            <a class="code" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">value_type</a>;
<a name="l00174"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">00174</a>       <span class="keyword">typedef</span> <span class="keywordtype">long</span>                          <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a>;
<a name="l00175"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">00175</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">backend::mem_handle</a>           <a class="code" href="classviennacl_1_1const__vector__iterator.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a>;
<a name="l00176"></a>00176       
<a name="l00177"></a>00177       <span class="comment">//const_vector_iterator() {};</span>
<a name="l00178"></a>00178       
<a name="l00185"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a6b7e1e1a085b19cc7f3ecae6dfa946fa">00185</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html#a6b7e1e1a085b19cc7f3ecae6dfa946fa" title="Constructor.">const_vector_iterator</a>(<a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00186"></a>00186                             std::size_t index,
<a name="l00187"></a>00187                             std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a> = 0,
<a name="l00188"></a>00188                             <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a> = 1) : <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>(vec.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>()), <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>(index), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a>(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a>), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>) {};
<a name="l00189"></a>00189                             
<a name="l00196"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#aceaf632421d2ba9eac40e1b5a275744b">00196</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html#a6b7e1e1a085b19cc7f3ecae6dfa946fa" title="Constructor.">const_vector_iterator</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> <span class="keyword">const</span> &amp; elements,
<a name="l00197"></a>00197                             std::size_t index,
<a name="l00198"></a>00198                             std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a> = 0,
<a name="l00199"></a>00199                             <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a> = 1) : <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>(elements), <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>(index), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a>(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a>), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>) {};
<a name="l00200"></a>00200 
<a name="l00202"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a832e184e247b97ecb752bf291d814dff">00202</a>       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a832e184e247b97ecb752bf291d814dff" title="Dereferences the iterator and returns the value of the element. For convenience only, performance is poor due to OpenCL overhead!">operator*</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>
<a name="l00203"></a>00203 <span class="keyword">      </span>{ 
<a name="l00204"></a>00204           <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a> result;
<a name="l00205"></a>00205           result = <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a> + <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> * <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>);
<a name="l00206"></a>00206           <span class="keywordflow">return</span> result;
<a name="l00207"></a>00207       }
<a name="l00208"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a0b50df67a5cd6493e8839fd8990500a7">00208</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a0b50df67a5cd6493e8839fd8990500a7">operator++</a>(<span class="keywordtype">void</span>) { <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> += <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00209"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a39f7c37604fd9845ff487b36b6f88602">00209</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a39f7c37604fd9845ff487b36b6f88602">operator++</a>(<span class="keywordtype">int</span>) { <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> tmp = *<span class="keyword">this</span>; ++(*this); <span class="keywordflow">return</span> tmp; }
<a name="l00210"></a>00210       
<a name="l00211"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ae01970b831b1c1dc3a9f22f7a4e19cf6">00211</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ae01970b831b1c1dc3a9f22f7a4e19cf6">operator==</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> == other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>; }
<a name="l00212"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a0c704f6470bc4c7392b964dd83a1d97b">00212</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a0c704f6470bc4c7392b964dd83a1d97b">operator!=</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> != other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>; }
<a name="l00213"></a>00213       
<a name="l00214"></a>00214 <span class="comment">//        self_type &amp; operator=(self_type const &amp; other)</span>
<a name="l00215"></a>00215 <span class="comment">//        {</span>
<a name="l00216"></a>00216 <span class="comment">//           index_ = other._index;</span>
<a name="l00217"></a>00217 <span class="comment">//           elements_ = other._elements;</span>
<a name="l00218"></a>00218 <span class="comment">//           return *this;</span>
<a name="l00219"></a>00219 <span class="comment">//        }   </span>
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">00221</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">operator-</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>
<a name="l00222"></a>00222 <span class="keyword">      </span>{
<a name="l00223"></a>00223         assert( (other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a> == <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a>) &amp;&amp; (other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a> == <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Iterators are not from the same vector (proxy)!&quot;</span>));
<a name="l00224"></a>00224         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a><span class="keyword">&gt;</span>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>) - static_cast&lt;difference_type&gt;(other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>); 
<a name="l00225"></a>00225       }
<a name="l00226"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">00226</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">operator+</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> diff)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> + diff * <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a>, stride_); }
<a name="l00227"></a>00227       
<a name="l00228"></a>00228       <span class="comment">//std::size_t index() const { return index_; }</span>
<a name="l00230"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad">00230</a> <span class="comment"></span>      std::size_t <a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a> + <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a> * <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>; }
<a name="l00231"></a>00231       
<a name="l00233"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988">00233</a>       std::size_t <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>; }
<a name="l00234"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">00234</a>       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>; }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="keyword">protected</span>:
<a name="l00238"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c">00238</a>       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">elements_</a>;
<a name="l00239"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">00239</a>       std::size_t <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>;  <span class="comment">//offset from the beginning of elements_</span>
<a name="l00240"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">00240</a>       std::size_t <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">start_</a>;
<a name="l00241"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">00241</a>       <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">stride_</a>;
<a name="l00242"></a>00242   };
<a name="l00243"></a>00243   
<a name="l00244"></a>00244 
<a name="l00264"></a>00264   <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00265"></a><a class="code" href="classviennacl_1_1vector__iterator.html">00265</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator</a> : <span class="keyword">public</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator</a>&lt;SCALARTYPE, ALIGNMENT&gt;
<a name="l00266"></a>00266   {
<a name="l00267"></a>00267       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>  <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>;
<a name="l00268"></a>00268       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>        <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>;
<a name="l00269"></a>00269     <span class="keyword">public</span>:
<a name="l00270"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a119eae92a73ab431d6d4f24f86141722">00270</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">base_type::handle_type</a>               <a class="code" href="classviennacl_1_1vector__iterator.html#a119eae92a73ab431d6d4f24f86141722">handle_type</a>;
<a name="l00271"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a7f1b8fde63313dfc323ad4f7cb81b188">00271</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">base_type::difference_type</a>           <a class="code" href="classviennacl_1_1vector__iterator.html#a7f1b8fde63313dfc323ad4f7cb81b188">difference_type</a>;
<a name="l00272"></a>00272       
<a name="l00273"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">00273</a>       <a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">vector_iterator</a>() : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(), elements_(NULL) {};
<a name="l00274"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a28ab481ecd5c8e3d7be1efbfbbce8f10">00274</a>       <a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">vector_iterator</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> &amp; elements,
<a name="l00275"></a>00275                       std::size_t index,
<a name="l00276"></a>00276                       std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a> = 0,
<a name="l00277"></a>00277                       <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a> = 1)  : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(elements, index, <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>), elements_(elements) {};
<a name="l00284"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a3846173b32c90ba3edd6d3a8370aeebb">00284</a>       <a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">vector_iterator</a>(<a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a> &amp; vec,
<a name="l00285"></a>00285                       std::size_t index,
<a name="l00286"></a>00286                       std::size_t <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a> = 0,
<a name="l00287"></a>00287                       <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a> = 1) : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(vec, index, <a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">start</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>), elements_(vec.<a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>()) {};
<a name="l00288"></a>00288       <span class="comment">//vector_iterator(base_type const &amp; b) : base_type(b) {};</span>
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="classviennacl_1_1vector__iterator.html#aca896a4673a17317ad7068e8b769a6c8">00290</a>       <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">base_type::value_type</a> <a class="code" href="classviennacl_1_1vector__iterator.html#aca896a4673a17317ad7068e8b769a6c8">operator*</a>(<span class="keywordtype">void</span>)  
<a name="l00291"></a>00291       { 
<a name="l00292"></a>00292           <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">base_type::value_type</a> result;
<a name="l00293"></a>00293           result = <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">base_type::start_</a> + <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">base_type::index_</a> * <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">base_type::stride_</a>, elements_); 
<a name="l00294"></a>00294           <span class="keywordflow">return</span> result;
<a name="l00295"></a>00295       }
<a name="l00296"></a>00296       
<a name="l00297"></a><a class="code" href="classviennacl_1_1vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">00297</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> <a class="code" href="classviennacl_1_1vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">operator-</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> result = <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">base_type::index_</a>; <span class="keywordflow">return</span> (result - static_cast&lt;difference_type&gt;(other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">index_</a>)); }
<a name="l00298"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">00298</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">operator+</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> diff)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>(elements_, <a class="code" href="classviennacl_1_1const__vector__iterator.html#af6e2d105c9719fcec9af80de8f674eb3">base_type::index_</a> + diff * <a class="code" href="classviennacl_1_1const__vector__iterator.html#a46b7e18d2c57d43846852ed15166661e">base_type::stride_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8bfb6b7495ce1eb3ca8c893b4e01e7fb">base_type::start_</a>, base_type::stride_); }
<a name="l00299"></a>00299       
<a name="l00300"></a><a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">00300</a>       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a>       &amp; <a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>()       { <span class="keywordflow">return</span> elements_; }
<a name="l00301"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">00301</a>       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac7b422c99f5eff7804206f01c871883c" title="The index of the entry the iterator is currently pointing to.">base_type::elements_</a>; }
<a name="l00302"></a>00302       
<a name="l00303"></a>00303       <span class="comment">//operator base_type() const</span>
<a name="l00304"></a>00304       <span class="comment">//{</span>
<a name="l00305"></a>00305       <span class="comment">//  return base_type(base_type::elements_, base_type::index_, base_type::start_, base_type::stride_);</span>
<a name="l00306"></a>00306       <span class="comment">//}</span>
<a name="l00307"></a>00307     <span class="keyword">private</span>:
<a name="l00308"></a>00308       <a class="code" href="classviennacl_1_1vector__iterator.html#a119eae92a73ab431d6d4f24f86141722">handle_type</a> &amp; elements_;
<a name="l00309"></a>00309   };
<a name="l00310"></a>00310   
<a name="l00311"></a>00311   
<a name="l00316"></a>00316   <span class="keyword">template</span>&lt;<span class="keyword">class </span>SCALARTYPE, <span class="keyword">typename</span> SizeType <span class="comment">/* see forwards.h for default type */</span>, <span class="keyword">typename</span> DistanceType <span class="comment">/* see forwards.h for default type */</span>&gt;
<a name="l00317"></a><a class="code" href="classviennacl_1_1vector__base.html">00317</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base</a>
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a>         <a class="code" href="classviennacl_1_1vector__base.html">self_type</a>;
<a name="l00320"></a>00320       
<a name="l00321"></a>00321     <span class="keyword">public</span>:
<a name="l00322"></a><a class="code" href="classviennacl_1_1vector__base.html#aed985c700866b1bae61cb8bcd5d322fe">00322</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;typename viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT&lt;SCALARTYPE&gt;::ResultType</a>&gt;   <a class="code" href="classviennacl_1_1vector__base.html#aed985c700866b1bae61cb8bcd5d322fe">value_type</a>;
<a name="l00323"></a><a class="code" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">00323</a>       <span class="keyword">typedef</span> SCALARTYPE                                        <a class="code" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a>;
<a name="l00324"></a><a class="code" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">00324</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">backend::mem_handle</a>                               <a class="code" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a>;
<a name="l00325"></a><a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">00325</a>       <span class="keyword">typedef</span> SizeType                                        <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>;
<a name="l00326"></a><a class="code" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">00326</a>       <span class="keyword">typedef</span> DistanceType                                     <a class="code" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a>;
<a name="l00327"></a><a class="code" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">00327</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, 1&gt;</a>              <a class="code" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a>;
<a name="l00328"></a><a class="code" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">00328</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, 1&gt;</a>                    <a class="code" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a>;
<a name="l00329"></a>00329       
<a name="l00330"></a><a class="code" href="classviennacl_1_1vector__base.html#a03ed50af9196539f90b41d7bad4a3b22">00330</a>       <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1vector__base.html#a03ed50af9196539f90b41d7bad4a3b22">alignment</a> = 1;
<a name="l00331"></a>00331   
<a name="l00334"></a><a class="code" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5">00334</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5" title="Default constructor in order to be compatible with various containers.">vector_base</a>() : size_(0), start_(0), stride_(1) { <span class="comment">/* Note: One must not call ::init() here because a vector might have been created globally before the backend has become available */</span> }
<a name="l00335"></a>00335   
<a name="l00345"></a><a class="code" href="classviennacl_1_1vector__base.html#af2a0b5272f0911e822835d939b5c09aa">00345</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5" title="Default constructor in order to be compatible with various containers.">vector_base</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> &amp; h,
<a name="l00346"></a>00346                            <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size, <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_start, <a class="code" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> vec_stride) : size_(vec_size), start_(vec_start), stride_(vec_stride), elements_(h) {}
<a name="l00347"></a>00347       
<a name="l00349"></a><a class="code" href="classviennacl_1_1vector__base.html#ac4cf80248dcf5e641aca0b3007c7deb7">00349</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5" title="Default constructor in order to be compatible with various containers.">vector_base</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size) : size_(vec_size), start_(0), stride_(1)
<a name="l00350"></a>00350       {
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00352"></a>00352         {
<a name="l00353"></a>00353           std::vector&lt;SCALARTYPE&gt; temp(<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00354"></a>00354           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>(), &amp;(temp[0]));
<a name="l00355"></a>00355           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00356"></a>00356         }
<a name="l00357"></a>00357       }
<a name="l00358"></a>00358   
<a name="l00360"></a><a class="code" href="classviennacl_1_1vector__base.html#af7c353f70c3cee2b9fba12bf58d27118">00360</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector__base.html#aa9dcc7c0c8bc7c616450c167c8a62ab5" title="Default constructor in order to be compatible with various containers.">vector_base</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size, <a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> mem_type) : size_(vec_size), start_(0), stride_(1)
<a name="l00361"></a>00361       {
<a name="l00362"></a>00362         elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a016f1218a02268c06c3009803cc3073d" title="Switches the currently active handle. If no support for that backend is provided, an exception is thr...">switch_active_handle_id</a>(mem_type);
<a name="l00363"></a>00363         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00364"></a>00364         {
<a name="l00365"></a>00365           std::vector&lt;SCALARTYPE&gt; temp(<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00366"></a>00366           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>(), &amp;(temp[0]));
<a name="l00367"></a>00367           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369       }
<a name="l00370"></a>00370       
<a name="l00371"></a>00371       <span class="comment">//</span>
<a name="l00372"></a>00372       <span class="comment">// operator=</span>
<a name="l00373"></a>00373       <span class="comment">//</span>
<a name="l00374"></a>00374       
<a name="l00375"></a>00375   
<a name="l00378"></a><a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130">00378</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; vec)
<a name="l00379"></a>00379       {
<a name="l00380"></a>00380         assert( ( (vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00381"></a>00381                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="keywordflow">if</span> (vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l00384"></a>00384         {
<a name="l00385"></a>00385           <span class="keywordflow">if</span> (size_ == 0)
<a name="l00386"></a>00386           {
<a name="l00387"></a>00387             size_ = vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>();
<a name="l00388"></a>00388             elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a016f1218a02268c06c3009803cc3073d" title="Switches the currently active handle. If no support for that backend is provided, an exception is thr...">switch_active_handle_id</a>(vec.<a class="code" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938" title="Returns the memory handle.">handle</a>().<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#acd29573cd156d000f75668bba858cca3" title="Returns an ID for the currently active memory buffer. Other memory buffers might contain old or no da...">get_active_handle_id</a>());
<a name="l00389"></a>00389             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00390"></a>00390           }
<a name="l00391"></a>00391             
<a name="l00392"></a>00392           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab944766c932d732c660dfd8cce23557f">viennacl::linalg::av</a>(*<span class="keyword">this</span>,
<a name="l00393"></a>00393                                vec, <a class="code" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a>(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00394"></a>00394         }
<a name="l00395"></a>00395         
<a name="l00396"></a>00396         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398   
<a name="l00399"></a>00399   
<a name="l00404"></a>00404       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP&gt;
<a name="l00405"></a>00405       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l00406"></a>00406                                     self_type &amp; &gt;::type
<a name="l00407"></a><a class="code" href="classviennacl_1_1vector__base.html#a8ddbade4c1fc2f09576e3e1a911b396a">00407</a>       <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP&gt; &amp; proxy)
<a name="l00408"></a>00408       {
<a name="l00409"></a>00409         assert( ( (proxy.lhs().size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00410"></a>00410                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00411"></a>00411         
<a name="l00412"></a>00412         <span class="comment">// initialize the necessary buffer</span>
<a name="l00413"></a>00413         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00414"></a>00414         {
<a name="l00415"></a>00415           size_ = proxy.lhs().size();
<a name="l00416"></a>00416           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00417"></a>00417           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00418"></a>00418         } 
<a name="l00419"></a>00419   
<a name="l00420"></a>00420         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab944766c932d732c660dfd8cce23557f">viennacl::linalg::av</a>(*<span class="keyword">this</span>,
<a name="l00421"></a>00421                              proxy.lhs(), proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), <span class="keyword">false</span>);
<a name="l00422"></a>00422         
<a name="l00423"></a>00423         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00424"></a>00424       }
<a name="l00425"></a>00425   
<a name="l00426"></a>00426       <span class="comment">//v1 = v2 +- v3; </span>
<a name="l00431"></a>00431 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l00432"></a>00432       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>,
<a name="l00433"></a>00433                                     self_type &amp;&gt;::type
<a name="l00434"></a><a class="code" href="classviennacl_1_1vector__base.html#a93c8163b27126bf6c57ecb85b49feabf">00434</a>       <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00435"></a>00435                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00436"></a>00436                                             OP&gt; &amp; proxy)
<a name="l00437"></a>00437       {
<a name="l00438"></a>00438         assert( ( (proxy.lhs().size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00439"></a>00439                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00440"></a>00440         
<a name="l00441"></a>00441         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00442"></a>00442         {
<a name="l00443"></a>00443           size_ = proxy.lhs().size();
<a name="l00444"></a>00444           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00445"></a>00445           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00446"></a>00446         } 
<a name="l00447"></a>00447   
<a name="l00448"></a>00448         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab55d2a6d333310c359eb03aab4411e1c">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00449"></a>00449                                proxy.lhs(), SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00450"></a>00450                                proxy.rhs(), SCALARTYPE(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l00451"></a>00451         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453       
<a name="l00458"></a>00458       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l00459"></a>00459                 <span class="keyword">typename</span> OP&gt;
<a name="l00460"></a>00460       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l00461"></a>00461                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00462"></a>00462                                     self_type &amp;&gt;::type
<a name="l00463"></a><a class="code" href="classviennacl_1_1vector__base.html#a27377e4c65395ce7c525c131d4c1f766">00463</a>       <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00464"></a>00464                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l00465"></a>00465                                            OP&gt; &amp; proxy)
<a name="l00466"></a>00466       {
<a name="l00467"></a>00467         assert( ( (proxy.lhs().size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00468"></a>00468                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00469"></a>00469         
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00471"></a>00471         {
<a name="l00472"></a>00472           size_ = proxy.lhs().size();
<a name="l00473"></a>00473           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00474"></a>00474           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00475"></a>00475         } 
<a name="l00476"></a>00476   
<a name="l00477"></a>00477         <span class="keywordtype">bool</span> flip_sign_2 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a>)
<a name="l00479"></a>00479           flip_sign_2 = !flip_sign_2;
<a name="l00480"></a>00480         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab55d2a6d333310c359eb03aab4411e1c">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00481"></a>00481                               proxy.lhs(),         SCALARTYPE(1.0), 1, false                                             , <span class="keyword">false</span>,
<a name="l00482"></a>00482                               proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_2);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00485"></a>00485       }
<a name="l00486"></a>00486   
<a name="l00491"></a>00491       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l00492"></a>00492                 <span class="keyword">typename</span> OP&gt;
<a name="l00493"></a>00493       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP1&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a>)
<a name="l00494"></a>00494                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00495"></a>00495                                     self_type &amp;&gt;::type
<a name="l00496"></a><a class="code" href="classviennacl_1_1vector__base.html#a1c342de5e734f41cbd12ddc916f7d61b">00496</a>       <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l00497"></a>00497                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00498"></a>00498                                            OP&gt; &amp; proxy)
<a name="l00499"></a>00499       {
<a name="l00500"></a>00500         assert( ( (proxy.size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00501"></a>00501                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00502"></a>00502         
<a name="l00503"></a>00503         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00504"></a>00504         {
<a name="l00505"></a>00505           size_ = proxy.lhs().size();
<a name="l00506"></a>00506           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00507"></a>00507           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00508"></a>00508         } 
<a name="l00509"></a>00509   
<a name="l00510"></a>00510         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab55d2a6d333310c359eb03aab4411e1c">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00511"></a>00511                               proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l00512"></a>00512                               proxy.rhs(),         SCALARTYPE(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l00513"></a>00513         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00514"></a>00514       }
<a name="l00515"></a>00515       
<a name="l00520"></a>00520       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l00521"></a>00521                 <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l00522"></a>00522                 <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l00523"></a>00523                 <span class="keyword">typename</span> OP&gt;
<a name="l00524"></a>00524       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP1&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a>)
<a name="l00525"></a>00525                                     &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l00526"></a>00526                                     &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l00527"></a>00527                                     self_type &amp;&gt;::type
<a name="l00528"></a><a class="code" href="classviennacl_1_1vector__base.html#a78ddfb4afeb752a38bda7fbee71a9c3e">00528</a>       <span class="keyword">operator</span> = (<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l00529"></a>00529                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l00530"></a>00530                                            OP&gt; &amp; proxy)
<a name="l00531"></a>00531       {
<a name="l00532"></a>00532         assert( ( (proxy.lhs().size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00533"></a>00533                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00534"></a>00534         
<a name="l00535"></a>00535         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00536"></a>00536         {
<a name="l00537"></a>00537           size_ = proxy.lhs().size();
<a name="l00538"></a>00538           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00539"></a>00539           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00540"></a>00540         } 
<a name="l00541"></a>00541   
<a name="l00542"></a>00542         <span class="keywordtype">bool</span> flip_sign_2 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00543"></a>00543         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a>)
<a name="l00544"></a>00544           flip_sign_2 = !flip_sign_2;
<a name="l00545"></a>00545         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab55d2a6d333310c359eb03aab4411e1c">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00546"></a>00546                               proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l00547"></a>00547                               proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_2);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00550"></a>00550       }
<a name="l00551"></a>00551       
<a name="l00552"></a>00552       
<a name="l00553"></a>00553       <span class="comment">//v1 = v2 * / v3; </span>
<a name="l00558"></a>00558 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l00559"></a>00559       <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; (viennacl::is_product&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a>),
<a name="l00560"></a>00560                                     self_type &amp;&gt;::type
<a name="l00561"></a><a class="code" href="classviennacl_1_1vector__base.html#a7dbdd7ea90aef1bb84605b3c86ccf3f7">00561</a>       <span class="keyword">operator</span> = (<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00562"></a>00562                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l00563"></a>00563                                            OP&gt; &amp; proxy)
<a name="l00564"></a>00564       {
<a name="l00565"></a>00565         assert( ( (proxy.lhs().size() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00566"></a>00566                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00567"></a>00567         
<a name="l00568"></a>00568         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00569"></a>00569         {
<a name="l00570"></a>00570           size_ = proxy.lhs().size();
<a name="l00571"></a>00571           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00572"></a>00572           <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00573"></a>00573         } 
<a name="l00574"></a>00574   
<a name="l00575"></a>00575         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ad13b15fd1f29384f6c3b5bbc4b47feef" title="Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)...">viennacl::linalg::element_op</a>(*<span class="keyword">this</span>, proxy);
<a name="l00576"></a>00576         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00577"></a>00577       }
<a name="l00578"></a>00578       
<a name="l00579"></a>00579       
<a name="l00580"></a>00580       
<a name="l00581"></a>00581       <span class="comment">// assign vector range or vector slice</span>
<a name="l00582"></a>00582       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00583"></a>00583       self_type &amp;
<a name="l00584"></a><a class="code" href="classviennacl_1_1vector__base.html#ae4c78fdea9013f3617ac2e87c0697324">00584</a>       <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1)
<a name="l00585"></a>00585       {
<a name="l00586"></a>00586         assert( ( (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00587"></a>00587                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00588"></a>00588         
<a name="l00589"></a>00589         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00590"></a>00590         {
<a name="l00591"></a>00591           size_ = v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>();
<a name="l00592"></a>00592           <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00593"></a>00593           {
<a name="l00594"></a>00594             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00595"></a>00595             <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>();
<a name="l00596"></a>00596           }
<a name="l00597"></a>00597         } 
<a name="l00598"></a>00598         
<a name="l00599"></a>00599         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab944766c932d732c660dfd8cce23557f">viennacl::linalg::av</a>(*<span class="keyword">this</span>, 
<a name="l00600"></a>00600                              v1, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00601"></a>00601         
<a name="l00602"></a>00602         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00603"></a>00603       }
<a name="l00604"></a>00604       
<a name="l00606"></a><a class="code" href="classviennacl_1_1vector__base.html#a4dcdb6c15f3d51904a8693ff9895c067">00606</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<a class="code" href="classviennacl_1_1unit__vector.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">unit_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v)
<a name="l00607"></a>00607       {
<a name="l00608"></a>00608         assert( ( (v.<a class="code" href="classviennacl_1_1unit__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00609"></a>00609                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00610"></a>00610         
<a name="l00611"></a>00611         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00612"></a>00612         {
<a name="l00613"></a>00613           size_ = v.<a class="code" href="classviennacl_1_1unit__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>();
<a name="l00614"></a>00614           <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00615"></a>00615             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617         
<a name="l00618"></a>00618         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00619"></a>00619         {
<a name="l00620"></a>00620           <a class="code" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero. Does not change the size of the vector.">clear</a>();
<a name="l00621"></a>00621           this-&gt;<a class="code" href="classviennacl_1_1vector__base.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(v.<a class="code" href="classviennacl_1_1unit__vector.html#ac60d57afcb61ce5035df36b8a3002c45">index</a>()) = SCALARTYPE(1);
<a name="l00622"></a>00622         }
<a name="l00623"></a>00623         
<a name="l00624"></a>00624         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00625"></a>00625       }
<a name="l00626"></a>00626       
<a name="l00628"></a><a class="code" href="classviennacl_1_1vector__base.html#adf893b2b113ffa442bdbf2cc700d3d96">00628</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<a class="code" href="classviennacl_1_1zero__vector.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v)
<a name="l00629"></a>00629       {
<a name="l00630"></a>00630         assert( ( (v.<a class="code" href="classviennacl_1_1zero__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00631"></a>00631                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00632"></a>00632         
<a name="l00633"></a>00633         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00634"></a>00634         {
<a name="l00635"></a>00635           size_ = v.<a class="code" href="classviennacl_1_1zero__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>();
<a name="l00636"></a>00636           <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00637"></a>00637             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639         
<a name="l00640"></a>00640         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00641"></a>00641           <a class="code" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero. Does not change the size of the vector.">clear</a>();
<a name="l00642"></a>00642         
<a name="l00643"></a>00643         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00644"></a>00644       }
<a name="l00645"></a>00645   
<a name="l00647"></a><a class="code" href="classviennacl_1_1vector__base.html#a7d0d055bd01dd6fd360e05636443b8b9">00647</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator = </a>(<a class="code" href="classviennacl_1_1scalar__vector.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v)
<a name="l00648"></a>00648       {
<a name="l00649"></a>00649         assert( ( (v.<a class="code" href="classviennacl_1_1scalar__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) || (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0) )
<a name="l00650"></a>00650                 &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00651"></a>00651         
<a name="l00652"></a>00652         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == 0)
<a name="l00653"></a>00653         {
<a name="l00654"></a>00654           size_ = v.<a class="code" href="classviennacl_1_1scalar__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>();
<a name="l00655"></a>00655           <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00656"></a>00656             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00657"></a>00657         }
<a name="l00658"></a>00658         
<a name="l00659"></a>00659         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00660"></a>00660           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a5666e85a9ba60d1f03b2dc0a30d0330f" title="Assign a constant value to a vector (-range/-slice)">viennacl::linalg::vector_assign</a>(*<span class="keyword">this</span>, v[0]);
<a name="l00661"></a>00661         
<a name="l00662"></a>00662         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00663"></a>00663       }
<a name="l00664"></a>00664   
<a name="l00665"></a>00665       
<a name="l00666"></a>00666       
<a name="l00668"></a>00668   
<a name="l00669"></a>00669       <span class="comment">//Note: The following operator overloads are defined in matrix_operations.hpp, compressed_matrix_operations.hpp and coordinate_matrix_operations.hpp</span>
<a name="l00670"></a>00670       <span class="comment">//This is certainly not the nicest approach and will most likely by changed in the future, but it works :-)</span>
<a name="l00671"></a>00671       
<a name="l00672"></a>00672       <span class="comment">//matrix&lt;&gt;</span>
<a name="l00677"></a>00677 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00678"></a><a class="code" href="classviennacl_1_1vector__base.html#a7e384c7a2f30a89bb334f8df2bf2f2a9">00678</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">viennacl::vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">matrix_base&lt;SCALARTYPE, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a>, viennacl::op_prod&gt; &amp; proxy)
<a name="l00679"></a>00679       {
<a name="l00680"></a>00680         assert(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy.lhs()) == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Size check failed for v1 = A * v2: size1(A) != size(v1)&quot;</span>));
<a name="l00681"></a>00681         
<a name="l00682"></a>00682         <span class="comment">// check for the special case x = A * x</span>
<a name="l00683"></a>00683         <span class="keywordflow">if</span> (<a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(proxy.rhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(*<span class="keyword">this</span>))
<a name="l00684"></a>00684         {
<a name="l00685"></a>00685           <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE&gt;</a> result(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy.lhs()));
<a name="l00686"></a>00686           <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), result);
<a name="l00687"></a>00687           *<span class="keyword">this</span> = result;
<a name="l00688"></a>00688         }
<a name="l00689"></a>00689         <span class="keywordflow">else</span>
<a name="l00690"></a>00690         {
<a name="l00691"></a>00691           <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00692"></a>00692         }
<a name="l00693"></a>00693         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00694"></a>00694       }
<a name="l00695"></a>00695   
<a name="l00696"></a>00696       
<a name="l00697"></a>00697       <span class="comment">//transposed_matrix_proxy:</span>
<a name="l00702"></a>00702 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00703"></a><a class="code" href="classviennacl_1_1vector__base.html#a8ea8b9ec85456e8340b12584ad645e2a">00703</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa5c64abfb6feb1fe07365d9d0bf47130" title="Assignment operator. Other vector needs to be of the same size, or this vector is not yet initialized...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">matrix_base&lt;SCALARTYPE, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html">matrix_base&lt;SCALARTYPE, F&gt;</a>, op_trans &gt;,
<a name="l00704"></a>00704                                                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a>,
<a name="l00705"></a>00705                                                      op_prod&gt; &amp; proxy)
<a name="l00706"></a>00706       {
<a name="l00707"></a>00707         assert(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy.lhs()) == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Size check failed in v1 = trans(A) * v2: size2(A) != size(v1)&quot;</span>));
<a name="l00708"></a>00708   
<a name="l00709"></a>00709         <span class="comment">// check for the special case x = trans(A) * x</span>
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (<a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(proxy.rhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(*<span class="keyword">this</span>))
<a name="l00711"></a>00711         {
<a name="l00712"></a>00712           <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE&gt;</a> result(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(proxy.lhs()));
<a name="l00713"></a>00713           <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), result);
<a name="l00714"></a>00714           *<span class="keyword">this</span> = result;
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716         <span class="keywordflow">else</span>
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718           <a class="code" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4" title="Carries out matrix-vector multiplication.">viennacl::linalg::prod_impl</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00721"></a>00721       }
<a name="l00722"></a>00722   
<a name="l00724"></a>00724 
<a name="l00725"></a>00725   
<a name="l00726"></a>00726       <span class="comment">//read-write access to an element of the vector</span>
<a name="l00729"></a><a class="code" href="classviennacl_1_1vector__base.html#ad39a7d06af546a8df947a8a36722eb03">00729</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector__base.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)
<a name="l00730"></a>00730       {
<a name="l00731"></a>00731         assert( (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)  &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Cannot apply operator() to vector of size zero!&quot;</span>));
<a name="l00732"></a>00732         assert( index &lt; <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Index out of bounds!&quot;</span>) );
<a name="l00733"></a>00733         
<a name="l00734"></a>00734         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(start_ + stride_ * index, elements_);
<a name="l00735"></a>00735       }
<a name="l00736"></a>00736   
<a name="l00739"></a><a class="code" href="classviennacl_1_1vector__base.html#af8f3f9c5c359c354201a0e4386b4cfcc">00739</a>       <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector__base.html#af8f3f9c5c359c354201a0e4386b4cfcc" title="Read-write access to a single element of the vector.">operator[]</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)
<a name="l00740"></a>00740       {
<a name="l00741"></a>00741         assert( (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)  &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Cannot apply operator() to vector of size zero!&quot;</span>));
<a name="l00742"></a>00742         assert( index &lt; <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Index out of bounds!&quot;</span>) );
<a name="l00743"></a>00743         
<a name="l00744"></a>00744         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(start_ + stride_ * index, elements_);
<a name="l00745"></a>00745       }
<a name="l00746"></a>00746   
<a name="l00747"></a>00747   
<a name="l00750"></a><a class="code" href="classviennacl_1_1vector__base.html#a0a081021edabde1ededaa17d2190d4c2">00750</a>       <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector__base.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)<span class="keyword"> const</span>
<a name="l00751"></a>00751 <span class="keyword">      </span>{
<a name="l00752"></a>00752         assert( (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)  &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Cannot apply operator() to vector of size zero!&quot;</span>));
<a name="l00753"></a>00753         assert( index &lt; <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Index out of bounds!&quot;</span>) );
<a name="l00754"></a>00754         
<a name="l00755"></a>00755         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a>(start_ + stride_ * index, elements_);
<a name="l00756"></a>00756       }
<a name="l00757"></a>00757       
<a name="l00760"></a><a class="code" href="classviennacl_1_1vector__base.html#af5300af0b7779ed3ca0b1abaaacc5d64">00760</a>       <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector__base.html#af8f3f9c5c359c354201a0e4386b4cfcc" title="Read-write access to a single element of the vector.">operator[]</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> index)<span class="keyword"> const</span>
<a name="l00761"></a>00761 <span class="keyword">      </span>{
<a name="l00762"></a>00762         assert( (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)  &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Cannot apply operator() to vector of size zero!&quot;</span>));
<a name="l00763"></a>00763         assert( index &lt; <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Index out of bounds!&quot;</span>) );
<a name="l00764"></a>00764         
<a name="l00765"></a>00765         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">const_entry_proxy&lt;SCALARTYPE&gt;</a>(start_ + stride_ * index, elements_);
<a name="l00766"></a>00766       }
<a name="l00767"></a>00767       
<a name="l00768"></a>00768       <span class="comment">//</span>
<a name="l00769"></a>00769       <span class="comment">// Operator overloads with implicit conversion (thus cannot be made global without introducing additional headache)</span>
<a name="l00770"></a>00770       <span class="comment">//</span>
<a name="l00771"></a>00771       
<a name="l00772"></a><a class="code" href="classviennacl_1_1vector__base.html#ae901a1ce2027fc044e8f7b9665826f5d">00772</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#ae901a1ce2027fc044e8f7b9665826f5d">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; vec)
<a name="l00773"></a>00773       {
<a name="l00774"></a>00774         assert(vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00775"></a>00775   
<a name="l00776"></a>00776         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l00777"></a>00777           <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00778"></a>00778                                   *<span class="keyword">this</span>, SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00779"></a>00779                                   vec,   SCALARTYPE(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00780"></a>00780         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00781"></a>00781       }
<a name="l00782"></a>00782       
<a name="l00783"></a><a class="code" href="classviennacl_1_1vector__base.html#afede1545613592581a6fc4b813fac86d">00783</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#afede1545613592581a6fc4b813fac86d">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; vec)
<a name="l00784"></a>00784       {
<a name="l00785"></a>00785         assert(vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l00786"></a>00786   
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l00788"></a>00788           <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(*<span class="keyword">this</span>, 
<a name="l00789"></a>00789                                   *<span class="keyword">this</span>, SCALARTYPE(1.0),  1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l00790"></a>00790                                   vec,   SCALARTYPE(-1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00791"></a>00791         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00792"></a>00792       }
<a name="l00793"></a>00793       
<a name="l00796"></a><a class="code" href="classviennacl_1_1vector__base.html#a131b09f05f2e3a9aceb0b376fb23b638">00796</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#a131b09f05f2e3a9aceb0b376fb23b638" title="Scales a vector (or proxy) by a CPU scalar value.">operator *= </a>(SCALARTYPE val)
<a name="l00797"></a>00797       {
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l00799"></a>00799           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab944766c932d732c660dfd8cce23557f">viennacl::linalg::av</a>(*<span class="keyword">this</span>,
<a name="l00800"></a>00800                                 *<span class="keyword">this</span>, val, 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00801"></a>00801         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00802"></a>00802       }
<a name="l00803"></a>00803       
<a name="l00806"></a><a class="code" href="classviennacl_1_1vector__base.html#ac0fce9b73d5213e8604dc604e71a608e">00806</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#ac0fce9b73d5213e8604dc604e71a608e" title="Scales this vector by a CPU scalar value.">operator /= </a>(SCALARTYPE val)
<a name="l00807"></a>00807       {
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l00809"></a>00809           <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#ab944766c932d732c660dfd8cce23557f">viennacl::linalg::av</a>(*<span class="keyword">this</span>,
<a name="l00810"></a>00810                                *<span class="keyword">this</span>, val, 1, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l00811"></a>00811         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00812"></a>00812       }
<a name="l00813"></a>00813       
<a name="l00814"></a>00814       
<a name="l00817"></a>00817       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const self_type, const SCALARTYPE, op_prod&gt;</a> 
<a name="l00818"></a><a class="code" href="classviennacl_1_1vector__base.html#a4b41a15beb1edf38c09d5bee8f75474b">00818</a>       <a class="code" href="classviennacl_1_1vector__base.html#a4b41a15beb1edf38c09d5bee8f75474b" title="Scales the vector by a CPU scalar &#39;alpha&#39; and returns an expression template.">operator * </a>(SCALARTYPE <a class="code" href="classviennacl_1_1value.html">value</a>)<span class="keyword"> const</span>
<a name="l00819"></a>00819 <span class="keyword">      </span>{
<a name="l00820"></a>00820         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const self_type, const SCALARTYPE, op_prod&gt;</a>(*<span class="keyword">this</span>, value);
<a name="l00821"></a>00821       }
<a name="l00822"></a>00822   
<a name="l00823"></a>00823   
<a name="l00826"></a>00826       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const self_type, const SCALARTYPE, op_prod&gt;</a> 
<a name="l00827"></a><a class="code" href="classviennacl_1_1vector__base.html#a0604ab0124a1a15735f40b408a31ba04">00827</a>       <a class="code" href="classviennacl_1_1vector__base.html#a0604ab0124a1a15735f40b408a31ba04" title="Scales the vector by a CPU scalar &#39;alpha&#39; and returns an expression template.">operator / </a>(SCALARTYPE <a class="code" href="classviennacl_1_1value.html">value</a>)<span class="keyword"> const</span>
<a name="l00828"></a>00828 <span class="keyword">      </span>{
<a name="l00829"></a>00829         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const self_type, const SCALARTYPE, op_prod&gt;</a>(*<span class="keyword">this</span>, SCALARTYPE(1.0) / value);
<a name="l00830"></a>00830       }
<a name="l00831"></a>00831       
<a name="l00832"></a>00832       
<a name="l00834"></a><a class="code" href="classviennacl_1_1vector__base.html#a041289decd3a01e20701a355a7f9c177">00834</a>       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const self_type, const SCALARTYPE, op_prod&gt;</a> <a class="code" href="classviennacl_1_1vector__base.html#a041289decd3a01e20701a355a7f9c177" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>()<span class="keyword"> const</span>
<a name="l00835"></a>00835 <span class="keyword">      </span>{
<a name="l00836"></a>00836         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const self_type, const SCALARTYPE, op_prod&gt;</a>(*<span class="keyword">this</span>, SCALARTYPE(-1.0));
<a name="l00837"></a>00837       }
<a name="l00838"></a>00838       
<a name="l00839"></a>00839       <span class="comment">//</span>
<a name="l00841"></a>00841 <span class="comment"></span>      <span class="comment">//</span>
<a name="l00842"></a>00842       
<a name="l00844"></a><a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8">00844</a>       <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">iterator</a> <a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>()
<a name="l00845"></a>00845       {
<a name="l00846"></a>00846         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a>(*<span class="keyword">this</span>, 0, start_, stride_);
<a name="l00847"></a>00847       }
<a name="l00848"></a>00848   
<a name="l00850"></a><a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f">00850</a>       <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">iterator</a> <a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>()
<a name="l00851"></a>00851       {
<a name="l00852"></a>00852         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__base.html#af259ae13e9ceb731eee5811dd73c743f">iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>(), start_, stride_);
<a name="l00853"></a>00853       }
<a name="l00854"></a>00854   
<a name="l00856"></a><a class="code" href="classviennacl_1_1vector__base.html#aa4b02d4f1a8500fb07a551069060709f">00856</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_iterator</a> <a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>()<span class="keyword"> const</span>
<a name="l00857"></a>00857 <span class="keyword">      </span>{
<a name="l00858"></a>00858         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a>(*<span class="keyword">this</span>, 0, start_, stride_);
<a name="l00859"></a>00859       }
<a name="l00860"></a>00860   
<a name="l00862"></a><a class="code" href="classviennacl_1_1vector__base.html#a350132543d80a1c1e5be844e6d2878ea">00862</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_iterator</a> <a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>()<span class="keyword"> const</span>
<a name="l00863"></a>00863 <span class="keyword">      </span>{
<a name="l00864"></a>00864         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__base.html#a38e4539acc7af91c7c6ba4f803325478">const_iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>(), start_, stride_);
<a name="l00865"></a>00865       }
<a name="l00866"></a>00866   
<a name="l00869"></a><a class="code" href="classviennacl_1_1vector__base.html#aec44f1e87d499827231c9087be3bd99b">00869</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aec44f1e87d499827231c9087be3bd99b" title="Swaps the entries of the two vectors.">swap</a>(<a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; other)
<a name="l00870"></a>00870       {
<a name="l00871"></a>00871         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a945a556a198a68294132d32df96b78a6" title="Swaps the contents of two vectors, data is copied.">viennacl::linalg::vector_swap</a>(*<span class="keyword">this</span>, other);
<a name="l00872"></a>00872         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00873"></a>00873       };
<a name="l00874"></a>00874       
<a name="l00875"></a>00875       
<a name="l00878"></a><a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7">00878</a>       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00879"></a>00879       
<a name="l00882"></a><a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c">00882</a>       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> viennacl::tools::roundUpToNextMultiple&lt;size_type&gt;(size_, 1); }
<a name="l00883"></a>00883 
<a name="l00886"></a><a class="code" href="classviennacl_1_1vector__base.html#ae8a8f4bf838f0a8a0f1d5fc75f43be27">00886</a>       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1vector__base.html#ae8a8f4bf838f0a8a0f1d5fc75f43be27" title="Returns the offset within the buffer.">start</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> start_; }
<a name="l00887"></a>00887       
<a name="l00890"></a><a class="code" href="classviennacl_1_1vector__base.html#aa1ac19fa335be66e75aa873f4e29fc4c">00890</a>       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> <a class="code" href="classviennacl_1_1vector__base.html#aa1ac19fa335be66e75aa873f4e29fc4c" title="Returns the stride within the buffer (in multiples of sizeof(SCALARTYPE))">stride</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stride_; }
<a name="l00891"></a>00891       
<a name="l00892"></a>00892       
<a name="l00894"></a><a class="code" href="classviennacl_1_1vector__base.html#ac6e61de369e994009e36f344f99c15ad">00894</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1vector__base.html#ac6e61de369e994009e36f344f99c15ad" title="Returns true is the size is zero.">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_ == 0; }
<a name="l00895"></a>00895       
<a name="l00897"></a><a class="code" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938">00897</a>       <span class="keyword">const</span> <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938" title="Returns the memory handle.">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> elements_; }
<a name="l00898"></a>00898   
<a name="l00900"></a><a class="code" href="classviennacl_1_1vector__base.html#aa1b198b314716d29e7aa65e6b6b71af9">00900</a>       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">handle_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#aa1b198b314716d29e7aa65e6b6b71af9" title="Returns the memory handle.">handle</a>() { <span class="keywordflow">return</span> elements_; }
<a name="l00901"></a>00901       
<a name="l00904"></a><a class="code" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204">00904</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector__base.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero. Does not change the size of the vector.">clear</a>()
<a name="l00905"></a>00905       {
<a name="l00906"></a>00906         <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a5666e85a9ba60d1f03b2dc0a30d0330f" title="Assign a constant value to a vector (-range/-slice)">viennacl::linalg::vector_assign</a>(*<span class="keyword">this</span>, <a class="code" href="classviennacl_1_1vector__base.html#afe14f79ef563aa2fc6b051029e0eb93b">cpu_value_type</a>(0.0));
<a name="l00907"></a>00907       }
<a name="l00908"></a>00908       
<a name="l00909"></a><a class="code" href="classviennacl_1_1vector__base.html#a4d7af104d914cb4ffd07463d5e19d721">00909</a>       <a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> <a class="code" href="classviennacl_1_1vector__base.html#a4d7af104d914cb4ffd07463d5e19d721">memory_domain</a>()<span class="keyword"> const</span>
<a name="l00910"></a>00910 <span class="keyword">      </span>{
<a name="l00911"></a>00911         <span class="keywordflow">return</span> elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#acd29573cd156d000f75668bba858cca3" title="Returns an ID for the currently active memory buffer. Other memory buffers might contain old or no da...">get_active_handle_id</a>();
<a name="l00912"></a>00912       }
<a name="l00913"></a>00913       
<a name="l00914"></a>00914     <span class="keyword">protected</span>:
<a name="l00915"></a>00915       
<a name="l00916"></a><a class="code" href="classviennacl_1_1vector__base.html#a06bd1620b92852143daab47c58918b30">00916</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector__base.html#a06bd1620b92852143daab47c58918b30">set_handle</a>(<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> <span class="keyword">const</span> &amp; h)
<a name="l00917"></a>00917       {
<a name="l00918"></a>00918         elements_ = h;
<a name="l00919"></a>00919       }
<a name="l00920"></a>00920         
<a name="l00923"></a><a class="code" href="classviennacl_1_1vector__base.html#a7d9d5c3cb020f5f2f5f160d624f387a0">00923</a>       <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector__base.html#a7d9d5c3cb020f5f2f5f160d624f387a0" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">fast_swap</a>(<a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; other) 
<a name="l00924"></a>00924       { 
<a name="l00925"></a>00925         assert(this-&gt;size_ == other.size_ &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vector size mismatch&quot;</span>)); 
<a name="l00926"></a>00926         this-&gt;elements_.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#afafd9b350d21b16440da38dc4e52be64" title="Implements a fast swapping method. No data is copied, only the handles are exchanged.">swap</a>(other.elements_); 
<a name="l00927"></a>00927         <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00928"></a>00928       }
<a name="l00929"></a>00929       
<a name="l00931"></a><a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e">00931</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>()
<a name="l00932"></a>00932       {
<a name="l00933"></a>00933         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>() != <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>())
<a name="l00934"></a>00934         {
<a name="l00935"></a>00935           std::vector&lt;SCALARTYPE&gt; <a class="code" href="classviennacl_1_1vector__base.html#ae715ade8c14c274c4a1f416423380f1e" title="Pads vectors with alignment &gt; 1 with trailing zeros if the internal size is larger than the visible s...">pad</a>(<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>() - <a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>());
<a name="l00936"></a>00936           <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a783445c0255733c8e6073cd8fe3c2a83" title="Writes data from main RAM identified by &#39;ptr&#39; to the buffer identified by &#39;dst_buffer&#39;.">viennacl::backend::memory_write</a>(elements_, 0, <span class="keyword">sizeof</span>(SCALARTYPE) * pad.size(), &amp;(pad[0]));
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938       }
<a name="l00939"></a>00939       
<a name="l00940"></a><a class="code" href="classviennacl_1_1vector__base.html#ad2283ab2934e9bfcd2335d00cb56519a">00940</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector__base.html#ad2283ab2934e9bfcd2335d00cb56519a">switch_memory_domain</a>(<a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> new_domain)
<a name="l00941"></a>00941       {
<a name="l00942"></a>00942         viennacl::backend::switch_memory_domain&lt;SCALARTYPE&gt;(elements_, new_domain);
<a name="l00943"></a>00943       }
<a name="l00944"></a>00944       
<a name="l00945"></a>00945       <span class="comment">//TODO: Think about implementing the following public member functions</span>
<a name="l00946"></a>00946       <span class="comment">//void insert_element(unsigned int i, SCALARTYPE val){}</span>
<a name="l00947"></a>00947       <span class="comment">//void erase_element(unsigned int i){}</span>
<a name="l00948"></a>00948       
<a name="l00949"></a>00949       <span class="comment">//enlarge or reduce allocated memory and set unused memory to zero</span>
<a name="l00955"></a><a class="code" href="classviennacl_1_1vector__base.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">00955</a> <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector__base.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">resize</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> new_size, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
<a name="l00956"></a>00956       {
<a name="l00957"></a>00957         assert(new_size &gt; 0 &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Positive size required when resizing vector!&quot;</span>));
<a name="l00958"></a>00958         
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (new_size != size_)
<a name="l00960"></a>00960         {
<a name="l00961"></a>00961           std::size_t new_internal_size = viennacl::tools::roundUpToNextMultiple&lt;std::size_t&gt;(new_size, 1);
<a name="l00962"></a>00962         
<a name="l00963"></a>00963           std::vector&lt;SCALARTYPE&gt; temp(size_);
<a name="l00964"></a>00964           <span class="keywordflow">if</span> (preserve &amp;&amp; size_ &gt; 0)
<a name="l00965"></a>00965             <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(*<span class="keyword">this</span>, temp);
<a name="l00966"></a>00966           temp.resize(new_size);  <span class="comment">//drop all entries above new_size</span>
<a name="l00967"></a>00967           temp.resize(new_internal_size); <span class="comment">//enlarge to fit new internal size</span>
<a name="l00968"></a>00968           
<a name="l00969"></a>00969           <span class="keywordflow">if</span> (new_internal_size != <a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>())
<a name="l00970"></a>00970           {
<a name="l00971"></a>00971             <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a44015b4bf171786babcaa5d3713aa3cb" title="Creates an array of the specified size in main RAM. If the second argument is provided, the buffer is initialized with data from that pointer.">viennacl::backend::memory_create</a>(elements_, <span class="keyword">sizeof</span>(SCALARTYPE)*new_internal_size);
<a name="l00972"></a>00972           }
<a name="l00973"></a>00973           
<a name="l00974"></a>00974           <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(temp, *<span class="keyword">this</span>);
<a name="l00975"></a>00975           size_ = new_size;
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977         
<a name="l00978"></a>00978       }
<a name="l00979"></a>00979       
<a name="l00980"></a>00980       
<a name="l00981"></a>00981     <span class="keyword">private</span>:
<a name="l00982"></a>00982       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>       size_;
<a name="l00983"></a>00983       <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a>       start_;
<a name="l00984"></a>00984       <a class="code" href="classviennacl_1_1vector__base.html#a3dfbb913139aab3a7932d35f1ad1422a">difference_type</a> stride_;
<a name="l00985"></a>00985       <a class="code" href="classviennacl_1_1vector__base.html#a54da31d88e477d0e9f61b0715fdc8162">handle_type</a> elements_;
<a name="l00986"></a>00986   }; <span class="comment">//vector_base</span>
<a name="l00987"></a>00987   
<a name="l00988"></a>00988   
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   <span class="comment">// forward definition in forwards.h!</span>
<a name="l00999"></a>00999 <span class="comment"></span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01000"></a><a class="code" href="classviennacl_1_1vector.html">01000</a>   <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector</a> : <span class="keyword">public</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base</a>&lt;SCALARTYPE&gt;
<a name="l01001"></a>01001   {
<a name="l01002"></a>01002     <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">self_type</a>;
<a name="l01003"></a>01003     <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__base.html">vector_base&lt;SCALARTYPE&gt;</a>               <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>;
<a name="l01004"></a>01004     
<a name="l01005"></a>01005   <span class="keyword">public</span>:
<a name="l01006"></a><a class="code" href="classviennacl_1_1vector.html#a6d6dadd7b4260bf281cc6277f382acac">01006</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">base_type::size_type</a>                  <a class="code" href="classviennacl_1_1vector.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a>;
<a name="l01007"></a>01007 
<a name="l01010"></a><a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383">01010</a>     <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>() : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>() { <span class="comment">/* Note: One must not call ::init() here because the vector might have been created globally before the backend has become available */</span> }
<a name="l01011"></a>01011 
<a name="l01016"></a><a class="code" href="classviennacl_1_1vector.html#a37af05b711e0806bd57ae6e4adfeb46e">01016</a>     <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector.html#a37af05b711e0806bd57ae6e4adfeb46e" title="An explicit constructor for the vector, allocating the given amount of memory (plus a padding specifi...">vector</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> vec_size) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(vec_size) {}
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="preprocessor">#ifdef VIENNACL_WITH_OPENCL</span>
<a name="l01019"></a>01019 <span class="preprocessor"></span>
<a name="l01027"></a>01027     <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(cl_mem existing_mem, <a class="code" href="classviennacl_1_1vector.html#a6d6dadd7b4260bf281cc6277f382acac">size_type</a> vec_size) : base_type(vec_size)
<a name="l01028"></a>01028     {
<a name="l01029"></a>01029       <a class="code" href="classviennacl_1_1backend_1_1mem__handle.html" title="Main abstraction class for multiple memory domains. Represents a buffer in either main RAM...">viennacl::backend::mem_handle</a> h;
<a name="l01030"></a>01030       h.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a016f1218a02268c06c3009803cc3073d" title="Switches the currently active handle. If no support for that backend is provided, an exception is thr...">switch_active_handle_id</a>(<a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">viennacl::OPENCL_MEMORY</a>);
<a name="l01031"></a>01031       h.opencl_handle() = existing_mem;
<a name="l01032"></a>01032       h.opencl_handle().inc();  <span class="comment">//prevents that the user-provided memory is deleted once the vector object is destroyed.</span>
<a name="l01033"></a>01033       h.<a class="code" href="classviennacl_1_1backend_1_1mem__handle.html#a88c5d6be919f60a44e114b3269d730fd" title="Returns the number of bytes of the currently active buffer.">raw_size</a>(<span class="keyword">sizeof</span>(SCALARTYPE) * vec_size);
<a name="l01034"></a>01034       
<a name="l01035"></a>01035       <a class="code" href="classviennacl_1_1vector__base.html#a06bd1620b92852143daab47c58918b30">base_type::set_handle</a>(h);
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037 <span class="preprocessor">#endif</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>    
<a name="l01039"></a>01039     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01040"></a><a class="code" href="classviennacl_1_1vector.html#a1005d197ecc9b43cee50d4ddc1047202">01040</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const LHS, const RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(proxy.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>(), viennacl::traits::<a class="code" href="namespaceviennacl_1_1traits.html#aad443a796634a9648e19b4156fcd880d" title="Returns an ID for the currently active memory domain of an object.">active_handle_id</a>(proxy))
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042       <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">self_type::operator=</a>(proxy);
<a name="l01043"></a>01043     }
<a name="l01044"></a>01044 
<a name="l01045"></a><a class="code" href="classviennacl_1_1vector.html#ac54d8f85cacd73f74edb00cb80be0e73">01045</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">base_type</a> &amp; v) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>(), v.<a class="code" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938" title="Returns the memory handle.">handle</a>().get_active_handle_id())
<a name="l01046"></a>01046     {
<a name="l01047"></a>01047       <span class="keywordflow">if</span> (v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01048"></a>01048         base_type::operator=(v);
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a><a class="code" href="classviennacl_1_1vector.html#ac1123319e66fae664c78e00e5251845a">01051</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; v) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>(), v.<a class="code" href="classviennacl_1_1vector__base.html#a0830e530145e6372224c89153128e938" title="Returns the memory handle.">handle</a>().get_active_handle_id())
<a name="l01052"></a>01052     {
<a name="l01053"></a>01053       <span class="keywordflow">if</span> (v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01054"></a>01054         base_type::operator=(v);
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056     
<a name="l01058"></a><a class="code" href="classviennacl_1_1vector.html#a7e459922c6c17bedc5280caf03b2f565">01058</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1unit__vector.html" title="Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initialize...">unit_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>())
<a name="l01059"></a>01059     {
<a name="l01060"></a>01060       <span class="keywordflow">if</span> (v.<a class="code" href="classviennacl_1_1unit__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() &gt; 0)
<a name="l01061"></a>01061         this-&gt;<span class="keyword">operator</span>()(v.<a class="code" href="classviennacl_1_1unit__vector.html#ac60d57afcb61ce5035df36b8a3002c45">index</a>()) = 1;
<a name="l01062"></a>01062     }
<a name="l01063"></a>01063     
<a name="l01065"></a><a class="code" href="classviennacl_1_1vector.html#ae1841113c35e3f3a7e1a9b094f41e277">01065</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1zero__vector.html" title="Represents a vector consisting of zeros only. To be used as an initializer for viennacl::vector, vector_range, or vector_slize only.">zero_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) 
<a name="l01066"></a>01066     {
<a name="l01067"></a>01067       <span class="keywordflow">if</span> (v.<a class="code" href="classviennacl_1_1zero__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() &gt; 0)
<a name="l01068"></a>01068         <a class="code" href="namespaceviennacl_1_1linalg.html#aedeab8ab68ef95c6b3c432c0edb7a7fa" title="Assign a constant value to a vector (-range/-slice)">viennacl::linalg::vector_assign</a>(*<span class="keyword">this</span>, SCALARTYPE(0.0));
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01072"></a><a class="code" href="classviennacl_1_1vector.html#a68bb4de19a2a3fd1a38c28ca3ad7c838">01072</a>     <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1scalar__vector.html" title="Represents a vector consisting of scalars &#39;s&#39; only, i.e. v[i] = s for all i. To be used as an initial...">scalar_vector&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; v) : <a class="code" href="classviennacl_1_1vector__base.html">base_type</a>(v.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>())
<a name="l01073"></a>01073     {
<a name="l01074"></a>01074       <span class="keywordflow">if</span> (v.<a class="code" href="classviennacl_1_1scalar__vector.html#a503ab01f6c0142145d3434f6924714e7">size</a>() &gt; 0)
<a name="l01075"></a>01075         <a class="code" href="namespaceviennacl_1_1linalg.html#aedeab8ab68ef95c6b3c432c0edb7a7fa" title="Assign a constant value to a vector (-range/-slice)">viennacl::linalg::vector_assign</a>(*<span class="keyword">this</span>, v[0]);
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="keyword">using</span> base_type::operator=;
<a name="l01079"></a>01079     
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="comment">// Note: Dense operations are already handled in vector_base</span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084     <span class="comment">//</span>
<a name="l01085"></a>01085     <span class="comment">// Sparse matrices</span>
<a name="l01086"></a>01086     <span class="comment">//</span>
<a name="l01087"></a>01087     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SparseMatrixType&gt;
<a name="l01088"></a>01088     <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_sparse_matrix&lt;SparseMatrixType&gt;::value</a>,
<a name="l01089"></a>01089                                   self_type &amp; &gt;::type
<a name="l01090"></a>01090     <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">viennacl::vector_expression</a>&lt; <span class="keyword">const</span> SparseMatrixType,
<a name="l01091"></a>01091                                                  <span class="keyword">const</span> base_type,
<a name="l01092"></a>01092                                                  viennacl::op_prod&gt; &amp; proxy) ;
<a name="l01093"></a>01093     
<a name="l01094"></a>01094     <span class="comment">//</span>
<a name="l01095"></a>01095     <span class="comment">// circulant_matrix&lt;&gt;</span>
<a name="l01096"></a>01096     <span class="comment">//</span>
<a name="l01101"></a>01101 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01102"></a>01102     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01103"></a>01103                                                    <span class="keyword">const</span> base_type,
<a name="l01104"></a>01104                                                    op_prod&gt; &amp; proxy);
<a name="l01105"></a>01105 
<a name="l01110"></a>01110     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01111"></a>01111     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#af32ea62c6222fd49fe2adb7e6941af55" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01112"></a>01112                                                     <span class="keyword">const</span> base_type,
<a name="l01113"></a>01113                                                     op_prod&gt; &amp; proxy);
<a name="l01114"></a>01114                                               
<a name="l01119"></a>01119     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01120"></a>01120     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#a52bb6d9095c64e26109bd988c3536654" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01121"></a>01121                                                     <span class="keyword">const</span> base_type,
<a name="l01122"></a>01122                                                     op_prod&gt; &amp; proxy);
<a name="l01123"></a>01123 
<a name="l01128"></a>01128     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01129"></a>01129     self_type <a class="code" href="classviennacl_1_1vector.html#af859359c2720dfafc8d2208595fa8527" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type circulan...">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01130"></a>01130                                                  <span class="keyword">const</span> base_type,
<a name="l01131"></a>01131                                                  op_prod&gt; &amp; proxy);
<a name="l01132"></a>01132 
<a name="l01137"></a>01137     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01138"></a>01138     self_type <a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01139"></a>01139                                                  <span class="keyword">const</span> base_type,
<a name="l01140"></a>01140                                                  op_prod&gt; &amp; proxy);
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="comment">//</span>
<a name="l01144"></a>01144     <span class="comment">// hankel_matrix&lt;&gt;</span>
<a name="l01145"></a>01145     <span class="comment">//</span>
<a name="l01150"></a>01150 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01151"></a>01151     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01152"></a>01152                                                    <span class="keyword">const</span> base_type,
<a name="l01153"></a>01153                                                    op_prod&gt; &amp; proxy);
<a name="l01154"></a>01154 
<a name="l01159"></a>01159     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01160"></a>01160     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#af32ea62c6222fd49fe2adb7e6941af55" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01161"></a>01161                                                     <span class="keyword">const</span> base_type,
<a name="l01162"></a>01162                                                     op_prod&gt; &amp; proxy);
<a name="l01163"></a>01163                                               
<a name="l01168"></a>01168     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01169"></a>01169     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#a52bb6d9095c64e26109bd988c3536654" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01170"></a>01170                                                     <span class="keyword">const</span> base_type,
<a name="l01171"></a>01171                                                     op_prod&gt; &amp; proxy);
<a name="l01172"></a>01172 
<a name="l01177"></a>01177     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01178"></a>01178     self_type <a class="code" href="classviennacl_1_1vector.html#af859359c2720dfafc8d2208595fa8527" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type circulan...">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01179"></a>01179                                                  <span class="keyword">const</span> base_type,
<a name="l01180"></a>01180                                                  op_prod&gt; &amp; proxy);
<a name="l01181"></a>01181 
<a name="l01186"></a>01186     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01187"></a>01187     self_type <a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01188"></a>01188                                                  <span class="keyword">const</span> base_type,
<a name="l01189"></a>01189                                                  op_prod&gt; &amp; proxy);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="comment">//</span>
<a name="l01192"></a>01192     <span class="comment">// toeplitz_matrix&lt;&gt;</span>
<a name="l01193"></a>01193     <span class="comment">//</span>
<a name="l01198"></a>01198 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01199"></a>01199     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01200"></a>01200                                                    <span class="keyword">const</span> base_type,
<a name="l01201"></a>01201                                                    op_prod&gt; &amp; proxy);
<a name="l01202"></a>01202 
<a name="l01207"></a>01207     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01208"></a>01208     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#af32ea62c6222fd49fe2adb7e6941af55" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01209"></a>01209                                                     <span class="keyword">const</span> base_type,
<a name="l01210"></a>01210                                                     op_prod&gt; &amp; proxy);
<a name="l01211"></a>01211                                               
<a name="l01216"></a>01216     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01217"></a>01217     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#a52bb6d9095c64e26109bd988c3536654" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01218"></a>01218                                                     <span class="keyword">const</span> base_type,
<a name="l01219"></a>01219                                                     op_prod&gt; &amp; proxy);
<a name="l01220"></a>01220 
<a name="l01225"></a>01225     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01226"></a>01226     self_type <a class="code" href="classviennacl_1_1vector.html#af859359c2720dfafc8d2208595fa8527" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type circulan...">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01227"></a>01227                                                   <span class="keyword">const</span> base_type,
<a name="l01228"></a>01228                                                   op_prod&gt; &amp; proxy);
<a name="l01229"></a>01229 
<a name="l01234"></a>01234     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01235"></a>01235     self_type <a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01236"></a>01236                                                   <span class="keyword">const</span> base_type,
<a name="l01237"></a>01237                                                   op_prod&gt; &amp; proxy);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     
<a name="l01240"></a>01240     <span class="comment">//</span>
<a name="l01241"></a>01241     <span class="comment">// vandermonde_matrix&lt;&gt;</span>
<a name="l01242"></a>01242     <span class="comment">//</span>
<a name="l01247"></a>01247 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01248"></a>01248     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#add67bd7306444d75f1f7a222e440f28b" title="Implementation of the operation v1 = A * v2, where A is a sparse matrix.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01249"></a>01249                                                     <span class="keyword">const</span> base_type,
<a name="l01250"></a>01250                                                     op_prod&gt; &amp; proxy);
<a name="l01251"></a>01251 
<a name="l01256"></a>01256     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01257"></a>01257     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#af32ea62c6222fd49fe2adb7e6941af55" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01258"></a>01258                                                     <span class="keyword">const</span> base_type,
<a name="l01259"></a>01259                                                     op_prod&gt; &amp; proxy);
<a name="l01260"></a>01260                                               
<a name="l01265"></a>01265     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01266"></a>01266     self_type &amp; <a class="code" href="classviennacl_1_1vector.html#a52bb6d9095c64e26109bd988c3536654" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type circula...">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01267"></a>01267                                                     <span class="keyword">const</span> base_type,
<a name="l01268"></a>01268                                                     op_prod&gt; &amp; proxy);
<a name="l01269"></a>01269 
<a name="l01274"></a>01274     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01275"></a>01275     self_type <a class="code" href="classviennacl_1_1vector.html#af859359c2720dfafc8d2208595fa8527" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type circulan...">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01276"></a>01276                                                  <span class="keyword">const</span> base_type,
<a name="l01277"></a>01277                                                  op_prod&gt; &amp; proxy);
<a name="l01278"></a>01278 
<a name="l01283"></a>01283     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l01284"></a>01284     self_type <a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l01285"></a>01285                                                  <span class="keyword">const</span> base_type,
<a name="l01286"></a>01286                                                  op_prod&gt; &amp; proxy);
<a name="l01287"></a>01287     
<a name="l01289"></a>01289     
<a name="l01291"></a><a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f">01291</a>     <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_base&lt;SCALARTYPE&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt; <a class="code" href="classviennacl_1_1vector.html#a9b12c32e6ef9a0835ae60bef75df501f" title="Sign flip for the vector. Emulated to be equivalent to -1.0 * vector.">operator-</a>()<span class="keyword"> const</span>
<a name="l01292"></a>01292 <span class="keyword">    </span>{
<a name="l01293"></a>01293       <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_base&lt;SCALARTYPE&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt;(*<span class="keyword">this</span>, SCALARTYPE(-1.0));
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295     
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="comment">//enlarge or reduce allocated memory and set unused memory to zero</span>
<a name="l01303"></a><a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">01303</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">resize</a>(<a class="code" href="classviennacl_1_1vector__base.html#a233dcbba0ec084278552de99c8b0a231">size_type</a> new_size, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
<a name="l01304"></a>01304     {
<a name="l01305"></a>01305       <a class="code" href="classviennacl_1_1vector__base.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">base_type::resize</a>(new_size, preserve);
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     
<a name="l01308"></a>01308 
<a name="l01311"></a><a class="code" href="classviennacl_1_1vector.html#a7d9d5c3cb020f5f2f5f160d624f387a0">01311</a>     <a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a7d9d5c3cb020f5f2f5f160d624f387a0" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">fast_swap</a>(<a class="code" href="classviennacl_1_1vector__base.html">self_type</a> &amp; other) 
<a name="l01312"></a>01312     { 
<a name="l01313"></a>01313       <a class="code" href="classviennacl_1_1vector__base.html#a7d9d5c3cb020f5f2f5f160d624f387a0" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">base_type::fast_swap</a>(other);
<a name="l01314"></a>01314       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316     
<a name="l01317"></a><a class="code" href="classviennacl_1_1vector.html#ad2283ab2934e9bfcd2335d00cb56519a">01317</a>     <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector.html#ad2283ab2934e9bfcd2335d00cb56519a">switch_memory_domain</a>(<a class="code" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">viennacl::memory_types</a> new_domain)
<a name="l01318"></a>01318     {
<a name="l01319"></a>01319       <a class="code" href="classviennacl_1_1vector__base.html#ad2283ab2934e9bfcd2335d00cb56519a">base_type::switch_memory_domain</a>(new_domain);
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321     
<a name="l01322"></a>01322   }; <span class="comment">//vector</span>
<a name="l01323"></a>01323   
<a name="l01324"></a>01324 
<a name="l01325"></a>01325   <span class="comment">//</span>
<a name="l01327"></a>01327 <span class="comment"></span>  <span class="comment">//</span>
<a name="l01328"></a>01328   
<a name="l01329"></a>01329 
<a name="l01341"></a>01341   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01342"></a><a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">01342</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01343"></a>01343                   <span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01344"></a>01344                   CPU_ITERATOR cpu_begin )
<a name="l01345"></a>01345   {
<a name="l01346"></a>01346     <span class="keywordflow">if</span> (gpu_begin != gpu_end)
<a name="l01347"></a>01347     {
<a name="l01348"></a>01348       <span class="keywordflow">if</span> (gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() == 1)
<a name="l01349"></a>01349       {
<a name="l01350"></a>01350         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>(), 
<a name="l01351"></a>01351                                       <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(),
<a name="l01352"></a>01352                                       <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() * (gpu_end - gpu_begin),
<a name="l01353"></a>01353                                       &amp;(*cpu_begin));
<a name="l01354"></a>01354       }
<a name="l01355"></a>01355       <span class="keywordflow">else</span>
<a name="l01356"></a>01356       {
<a name="l01357"></a>01357         std::size_t gpu_size = (gpu_end - gpu_begin);
<a name="l01358"></a>01358         std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() * gpu_size);
<a name="l01359"></a>01359         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*temp_buffer.size(), &amp;(temp_buffer[0]));
<a name="l01360"></a>01360 
<a name="l01361"></a>01361         <span class="keywordflow">for</span> (std::size_t i=0; i&lt;gpu_size; ++i)
<a name="l01362"></a>01362         {
<a name="l01363"></a>01363           (&amp;(*cpu_begin))[i] = temp_buffer[i * gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>()];
<a name="l01364"></a>01364         }
<a name="l01365"></a>01365       }
<a name="l01366"></a>01366     }
<a name="l01367"></a>01367   }
<a name="l01368"></a>01368 
<a name="l01374"></a>01374   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01375"></a><a class="code" href="namespaceviennacl.html#a18efe971cc5df1ca97ca63bf7565a8ed">01375</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> <span class="keyword">const</span> &amp; gpu_vec, CPUVECTOR &amp; cpu_vec )
<a name="l01376"></a>01376   {
<a name="l01377"></a>01377     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), cpu_vec.begin());
<a name="l01378"></a>01378   }
<a name="l01379"></a>01379 
<a name="l01380"></a>01380   
<a name="l01387"></a>01387   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01388"></a><a class="code" href="namespaceviennacl.html#a592a3a17afda2a630893f43e4a682143">01388</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01389"></a>01389             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01390"></a>01390             CPU_ITERATOR cpu_begin )
<a name="l01391"></a>01391   {
<a name="l01392"></a>01392     assert(gpu_end - gpu_begin &gt;= 0 &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Iterators incompatible&quot;</span>));
<a name="l01393"></a>01393     <span class="keywordflow">if</span> (gpu_end - gpu_begin != 0)
<a name="l01394"></a>01394     {
<a name="l01395"></a>01395       std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_end - gpu_begin);
<a name="l01396"></a>01396       <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(gpu_begin, gpu_end, temp_buffer.begin());
<a name="l01397"></a>01397       
<a name="l01398"></a>01398       <span class="comment">//now copy entries to cpu_vec:</span>
<a name="l01399"></a>01399       <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">std::copy</a>(temp_buffer.begin(), temp_buffer.end(), cpu_begin);
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401   }
<a name="l01402"></a>01402 
<a name="l01409"></a>01409   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01410"></a><a class="code" href="namespaceviennacl.html#a247dbb2faef4f43e89a6ea3c5ebdb028">01410</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01411"></a>01411             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01412"></a>01412             CPU_ITERATOR cpu_begin )
<a name="l01413"></a>01413 
<a name="l01414"></a>01414   {
<a name="l01415"></a>01415     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>(gpu_begin),
<a name="l01416"></a>01416                     <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>(gpu_end),
<a name="l01417"></a>01417                     cpu_begin);
<a name="l01418"></a>01418   }
<a name="l01419"></a>01419   
<a name="l01425"></a>01425   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01426"></a><a class="code" href="namespaceviennacl.html#a41d005b9f0d205c14417da3dbdaff0f7">01426</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> <span class="keyword">const</span> &amp; gpu_vec, CPUVECTOR &amp; cpu_vec )
<a name="l01427"></a>01427   {
<a name="l01428"></a>01428     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), cpu_vec.begin());
<a name="l01429"></a>01429   }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 <span class="preprocessor">  #ifdef VIENNACL_WITH_EIGEN</span>
<a name="l01434"></a>01434 <span class="preprocessor"></span>  <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01435"></a>01435   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(vector&lt;float, ALIGNMENT&gt; <span class="keyword">const</span> &amp; gpu_vec,
<a name="l01436"></a>01436             Eigen::VectorXf &amp; eigen_vec)
<a name="l01437"></a>01437   {
<a name="l01438"></a>01438     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(gpu_vec.begin(), gpu_vec.end(), &amp;(eigen_vec[0]));
<a name="l01439"></a>01439   }
<a name="l01440"></a>01440   
<a name="l01441"></a>01441   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01442"></a>01442   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(vector&lt;double, ALIGNMENT&gt; &amp; gpu_vec,
<a name="l01443"></a>01443             Eigen::VectorXd &amp; eigen_vec)
<a name="l01444"></a>01444   {
<a name="l01445"></a>01445     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(gpu_vec.begin(), gpu_vec.end(), &amp;(eigen_vec[0]));
<a name="l01446"></a>01446   }
<a name="l01447"></a>01447 <span class="preprocessor">  #endif</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span>
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <span class="comment">//</span>
<a name="l01452"></a>01452 <span class="comment"></span>  <span class="comment">//</span>
<a name="l01453"></a>01453 
<a name="l01465"></a>01465   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CPU_ITERATOR, <span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01466"></a><a class="code" href="namespaceviennacl.html#abfe63ce6ea6eded970702b69279c37fb">01466</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_begin,
<a name="l01467"></a>01467                   CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_end,
<a name="l01468"></a>01468                   <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> gpu_begin)
<a name="l01469"></a>01469   {
<a name="l01470"></a>01470     <span class="keywordflow">if</span> (cpu_end - cpu_begin &gt; 0)
<a name="l01471"></a>01471     {
<a name="l01472"></a>01472       <span class="keywordflow">if</span> (gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() == 1)
<a name="l01473"></a>01473       {
<a name="l01474"></a>01474         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a783445c0255733c8e6073cd8fe3c2a83" title="Writes data from main RAM identified by &#39;ptr&#39; to the buffer identified by &#39;dst_buffer&#39;.">viennacl::backend::memory_write</a>(gpu_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>(),
<a name="l01475"></a>01475                                         <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(),
<a name="l01476"></a>01476                                         <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() * (cpu_end - cpu_begin), &amp;(*cpu_begin));
<a name="l01477"></a>01477       }
<a name="l01478"></a>01478       <span class="keywordflow">else</span> <span class="comment">//writing to slice:</span>
<a name="l01479"></a>01479       {
<a name="l01480"></a>01480         std::size_t cpu_size = (cpu_end - cpu_begin);
<a name="l01481"></a>01481         std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() * cpu_size);
<a name="l01482"></a>01482         
<a name="l01483"></a>01483         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a0b602e81fad22f0772ceba3587d20d5b" title="Reads data from a buffer back to main RAM.">viennacl::backend::memory_read</a>(gpu_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*temp_buffer.size(), &amp;(temp_buffer[0]));
<a name="l01484"></a>01484 
<a name="l01485"></a>01485         <span class="keywordflow">for</span> (std::size_t i=0; i&lt;cpu_size; ++i)
<a name="l01486"></a>01486           temp_buffer[i * gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>()] = (&amp;(*cpu_begin))[i];
<a name="l01487"></a>01487         
<a name="l01488"></a>01488         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a783445c0255733c8e6073cd8fe3c2a83" title="Writes data from main RAM identified by &#39;ptr&#39; to the buffer identified by &#39;dst_buffer&#39;.">viennacl::backend::memory_write</a>(gpu_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*temp_buffer.size(), &amp;(temp_buffer[0]));
<a name="l01489"></a>01489       }
<a name="l01490"></a>01490     }
<a name="l01491"></a>01491   }
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 
<a name="l01499"></a>01499   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CPUVECTOR, <span class="keyword">typename</span> NumericT&gt;
<a name="l01500"></a><a class="code" href="namespaceviennacl.html#a19621895b23c45e932e4ce15d947b311">01500</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy</a>(<span class="keyword">const</span> CPUVECTOR &amp; cpu_vec, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; gpu_vec)
<a name="l01501"></a>01501   {
<a name="l01502"></a>01502     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(cpu_vec.begin(), cpu_vec.end(), gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>());
<a name="l01503"></a>01503   }
<a name="l01504"></a>01504   
<a name="l01505"></a>01505   <span class="comment">//from cpu to gpu. Safe assumption: cpu_vector does not necessarily occupy a linear memory segment, but is not larger than the allocated memory on the GPU</span>
<a name="l01512"></a>01512 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01513"></a><a class="code" href="namespaceviennacl.html#ae90a3bfb2d1d49bb356c8f2179a685b0">01513</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_begin,
<a name="l01514"></a>01514             CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_end,
<a name="l01515"></a>01515             <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> gpu_begin)
<a name="l01516"></a>01516   {
<a name="l01517"></a>01517     assert(cpu_end - cpu_begin &gt; 0 &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Iterators incompatible&quot;</span>));
<a name="l01518"></a>01518     <span class="keywordflow">if</span> (cpu_begin != cpu_end)
<a name="l01519"></a>01519     {
<a name="l01520"></a>01520       <span class="comment">//we require that the size of the gpu_vector is larger or equal to the cpu-size</span>
<a name="l01521"></a>01521       std::vector&lt;SCALARTYPE&gt; temp_buffer(cpu_end - cpu_begin);
<a name="l01522"></a>01522       <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">std::copy</a>(cpu_begin, cpu_end, temp_buffer.begin());
<a name="l01523"></a>01523       <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(temp_buffer.begin(), temp_buffer.end(), gpu_begin);
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525   }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527   <span class="comment">// for things like copy(std_vec.begin(), std_vec.end(), vcl_vec.begin() + 1);</span>
<a name="l01528"></a>01528 
<a name="l01534"></a>01534   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CPUVECTOR, <span class="keyword">typename</span> T&gt;
<a name="l01535"></a><a class="code" href="namespaceviennacl.html#aa38a64c6f9e5764df676c05e5aec3ff8">01535</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> CPUVECTOR &amp; cpu_vec, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; gpu_vec)
<a name="l01536"></a>01536   {
<a name="l01537"></a>01537     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(cpu_vec.begin(), cpu_vec.end(), gpu_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>());
<a name="l01538"></a>01538   }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 <span class="preprocessor">  #ifdef VIENNACL_WITH_EIGEN</span>
<a name="l01542"></a>01542 <span class="preprocessor"></span>  <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01543"></a>01543   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(Eigen::VectorXf <span class="keyword">const</span> &amp; eigen_vec,
<a name="l01544"></a>01544             vector&lt;float, ALIGNMENT&gt; &amp; gpu_vec)
<a name="l01545"></a>01545   {
<a name="l01546"></a>01546     std::vector&lt;float&gt; entries(eigen_vec.size());
<a name="l01547"></a>01547     <span class="keywordflow">for</span> (std::size_t i = 0; i&lt;entries.size(); ++i)
<a name="l01548"></a>01548       entries[i] = eigen_vec(i);
<a name="l01549"></a>01549     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(entries.begin(), entries.end(), gpu_vec.begin());
<a name="l01550"></a>01550   }
<a name="l01551"></a>01551   
<a name="l01552"></a>01552   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01553"></a>01553   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(Eigen::VectorXd <span class="keyword">const</span> &amp; eigen_vec,
<a name="l01554"></a>01554             vector&lt;double, ALIGNMENT&gt; &amp; gpu_vec)
<a name="l01555"></a>01555   {
<a name="l01556"></a>01556     std::vector&lt;double&gt; entries(eigen_vec.size());
<a name="l01557"></a>01557     <span class="keywordflow">for</span> (std::size_t i = 0; i&lt;entries.size(); ++i)
<a name="l01558"></a>01558       entries[i] = eigen_vec(i);
<a name="l01559"></a>01559     <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(entries.begin(), entries.end(), gpu_vec.begin());
<a name="l01560"></a>01560   }
<a name="l01561"></a>01561 <span class="preprocessor">  #endif</span>
<a name="l01562"></a>01562 <span class="preprocessor"></span>  
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   <span class="comment">//</span>
<a name="l01567"></a>01567 <span class="comment"></span>  <span class="comment">//</span>
<a name="l01574"></a>01574 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01575"></a><a class="code" href="namespaceviennacl.html#a0d783c95a46bcb7d01000ae479a03cfc">01575</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_begin,
<a name="l01576"></a>01576             <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_end,
<a name="l01577"></a>01577             <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> gpu_dest_begin)
<a name="l01578"></a>01578   {
<a name="l01579"></a>01579     assert(gpu_src_end - gpu_src_begin &gt;= 0);
<a name="l01580"></a>01580     assert(gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() == 1 &amp;&amp; bool(<span class="stringliteral">&quot;ViennaCL ERROR: copy() for GPU-&gt;GPU not implemented for slices! Use operator= instead for the moment.&quot;</span>));
<a name="l01581"></a>01581 
<a name="l01582"></a>01582     <span class="keywordflow">if</span> (gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() == 1 &amp;&amp; gpu_dest_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#ab4cecc3216a2369e8d0980f33303e988" title="Index increment in the underlying buffer when incrementing the iterator to the next element...">stride</a>() == 1)
<a name="l01583"></a>01583     {
<a name="l01584"></a>01584       <span class="keywordflow">if</span> (gpu_src_begin != gpu_src_end)
<a name="l01585"></a>01585         <a class="code" href="namespaceviennacl_1_1backend_1_1cpu__ram.html#a6835086e6b7f32c05a181167d5ace354" title="Copies &#39;bytes_to_copy&#39; bytes from address &#39;src_buffer + src_offset&#39; to memory starting at address &#39;ds...">viennacl::backend::memory_copy</a>(gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a82f9d6c89ae9a767448d32726520d77f">handle</a>(), gpu_dest_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#aa1b198b314716d29e7aa65e6b6b71af9">handle</a>(),
<a name="l01586"></a>01586                                         <span class="keyword">sizeof</span>(SCALARTYPE) * gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(),
<a name="l01587"></a>01587                                         <span class="keyword">sizeof</span>(SCALARTYPE) * gpu_dest_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>(),
<a name="l01588"></a>01588                                         <span class="keyword">sizeof</span>(SCALARTYPE) * (gpu_src_end.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>() - gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a00b50cd5f079fc83da8f148edd6dc3ad" title="Offset of the current element index with respect to the beginning of the buffer.">offset</a>()));
<a name="l01589"></a>01589     }
<a name="l01590"></a>01590     <span class="keywordflow">else</span>
<a name="l01591"></a>01591     {
<a name="l01592"></a>01592       assert( <span class="keyword">false</span> &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;not implemented yet&quot;</span>));
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594   }
<a name="l01595"></a>01595 
<a name="l01602"></a>01602   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01603"></a><a class="code" href="namespaceviennacl.html#a932444aaf1651567029ef1618f883d1b">01603</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_begin,
<a name="l01604"></a>01604             <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_end,
<a name="l01605"></a>01605             <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> gpu_dest_begin)
<a name="l01606"></a>01606   {
<a name="l01607"></a>01607     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(<span class="keyword">static_cast&lt;</span><a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">&gt;</span>(gpu_src_begin),
<a name="l01608"></a>01608                     <span class="keyword">static_cast&lt;</span><a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">&gt;</span>(gpu_src_end),
<a name="l01609"></a>01609                     gpu_dest_begin);
<a name="l01610"></a>01610   }
<a name="l01611"></a>01611 
<a name="l01617"></a>01617   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01618"></a><a class="code" href="namespaceviennacl.html#aa5623507e69891c07a96a2036105cf35">01618</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_vec,
<a name="l01619"></a>01619             <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> &amp; gpu_dest_vec )
<a name="l01620"></a>01620   {
<a name="l01621"></a>01621     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(gpu_src_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), gpu_src_vec.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), gpu_dest_vec.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>());
<a name="l01622"></a>01622   } 
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 
<a name="l01625"></a>01625   
<a name="l01626"></a>01626   
<a name="l01627"></a>01627   
<a name="l01628"></a>01628 
<a name="l01629"></a>01629   <span class="comment">//global functions for handling vectors:</span>
<a name="l01634"></a>01634 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01635"></a><a class="code" href="namespaceviennacl.html#a64c137c6e59e2a4791600a06447b3ef1">01635</a>   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, vector_base&lt;T&gt; <span class="keyword">const</span> &amp; val)
<a name="l01636"></a>01636   {
<a name="l01637"></a>01637     std::vector&lt;T&gt; tmp(val.size());
<a name="l01638"></a>01638     <a class="code" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(val.begin(), val.end(), tmp.begin());
<a name="l01639"></a>01639     std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; val.size() &lt;&lt; <span class="stringliteral">&quot;](&quot;</span>;
<a name="l01640"></a>01640     <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;T&gt;::size_type i=0; i&lt;val.size(); ++i)
<a name="l01641"></a>01641     {
<a name="l01642"></a>01642       <span class="keywordflow">if</span> (i &gt; 0)
<a name="l01643"></a>01643         s &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;
<a name="l01644"></a>01644       s &lt;&lt; tmp[i];
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646     std::cout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l01647"></a>01647     <span class="keywordflow">return</span> s;
<a name="l01648"></a>01648   }
<a name="l01649"></a>01649 
<a name="l01650"></a>01650   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01651"></a><a class="code" href="namespaceviennacl.html#a70af3a8f39277af306bf3fa8cbfa13d9">01651</a>   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, vector_expression&lt;LHS, RHS, OP&gt; <span class="keyword">const</span> &amp; proxy)
<a name="l01652"></a>01652   {
<a name="l01653"></a>01653     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cpu__value__type.html#af2881e25afe8aad2d19886ce9bb1b0ea">viennacl::result_of::cpu_value_type&lt;typename LHS::value_type&gt;::type</a> ScalarType;
<a name="l01654"></a>01654     <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> result = proxy;
<a name="l01655"></a>01655     s &lt;&lt; result;
<a name="l01656"></a>01656     <span class="keywordflow">return</span> s;
<a name="l01657"></a>01657   }
<a name="l01658"></a>01658   
<a name="l01664"></a>01664   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01665"></a><a class="code" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">01665</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375" title="Swaps the contents of two vectors, data is copied.">swap</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec2)
<a name="l01666"></a>01666   {
<a name="l01667"></a>01667     <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a945a556a198a68294132d32df96b78a6" title="Swaps the contents of two vectors, data is copied.">viennacl::linalg::vector_swap</a>(vec1, vec2);
<a name="l01668"></a>01668   }
<a name="l01669"></a>01669   
<a name="l01675"></a>01675   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01676"></a><a class="code" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d">01676</a>   <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d" title="Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.">fast_swap</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; v1,
<a name="l01677"></a>01677                                             <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; v2) 
<a name="l01678"></a>01678   { 
<a name="l01679"></a>01679     <span class="keywordflow">return</span> v1.<a class="code" href="classviennacl_1_1vector.html#a7d9d5c3cb020f5f2f5f160d624f387a0" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">fast_swap</a>(v2);
<a name="l01680"></a>01680   }       
<a name="l01681"></a>01681   
<a name="l01682"></a>01682   
<a name="l01683"></a>01683   
<a name="l01684"></a>01684   
<a name="l01685"></a>01685   
<a name="l01686"></a>01686   <span class="comment">//</span>
<a name="l01687"></a>01687   <span class="comment">//</span>
<a name="l01689"></a>01689 <span class="comment"></span>  <span class="comment">//</span>
<a name="l01690"></a>01690   <span class="comment">//</span>
<a name="l01691"></a>01691   
<a name="l01692"></a>01692   <span class="comment">//</span>
<a name="l01693"></a>01693   <span class="comment">// operator +=</span>
<a name="l01694"></a>01694   <span class="comment">//</span>
<a name="l01695"></a>01695   
<a name="l01696"></a>01696                                               
<a name="l01699"></a>01699   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01700"></a><a class="code" href="namespaceviennacl.html#a7facf74608270e673b7b6fbc189a18e8">01700</a>   <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v2)
<a name="l01701"></a>01701   {
<a name="l01702"></a>01702     
<a name="l01703"></a>01703     assert(v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == v2.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01706"></a>01706       <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(v1, 
<a name="l01707"></a>01707                              v1, T(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01708"></a>01708                              v2, T(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01709"></a>01709     <span class="keywordflow">return</span> v1;
<a name="l01710"></a>01710   }
<a name="l01711"></a>01711   
<a name="l01714"></a>01714   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01715"></a>01715   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01716"></a>01716                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01717"></a><a class="code" href="namespaceviennacl.html#a1c2d2bc3e344790b342a15bfad0a1463">01717</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01718"></a>01718                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy)
<a name="l01719"></a>01719   {
<a name="l01720"></a>01720     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01721"></a>01721 
<a name="l01722"></a>01722     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01723"></a>01723       <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(v1, 
<a name="l01724"></a>01724                               v1,               T(1.0), 1, <span class="keyword">false</span>,                                             <span class="keyword">false</span>,
<a name="l01725"></a>01725                               proxy.lhs(), proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01726"></a>01726     <span class="keywordflow">return</span> v1;
<a name="l01727"></a>01727   }
<a name="l01728"></a>01728 
<a name="l01729"></a>01729   
<a name="l01735"></a>01735   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l01736"></a>01736   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; (viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01737"></a>01737                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01738"></a><a class="code" href="namespaceviennacl.html#ac6030ee2584f89d654404b4e06688786">01738</a>   <span class="keyword">operator</span> += (<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01739"></a>01739                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, OP&gt; &amp; proxy)
<a name="l01740"></a>01740   {
<a name="l01741"></a>01741     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01744"></a>01744       <a class="code" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01745"></a>01745                                 proxy.lhs(), T(1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01746"></a>01746                                 proxy.rhs(), T(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01747"></a>01747     <span class="keywordflow">return</span> v1;
<a name="l01748"></a>01748   }
<a name="l01749"></a>01749   
<a name="l01755"></a>01755   <span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, 
<a name="l01756"></a>01756              <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01757"></a>01757              <span class="keyword">typename</span> OP&gt;
<a name="l01758"></a>01758   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01759"></a>01759                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01760"></a>01760                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01761"></a><a class="code" href="namespaceviennacl.html#a8d5d87e8494e2bfbae9eb703cb189ede">01761</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1,
<a name="l01762"></a>01762                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l01763"></a>01763                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01764"></a>01764                                         OP&gt; &amp; proxy)
<a name="l01765"></a>01765   {
<a name="l01766"></a>01766     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01767"></a>01767 
<a name="l01768"></a>01768     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01769"></a>01769     {
<a name="l01770"></a>01770       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l01771"></a>01771       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01772"></a>01772         flip_sign_3 = !flip_sign_3;
<a name="l01773"></a>01773       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a6be7da5d1ee87dff9d82ac4a3c5cb2ce">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01774"></a>01774                                 proxy.lhs(),                  T(1.0), 1, false                                             , <span class="keyword">false</span>,
<a name="l01775"></a>01775                                 proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777     <span class="keywordflow">return</span> v1;
<a name="l01778"></a>01778   }
<a name="l01779"></a>01779 
<a name="l01785"></a>01785   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01786"></a>01786             <span class="keyword">typename</span> OP&gt;
<a name="l01787"></a>01787   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01788"></a>01788                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01789"></a>01789                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01790"></a><a class="code" href="namespaceviennacl.html#a36070c447cb85a93a1f240237d391376">01790</a>   <a class="code" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b" title="Implementation of the operation v1 += A * v2, where A is a matrix.">operator += </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1,
<a name="l01791"></a>01791                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01792"></a>01792                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l01793"></a>01793                                         OP&gt; &amp; proxy)
<a name="l01794"></a>01794   {
<a name="l01795"></a>01795     assert(proxy.size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01796"></a>01796 
<a name="l01797"></a>01797     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01798"></a>01798       <a class="code" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01799"></a>01799                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l01800"></a>01800                                 proxy.rhs(),                  T(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>) );
<a name="l01801"></a>01801     <span class="keywordflow">return</span> v1;
<a name="l01802"></a>01802   }
<a name="l01803"></a>01803   
<a name="l01809"></a>01809   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, 
<a name="l01810"></a>01810             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01811"></a>01811             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01812"></a>01812             <span class="keyword">typename</span> OP&gt;
<a name="l01813"></a>01813   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01814"></a>01814                                 &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01815"></a>01815                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01816"></a>01816                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01817"></a><a class="code" href="namespaceviennacl.html#aeb202a12ab57dcaa684ff2d5042142f3">01817</a>   <span class="keyword">operator</span> += (<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1,
<a name="l01818"></a>01818                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01819"></a>01819                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01820"></a>01820                                         OP&gt; &amp; proxy)
<a name="l01821"></a>01821   {
<a name="l01822"></a>01822     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01823"></a>01823 
<a name="l01824"></a>01824     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01825"></a>01825     {
<a name="l01826"></a>01826       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l01827"></a>01827       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01828"></a>01828         flip_sign_3 = !flip_sign_3;
<a name="l01829"></a>01829       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a6be7da5d1ee87dff9d82ac4a3c5cb2ce">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01830"></a>01830                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>),
<a name="l01831"></a>01831                                 proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3 );
<a name="l01832"></a>01832     }
<a name="l01833"></a>01833     <span class="keywordflow">return</span> v1;
<a name="l01834"></a>01834   }
<a name="l01835"></a>01835   
<a name="l01836"></a>01836   
<a name="l01837"></a>01837   <span class="comment">//</span>
<a name="l01838"></a>01838   <span class="comment">// operator -=</span>
<a name="l01839"></a>01839   <span class="comment">//</span>
<a name="l01840"></a>01840   
<a name="l01842"></a>01842   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01843"></a><a class="code" href="namespaceviennacl.html#a8c70e45d9ff63187aba756147937ae7d">01843</a>   <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec)
<a name="l01844"></a>01844   {
<a name="l01845"></a>01845     assert(vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01848"></a>01848       <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(v1, 
<a name="l01849"></a>01849                              v1,  T( 1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>,
<a name="l01850"></a>01850                              vec, T(-1.0), 1, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01851"></a>01851     <span class="keywordflow">return</span> v1;
<a name="l01852"></a>01852   }
<a name="l01853"></a>01853 
<a name="l01854"></a>01854   
<a name="l01857"></a>01857   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP&gt;
<a name="l01858"></a>01858   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l01859"></a>01859                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01860"></a><a class="code" href="namespaceviennacl.html#a58e7f611b043ca30e4ed1e787ab465a8">01860</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01861"></a>01861                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP&gt; &amp; proxy)
<a name="l01862"></a>01862   {
<a name="l01863"></a>01863     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01864"></a>01864 
<a name="l01865"></a>01865     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01866"></a>01866       <a class="code" href="namespaceviennacl_1_1linalg.html#a9283e9543bbe348eb00d7c16b678ecad">viennacl::linalg::avbv</a>(v1, 
<a name="l01867"></a>01867                              v1,               T(1.0), 1, <span class="keyword">false</span>,                                             <span class="keyword">false</span>,
<a name="l01868"></a>01868                              proxy.lhs(), proxy.rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>));
<a name="l01869"></a>01869     <span class="keywordflow">return</span> v1;
<a name="l01870"></a>01870   }
<a name="l01871"></a>01871   
<a name="l01877"></a>01877   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l01878"></a>01878   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; (viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01879"></a>01879                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01880"></a><a class="code" href="namespaceviennacl.html#ac5e929bc4d126d468c26b53c12847c8c">01880</a>   <span class="keyword">operator</span> -= (<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01881"></a>01881                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, OP&gt; &amp; proxy)
<a name="l01882"></a>01882   {
<a name="l01883"></a>01883     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01884"></a>01884 
<a name="l01885"></a>01885     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01886"></a>01886       <a class="code" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01887"></a>01887                                proxy.lhs(), T(1.0), 1, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l01888"></a>01888                                proxy.rhs(), T(1.0), 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>) );
<a name="l01889"></a>01889     <span class="keywordflow">return</span> v1;
<a name="l01890"></a>01890   }
<a name="l01891"></a>01891   
<a name="l01897"></a>01897   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l01898"></a>01898             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01899"></a>01899             <span class="keyword">typename</span> OP&gt;
<a name="l01900"></a>01900   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01901"></a>01901                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01902"></a>01902                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01903"></a><a class="code" href="namespaceviennacl.html#a38c5f7890a2ec83b5c97013d18c39c04">01903</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01904"></a>01904                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l01905"></a>01905                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01906"></a>01906                                         OP&gt; &amp; proxy)
<a name="l01907"></a>01907   {
<a name="l01908"></a>01908     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01909"></a>01909 
<a name="l01910"></a>01910     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01911"></a>01911     {
<a name="l01912"></a>01912       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>);
<a name="l01913"></a>01913       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01914"></a>01914         flip_sign_3 = !flip_sign_3;
<a name="l01915"></a>01915       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a6be7da5d1ee87dff9d82ac4a3c5cb2ce">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01916"></a>01916                                 proxy.lhs(),                  T(1.0), 1, false                                             , <span class="keyword">true</span>,
<a name="l01917"></a>01917                                 proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3);
<a name="l01918"></a>01918     }
<a name="l01919"></a>01919     <span class="keywordflow">return</span> v1;
<a name="l01920"></a>01920   }
<a name="l01921"></a>01921 
<a name="l01927"></a>01927   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01928"></a>01928             <span class="keyword">typename</span> OP&gt;
<a name="l01929"></a>01929   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01930"></a>01930                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01931"></a>01931                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01932"></a><a class="code" href="namespaceviennacl.html#aa41f60503f12c10a966dd8301605165e">01932</a>   <a class="code" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138" title="Implementation of the operation v1 -= A * v2, where A is a matrix.">operator -= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01933"></a>01933                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01934"></a>01934                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l01935"></a>01935                                         OP&gt; &amp; proxy)
<a name="l01936"></a>01936   {
<a name="l01937"></a>01937     assert(proxy.size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01938"></a>01938 
<a name="l01939"></a>01939     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01940"></a>01940       <a class="code" href="namespaceviennacl_1_1linalg.html#aaeda7928989157a211111dfbfcb35793">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01941"></a>01941                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>),
<a name="l01942"></a>01942                                 proxy.rhs(),                  T(1.0), 1, false                                             , (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>) );
<a name="l01943"></a>01943     <span class="keywordflow">return</span> v1;
<a name="l01944"></a>01944   }
<a name="l01945"></a>01945   
<a name="l01951"></a>01951   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l01952"></a>01952             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2,
<a name="l01953"></a>01953             <span class="keyword">typename</span> S3, <span class="keyword">typename</span> OP3,
<a name="l01954"></a>01954             <span class="keyword">typename</span> OP&gt;
<a name="l01955"></a>01955   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S2&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP2&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a>)
<a name="l01956"></a>01956                                 &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S3&gt;::value</a> &amp;&amp; (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP3&gt;::value</a> || <a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a>)
<a name="l01957"></a>01957                                 &amp;&amp; (<a class="code" href="structviennacl_1_1is__addition.html" title="Helper metafunction for checking whether the provided type is viennacl::op_add (for addition)...">viennacl::is_addition&lt;OP&gt;::value</a> || <a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a>),
<a name="l01958"></a>01958                                 vector_base&lt;T&gt; &amp;&gt;::type
<a name="l01959"></a><a class="code" href="namespaceviennacl.html#ad0b6510c15b44f5b82032a1f85e018ae">01959</a>   <span class="keyword">operator</span> -= (<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l01960"></a>01960                <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l01961"></a>01961                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S3, OP3&gt;,
<a name="l01962"></a>01962                                         OP&gt; &amp; proxy)
<a name="l01963"></a>01963   {
<a name="l01964"></a>01964     assert(proxy.lhs().size() == v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l01965"></a>01965 
<a name="l01966"></a>01966     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01967"></a>01967     {
<a name="l01968"></a>01968       <span class="keywordtype">bool</span> flip_sign_3 = (<a class="code" href="structviennacl_1_1is__subtraction.html" title="Helper metafunction for checking whether the provided type is viennacl::op_sub (for subtraction)...">viennacl::is_subtraction&lt;OP&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>);
<a name="l01969"></a>01969       <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S3&gt;::value</a>)
<a name="l01970"></a>01970         flip_sign_3 = !flip_sign_3;
<a name="l01971"></a>01971       <a class="code" href="namespaceviennacl_1_1linalg_1_1cuda.html#a6be7da5d1ee87dff9d82ac4a3c5cb2ce">viennacl::linalg::avbv_v</a>(v1, 
<a name="l01972"></a>01972                                 proxy.lhs().lhs(), proxy.lhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP2&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S2&gt;::value</a> ? <span class="keyword">false</span> : <span class="keyword">true</span>),
<a name="l01973"></a>01973                                 proxy.rhs().lhs(), proxy.rhs().rhs(), 1, (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP3&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>), flip_sign_3);
<a name="l01974"></a>01974     }
<a name="l01975"></a>01975     <span class="keywordflow">return</span> v1;
<a name="l01976"></a>01976   }
<a name="l01977"></a>01977   
<a name="l01978"></a>01978   
<a name="l01979"></a>01979   <span class="comment">//</span>
<a name="l01980"></a>01980   <span class="comment">// operator *=</span>
<a name="l01981"></a>01981   <span class="comment">//</span>
<a name="l01982"></a>01982 
<a name="l01985"></a>01985   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1&gt;
<a name="l01986"></a>01986   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l01987"></a>01987                                 vector_base&lt;T&gt; &amp; 
<a name="l01988"></a>01988                               &gt;::type
<a name="l01989"></a><a class="code" href="namespaceviennacl.html#a447eda4887f7373cd9214f7f452aa8ca">01989</a>   <a class="code" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4" title="Scales a matrix by a GPU scalar value.">operator *= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, S1 <span class="keyword">const</span> &amp; gpu_val)
<a name="l01990"></a>01990   {
<a name="l01991"></a>01991     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l01992"></a>01992       <a class="code" href="namespaceviennacl_1_1linalg.html#a5abc76193a54abea357ec6503ffaadcb">viennacl::linalg::av</a>(v1,
<a name="l01993"></a>01993                            v1, gpu_val, 1, <span class="keyword">false</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l01994"></a>01994     <span class="keywordflow">return</span> v1;
<a name="l01995"></a>01995   }
<a name="l01996"></a>01996 
<a name="l01997"></a>01997   
<a name="l01998"></a>01998   <span class="comment">//</span>
<a name="l01999"></a>01999   <span class="comment">// operator /=</span>
<a name="l02000"></a>02000   <span class="comment">//</span>
<a name="l02001"></a>02001     
<a name="l02002"></a>02002 
<a name="l02005"></a>02005   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1&gt;
<a name="l02006"></a>02006   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02007"></a>02007                                 vector_base&lt;T&gt; &amp; 
<a name="l02008"></a>02008                               &gt;::type
<a name="l02009"></a><a class="code" href="namespaceviennacl.html#a5911b2abc96a555d3c20855f645441ac">02009</a>   <a class="code" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453" title="Scales a matrix by a GPU scalar value.">operator /= </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, S1 <span class="keyword">const</span> &amp; gpu_val)
<a name="l02010"></a>02010   {
<a name="l02011"></a>02011     <span class="keywordflow">if</span> (v1.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &gt; 0)
<a name="l02012"></a>02012       <a class="code" href="namespaceviennacl_1_1linalg.html#a5abc76193a54abea357ec6503ffaadcb">viennacl::linalg::av</a>(v1,
<a name="l02013"></a>02013                            v1, gpu_val, 1, <span class="keyword">true</span>, (<a class="code" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt;S1&gt;::value</a> ? <span class="keyword">true</span> : <span class="keyword">false</span>));
<a name="l02014"></a>02014     <span class="keywordflow">return</span> v1;
<a name="l02015"></a>02015   }
<a name="l02016"></a>02016   
<a name="l02017"></a>02017   
<a name="l02018"></a>02018   <span class="comment">//</span>
<a name="l02019"></a>02019   <span class="comment">// operator +</span>
<a name="l02020"></a>02020   <span class="comment">//</span>
<a name="l02021"></a>02021   
<a name="l02022"></a>02022   <span class="comment">//addition and subtraction of two vector_expressions:</span>
<a name="l02028"></a>02028 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l02029"></a>02029             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l02030"></a>02030   <span class="keyword">typename</span> vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType
<a name="l02031"></a><a class="code" href="namespaceviennacl.html#a5e9bf6c5c16a42f495bfd3d7dd17257c">02031</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l02032"></a>02032               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l02033"></a>02033   {
<a name="l02034"></a>02034     assert(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == proxy2.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02035"></a>02035     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067" title="Extracts the vector type from the two operands.">vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType</a> result = proxy1;
<a name="l02036"></a>02036     result += proxy2;
<a name="l02037"></a>02037     <span class="keywordflow">return</span> result;
<a name="l02038"></a>02038   }
<a name="l02039"></a>02039   
<a name="l02040"></a>02040   
<a name="l02046"></a>02046   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> T&gt;
<a name="l02047"></a>02047   <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a>
<a name="l02048"></a><a class="code" href="namespaceviennacl.html#a95221367a0d8f92d0381b6d2187aae05">02048</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l02049"></a>02049               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l02050"></a>02050   {
<a name="l02051"></a>02051     assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02052"></a>02052     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> result = proxy;
<a name="l02053"></a>02053     result += vec;
<a name="l02054"></a>02054     <span class="keywordflow">return</span> result;
<a name="l02055"></a>02055   }
<a name="l02056"></a>02056 
<a name="l02062"></a>02062   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l02063"></a>02063   <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a>
<a name="l02064"></a><a class="code" href="namespaceviennacl.html#ab76a8502af69ef1290f7ceffb9793d00">02064</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l02065"></a>02065               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l02066"></a>02066   {
<a name="l02067"></a>02067     assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02068"></a>02068     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> result = vec;
<a name="l02069"></a>02069     result += proxy;
<a name="l02070"></a>02070     <span class="keywordflow">return</span> result;
<a name="l02071"></a>02071   }
<a name="l02072"></a>02072 
<a name="l02073"></a>02073   
<a name="l02079"></a>02079   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1&gt;
<a name="l02080"></a>02080   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02081"></a>02081                                 vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02082"></a>02082                                                   <span class="keyword">const</span> vector_base&lt;T&gt;,
<a name="l02083"></a>02083                                                   op_add&gt;
<a name="l02084"></a>02084                               &gt;::type
<a name="l02085"></a><a class="code" href="namespaceviennacl.html#a481ef4ef8c1ac31dd4e217fd6b96ce30">02085</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; proxy,
<a name="l02086"></a>02086               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l02087"></a>02087   {
<a name="l02088"></a>02088     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02089"></a>02089                              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l02090"></a>02090                              op_add&gt;(proxy, vec);
<a name="l02091"></a>02091   }
<a name="l02092"></a>02092   
<a name="l02098"></a>02098   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l02099"></a>02099             <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l02100"></a>02100             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l02101"></a>02101   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l02102"></a>02102                                 vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02103"></a>02103                                                   <span class="keyword">const</span> vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02104"></a>02104                                                   op_add&gt;
<a name="l02105"></a>02105                               &gt;::type
<a name="l02106"></a><a class="code" href="namespaceviennacl.html#ac336464bc60f71306e3744a48b09f783">02106</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; lhs,
<a name="l02107"></a>02107               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt; <span class="keyword">const</span> &amp; rhs)
<a name="l02108"></a>02108   {
<a name="l02109"></a>02109     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02110"></a>02110                              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02111"></a>02111                              op_add&gt;(lhs, rhs);
<a name="l02112"></a>02112   }
<a name="l02113"></a>02113   
<a name="l02114"></a>02114   
<a name="l02117"></a>02117   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l02118"></a>02118   vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> vector_base&lt;T&gt;, op_add&gt;      
<a name="l02119"></a><a class="code" href="namespaceviennacl.html#a2471d058da27c2588866407382060cc0">02119</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v2)
<a name="l02120"></a>02120   {
<a name="l02121"></a>02121     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, op_add&gt;(v1, v2);
<a name="l02122"></a>02122   }
<a name="l02123"></a>02123   
<a name="l02126"></a>02126   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l02127"></a>02127   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l02128"></a>02128                                 vector_expression&lt; const vector_base&lt;T&gt;,
<a name="l02129"></a>02129                                                     <span class="keyword">const</span> vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02130"></a>02130                                                     op_add&gt;      
<a name="l02131"></a>02131                               &gt;::type
<a name="l02132"></a><a class="code" href="namespaceviennacl.html#a331fa4a57740ba8a084343f667271248">02132</a>   <a class="code" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf" title="Implementation of the operation &#39;result = v1 + A * v2&#39;, where A is a matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l02133"></a>02133             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l02134"></a>02134                                      <span class="keyword">const</span> S2,
<a name="l02135"></a>02135                                      OP2&gt; &amp; proxy)
<a name="l02136"></a>02136   {
<a name="l02137"></a>02137     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>,
<a name="l02138"></a>02138                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02139"></a>02139                               op_add&gt;(v1, proxy);
<a name="l02140"></a>02140   }
<a name="l02141"></a>02141 
<a name="l02142"></a>02142 
<a name="l02143"></a>02143   
<a name="l02144"></a>02144   
<a name="l02145"></a>02145   <span class="comment">//</span>
<a name="l02146"></a>02146   <span class="comment">// operator -</span>
<a name="l02147"></a>02147   <span class="comment">//</span>
<a name="l02148"></a>02148   
<a name="l02154"></a>02154   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l02155"></a>02155             <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l02156"></a>02156   <span class="keyword">typename</span> vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType
<a name="l02157"></a><a class="code" href="namespaceviennacl.html#a7a1e1894edebb7f8b0207bec32bfda6b">02157</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l02158"></a>02158               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l02159"></a>02159   {
<a name="l02160"></a>02160     assert(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == proxy2.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02161"></a>02161     <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067" title="Extracts the vector type from the two operands.">vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType</a> result = proxy1;
<a name="l02162"></a>02162     result -= proxy2;
<a name="l02163"></a>02163     <span class="keywordflow">return</span> result;
<a name="l02164"></a>02164   }
<a name="l02165"></a>02165   
<a name="l02166"></a>02166   
<a name="l02172"></a>02172   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> T&gt;
<a name="l02173"></a>02173   <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a>
<a name="l02174"></a><a class="code" href="namespaceviennacl.html#a303edd7fc2f89bf156aaa1b8ff40ecae">02174</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l02175"></a>02175               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l02176"></a>02176   {
<a name="l02177"></a>02177     assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02178"></a>02178     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> result = proxy;
<a name="l02179"></a>02179     result -= vec;
<a name="l02180"></a>02180     <span class="keywordflow">return</span> result;
<a name="l02181"></a>02181   }
<a name="l02182"></a>02182 
<a name="l02188"></a>02188   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l02189"></a>02189   <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a>
<a name="l02190"></a><a class="code" href="namespaceviennacl.html#afd93f9d8286afbab1334c082413bfab6">02190</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l02191"></a>02191               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l02192"></a>02192   {
<a name="l02193"></a>02193     assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Incompatible vector sizes!&quot;</span>));
<a name="l02194"></a>02194     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> result = vec;
<a name="l02195"></a>02195     result -= proxy;
<a name="l02196"></a>02196     <span class="keywordflow">return</span> result;
<a name="l02197"></a>02197   }
<a name="l02198"></a>02198   
<a name="l02204"></a>02204   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1&gt;
<a name="l02205"></a>02205   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02206"></a>02206                                 vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02207"></a>02207                                                   <span class="keyword">const</span> vector_base&lt;T&gt;,
<a name="l02208"></a>02208                                                   op_sub&gt;
<a name="l02209"></a>02209                               &gt;::type
<a name="l02210"></a><a class="code" href="namespaceviennacl.html#ae938fcfd01a03e806c8aac20c0792fd6">02210</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; proxy,
<a name="l02211"></a>02211               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l02212"></a>02212   {
<a name="l02213"></a>02213     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02214"></a>02214                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l02215"></a>02215                               op_sub&gt;(proxy, vec);
<a name="l02216"></a>02216   }
<a name="l02217"></a>02217   
<a name="l02223"></a>02223   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,
<a name="l02224"></a>02224             <span class="keyword">typename</span> S1, <span class="keyword">typename</span> OP1,
<a name="l02225"></a>02225             <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l02226"></a>02226   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt;    viennacl::is_any_scalar&lt;S1&gt;::value</a>
<a name="l02227"></a>02227                                 &amp;&amp; <a class="code" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l02228"></a>02228                                 vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02229"></a>02229                                                   <span class="keyword">const</span> vector_expression&lt;const vector_base&lt;T&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02230"></a>02230                                                   op_sub&gt;
<a name="l02231"></a>02231                               &gt;::type
<a name="l02232"></a><a class="code" href="namespaceviennacl.html#a9bf7a39a41216e00fc8ca21ebc4b4aed">02232</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt; <span class="keyword">const</span> &amp; lhs,
<a name="l02233"></a>02233               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt; <span class="keyword">const</span> &amp; rhs)
<a name="l02234"></a>02234   {
<a name="l02235"></a>02235     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, OP1&gt;,
<a name="l02236"></a>02236                              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02237"></a>02237                              op_sub&gt;(lhs, rhs);
<a name="l02238"></a>02238   }
<a name="l02239"></a>02239 
<a name="l02242"></a>02242   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l02243"></a>02243   vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> vector_base&lt;T&gt;, op_sub&gt;      
<a name="l02244"></a><a class="code" href="namespaceviennacl.html#ab2a0eb807884794e795aec5ec78353a4">02244</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v2)
<a name="l02245"></a>02245   {
<a name="l02246"></a>02246     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, op_sub&gt;(v1, v2);
<a name="l02247"></a>02247   }
<a name="l02248"></a>02248 
<a name="l02249"></a>02249 
<a name="l02252"></a>02252   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S2, <span class="keyword">typename</span> OP2&gt;
<a name="l02253"></a>02253   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S2&gt;::value</a>,
<a name="l02254"></a>02254                                 vector_expression&lt; const vector_base&lt;T&gt;,
<a name="l02255"></a>02255                                                    <span class="keyword">const</span> vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02256"></a>02256                                                    op_sub&gt;      
<a name="l02257"></a>02257                               &gt;::type
<a name="l02258"></a><a class="code" href="namespaceviennacl.html#a4a1dab1b036689602adfaaa4b3d34c38">02258</a>   <a class="code" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f" title="Implementation of the operation &#39;result = v1 - A * v2&#39;, where A is a matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; v1, 
<a name="l02259"></a>02259             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>,
<a name="l02260"></a>02260                                      <span class="keyword">const</span> S2,
<a name="l02261"></a>02261                                      OP2&gt; &amp; proxy)
<a name="l02262"></a>02262   {
<a name="l02263"></a>02263     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>,
<a name="l02264"></a>02264                               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S2, OP2&gt;,
<a name="l02265"></a>02265                               op_sub&gt;(v1, proxy);
<a name="l02266"></a>02266   }
<a name="l02267"></a>02267 
<a name="l02268"></a>02268   
<a name="l02269"></a>02269   <span class="comment">//</span>
<a name="l02270"></a>02270   <span class="comment">// operator *</span>
<a name="l02271"></a>02271   <span class="comment">//</span>
<a name="l02272"></a>02272   
<a name="l02273"></a>02273   
<a name="l02279"></a>02279   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> T&gt;
<a name="l02280"></a>02280   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02281"></a>02281                                 vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, op_prod&gt; &gt;::type 
<a name="l02282"></a><a class="code" href="namespaceviennacl.html#a6d8d71789df177be4cedacd7917848c8">02282</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(S1 <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1value.html">value</a>, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l02283"></a>02283   {
<a name="l02284"></a>02284     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, op_prod&gt;(vec, value);
<a name="l02285"></a>02285   }
<a name="l02286"></a>02286 
<a name="l02287"></a>02287 
<a name="l02293"></a>02293   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> S1&gt;
<a name="l02294"></a>02294   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02295"></a>02295                                 <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; &gt;::type
<a name="l02296"></a><a class="code" href="namespaceviennacl.html#abaa72495bd583bcfda69157fe91d96d1">02296</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l02297"></a>02297               S1 <span class="keyword">const</span> &amp; val)
<a name="l02298"></a>02298   {
<a name="l02299"></a>02299     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; result = proxy;
<a name="l02300"></a>02300     result *= val;
<a name="l02301"></a>02301     <span class="keywordflow">return</span> result;
<a name="l02302"></a>02302   }
<a name="l02303"></a>02303 
<a name="l02304"></a>02304 
<a name="l02310"></a>02310   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l02311"></a>02311   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02312"></a>02312                                 <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; &gt;::type
<a name="l02313"></a><a class="code" href="namespaceviennacl.html#a6b89778aa52ade99eaa79ba6cb6661e5">02313</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(S1 <span class="keyword">const</span> &amp; val,
<a name="l02314"></a>02314               <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l02315"></a>02315   {
<a name="l02316"></a>02316     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; result = proxy;
<a name="l02317"></a>02317     result *= val;
<a name="l02318"></a>02318     <span class="keywordflow">return</span> result;
<a name="l02319"></a>02319   }
<a name="l02320"></a>02320   
<a name="l02323"></a>02323   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1&gt;
<a name="l02324"></a>02324   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02325"></a>02325                                 vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, op_prod&gt; &gt;::type
<a name="l02326"></a><a class="code" href="namespaceviennacl.html#a74ce674a02b729fe8b5cb3c2680540d4">02326</a>   <a class="code" href="namespaceviennacl.html#ac582aeec7eda410e350afb8ee607fa56" title="Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m...">operator * </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; v1, S1 <span class="keyword">const</span> &amp; s1)
<a name="l02327"></a>02327   {
<a name="l02328"></a>02328     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, op_prod&gt;(v1, s1);
<a name="l02329"></a>02329   }
<a name="l02330"></a>02330   
<a name="l02331"></a>02331   <span class="comment">//</span>
<a name="l02332"></a>02332   <span class="comment">// operator /</span>
<a name="l02333"></a>02333   <span class="comment">//  </span>
<a name="l02334"></a>02334   
<a name="l02340"></a>02340   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l02341"></a>02341   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02342"></a>02342                                 <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; &gt;::type
<a name="l02343"></a><a class="code" href="namespaceviennacl.html#a46676b8976492931849cedda0a8b0b7c">02343</a>   <a class="code" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f" title="Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a matrix_expression and then divided by alpha.">operator / </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l02344"></a>02344               S1 <span class="keyword">const</span> &amp; val)
<a name="l02345"></a>02345   {
<a name="l02346"></a>02346     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;typename viennacl::result_of::cpu_value_type&lt;RHS&gt;::type</a>&gt; result = proxy;
<a name="l02347"></a>02347     result /= val;
<a name="l02348"></a>02348     <span class="keywordflow">return</span> result;
<a name="l02349"></a>02349   }
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 
<a name="l02354"></a>02354   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S1&gt;
<a name="l02355"></a>02355   <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl::enable_if&lt; viennacl::is_any_scalar&lt;S1&gt;::value</a>,
<a name="l02356"></a>02356                                 vector_expression&lt; const vector_base&lt;T&gt;, <span class="keyword">const</span> S1, op_div&gt; &gt;::type
<a name="l02357"></a><a class="code" href="namespaceviennacl.html#a479f8bc932a3b68dbd4716a0766124f9">02357</a>   <a class="code" href="namespaceviennacl.html#ad2770a13264b6b8348e81926cdcb605f" title="Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a matrix_expression and then divided by alpha.">operator / </a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; v1, S1 <span class="keyword">const</span> &amp; s1)
<a name="l02358"></a>02358   {
<a name="l02359"></a>02359     <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector_base&lt;T&gt;</a>, <span class="keyword">const</span> S1, op_div&gt;(v1, s1);
<a name="l02360"></a>02360   }
<a name="l02361"></a>02361   
<a name="l02362"></a>02362 }
<a name="l02363"></a>02363 
<a name="l02364"></a>02364 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 28 2013 21:44:55 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
